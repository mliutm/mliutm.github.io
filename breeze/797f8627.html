<!DOCTYPE html><html class="hide-aside" lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>MySQL单机优化 | 清风</title><meta name="author" content="清风"><meta name="copyright" content="清风"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据库优化-单机优化内容 关系型数据优化概述;（了解） 定位慢SQL;（掌握）发现问题 分析慢sql；（掌握）分析问题 常规优化;（掌握）解决问题  一.关系型数据库优化概述​	关系型数据库:有表的存储系统就是关系型数据库!!!!    mysql  oracle sqlserver postgresql….. ​    mysql- &#x2F; postgresql-(小型公司&#x2F;大型"><meta property="og:type" content="article"><meta property="og:title" content="MySQL单机优化"><meta property="og:url" content="https://mliutm.github.io/breeze/797f8627.html"><meta property="og:site_name" content="清风"><meta property="og:description" content="数据库优化-单机优化内容 关系型数据优化概述;（了解） 定位慢SQL;（掌握）发现问题 分析慢sql；（掌握）分析问题 常规优化;（掌握）解决问题  一.关系型数据库优化概述​	关系型数据库:有表的存储系统就是关系型数据库!!!!    mysql  oracle sqlserver postgresql….. ​    mysql- &#x2F; postgresql-(小型公司&#x2F;大型"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://mliutm.github.io/img/photo-1653549892896-dde02867edee.jpg"><meta property="article:published_time" content="2024-01-14T07:32:54.000Z"><meta property="article:modified_time" content="2024-01-14T14:43:35.025Z"><meta property="article:author" content="清风"><meta property="article:tag" content="mysql"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://mliutm.github.io/img/photo-1653549892896-dde02867edee.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://mliutm.github.io/breeze/797f8627.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,top_n_per_article:1,unescape:!1,languages:{hits_empty:"找不到您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!1,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:10,languages:{author:"作者: 清风",link:"链接: ",source:"来源: 清风",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"MySQL单机优化",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-01-14 22:43:35"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,a){0!==a&&(a=864e5*a,t={value:t,expiry:(new Date).getTime()+a},localStorage.setItem(e,JSON.stringify(t)))},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!((new Date).getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=o=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.getCSS=(o,n=!1)=>new Promise((t,e)=>{const a=document.createElement("link");a.rel="stylesheet",a.href=o,n&&(a.id=n),a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">140</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">72</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/img/photo-1653549892896-dde02867edee.jpg)"><nav id="nav"><span id="blog-info"><a href="/" title="清风"><span class="site-name">清风</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MySQL单机优化</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-14T07:32:54.000Z" title="发表于 2024-01-14 15:32:54">2024-01-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-14T14:43:35.025Z" title="更新于 2024-01-14 22:43:35">2024-01-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E8%83%BD%E6%8F%90%E5%8D%87/">技能提升</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>50分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="MySQL单机优化"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="数据库优化-单机优化"><a href="#数据库优化-单机优化" class="headerlink" title="数据库优化-单机优化"></a>数据库优化-单机优化</h1><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul><li>关系型数据优化概述;（了解）</li><li>定位慢SQL;（掌握）发现问题</li><li>分析慢sql；（掌握）分析问题</li><li>常规优化;（掌握）解决问题</li></ul><h2 id="一-关系型数据库优化概述"><a href="#一-关系型数据库优化概述" class="headerlink" title="一.关系型数据库优化概述"></a>一.关系型数据库优化概述</h2><p>​	关系型数据库:有表的存储系统就是关系型数据库!!!! mysql oracle sqlserver postgresql…..</p><p>​ mysql- &#x2F; postgresql-(小型公司&#x2F;大型公司)</p><p>​ oracle(中型公司) - 收费,提倡单机</p><p>​ sqlServer</p><h3 id="1-为什么需要优化"><a href="#1-为什么需要优化" class="headerlink" title="1.为什么需要优化"></a>1.为什么需要优化</h3><h4 id="1-1-高并发读写-集群"><a href="#1-1-高并发读写-集群" class="headerlink" title="1.1.高并发读写 集群"></a>1.1.高并发读写 集群</h4><p>​	网站的用户并发性非常高，往往达到每秒上万次读写请求，对于传统关系型数据库来说，硬盘I&#x2F;O是一个很大的瓶颈。例如：双十一购物</p><p>​	双十一购物节，号称优惠比较多。所以很多人都在那天购物，特别是11.11凌晨的时候，成千上万或上亿，一起查询、浏览商品，下单购物。实质上，商品订单等信息是保存到数据库中的，那是不是很多人同时获取数据库连接，同时操作数据（读写），操作完成后关闭连接。那，是不是要同时支持很多连接，并且读写。那，现状我们一台数据库最大连接数是不是有限的。不能满足很多人同时读写，是有瓶颈的。</p><h4 id="1-2-海量数据读写-单表数据存储量比较大-分表-分库"><a href="#1-2-海量数据读写-单表数据存储量比较大-分表-分库" class="headerlink" title="1.2.海量数据读写(单表数据存储量比较大)      分表 分库"></a>1.2.海量数据读写(单表数据存储量比较大) 分表 分库</h4><p>​	网站产生的数据量是巨大的，对于关系型数据库来说，在一张包含海量数据的表中查询，效率是非常低的.例如：商品表</p><p>​	像天猫、京东等购物商城，某些数据是巨大的，比如说商品，用户等。存放到数据库中会有怎么样的效果呢？是不是一张包含很多数据（上亿条记录）的表，那我们查询、插入起来是不是速度会很慢。也就是说海量数据表的的读写速率比较低。</p><h4 id="1-3-高扩展性和可用性"><a href="#1-3-高扩展性和可用性" class="headerlink" title="1.3.高扩展性和可用性"></a>1.3.高扩展性和可用性</h4><p>​	在基于web的结构（即浏览器&#x2F;服务器）当中，数据库是最难进行横向扩展的，当一个应用系统的用户量和访问量与日俱增的时候，数据库却没有办法简单的通过添加更多的硬件和服务节点来扩展性能和负载能力。对于很多需要提供24小时不间断服务的网站来说，对数据库系统进行升级和扩展 是非常痛苦的事情，往往需要停机维护和数据迁移.</p><p>​	动态添加服务器一台数据库服务器扩充到多台时，不下电情况是很难做到的。</p><p>​	单点故障[容灾]：一台数据库服务器挂了。业务就中断，期望去找还好的数据库继续提供服务。</p><h3 id="2-对数据库性能影响的因素"><a href="#2-对数据库性能影响的因素" class="headerlink" title="2.对数据库性能影响的因素"></a>2.对数据库性能影响的因素</h3><h4 id="2-1-商业需求对性能的影响"><a href="#2-1-商业需求对性能的影响" class="headerlink" title="2.1.商业需求对性能的影响"></a>2.1.商业需求对性能的影响</h4><p>​	不合理的需求：一个论坛帖子的总数量，附加要求：实时更新</p><p>​	问：非要实时更新吗？</p><h4 id="2-2-数据库设计对性能的影响"><a href="#2-2-数据库设计对性能的影响" class="headerlink" title="2.2.数据库设计对性能的影响"></a>2.2.数据库设计对性能的影响</h4><ul><li><p>某些数据不适合基于数据库查询：比如大量数据的全文检索</p><p>解决方案：基于ES全文检索</p></li><li><p>热点数据高频查询</p><p>解决方案：合理的缓存，提高响应速度</p></li><li><p>多余的数据库交互，重复的SQL</p><p>减少数据库交互次数，减少重复相同SQL的重复执行—<strong>类型树不用递归用循环方案</strong></p></li><li><p>错误的表设计：比如几十个字段全部仍在一张表[大表,开发中尽量不要使用]</p><p>冗余字段太多（违反3FN）或者适当冗余（反三范式）；大表拆小标(垂直分表，水平分表)；常用属性分离成小表；</p></li><li><p>不合理的[索引]设计</p></li><li><p>高并发支持</p></li><li><p>海量数据支持</p></li><li><p>扩展性和可用性</p></li></ul><h4 id="2-3-SQL编写的不合理对性能的影响"><a href="#2-3-SQL编写的不合理对性能的影响" class="headerlink" title="2.3.SQL编写的不合理对性能的影响"></a>2.3.SQL编写的不合理对性能的影响</h4><ul><li><p>太多表JOIN[联表查询] –&gt;一个查询要经历哪些过程—&gt;产生笛卡尔积—&gt;使用等值条件正确数据的筛选</p><p>使用冗余字段减少JOIN</p></li><li><p>SQL太复杂</p><p>用一个非常复杂的SQL且进行了大量的计算，有时候还不如发多条简单SQL去查询数据，在代码中	去处理结果。</p></li><li><p>不合理的查询结果[* 在外面做开发尽量不要用]</p><p>SELECT * ，明明不需要那些字段，非要全部查询出来</p></li></ul><h4 id="2-4-其他方面"><a href="#2-4-其他方面" class="headerlink" title="2.4.其他方面"></a>2.4.其他方面</h4><ul><li>硬件环境</li><li>网路环境–&gt;数据IO–&gt;网络传输</li></ul><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>硬件: 买买买 软件:不合理的需求,库或表设计不合理,sql写错</p><h3 id="3-关系型数据库的优化技术整体介绍"><a href="#3-关系型数据库的优化技术整体介绍" class="headerlink" title="3.关系型数据库的优化技术整体介绍"></a>3.关系型数据库的优化技术整体介绍</h3><p>对关系型数据库的优化是一个综合性的技术，主要包括：</p><ul><li>找出执行效率低Sql（定位慢查询）- 发现问题</li><li>分析慢Sql expain sql - 分析问题</li><li>优化 - 解决问题</li></ul><p><strong>常见优化手段</strong></p><table><thead><tr><th><strong>单机</strong></th><th><strong>多机</strong></th><th>其他方案[减少数据库的压力]</th></tr></thead><tbody><tr><td>合适表结构 3ＮＦ和反3NF</td><td>集群（读写分离，让多台服务器提供服务）</td><td>Redis缓存</td></tr><tr><td>合适引擎[innoDB &#x2F; MYISAM]</td><td>分布式（把不同的业务分给不同的集群处理）</td><td>ElasticSearch全文检索</td></tr><tr><td>索引[给字段建立索引]</td><td></td><td>页面静态化</td></tr><tr><td>分表(垂直分表和水平分表)</td><td></td><td></td></tr><tr><td>Sql优化技巧[查询语句尽量使用到索引]</td><td></td><td></td></tr><tr><td>升硬件</td><td></td><td></td></tr><tr><td>升网络带宽</td><td></td><td></td></tr></tbody></table><p><strong>注意：</strong></p><p>1、优化方案不仅可以适用在mysql,还可以使用于oracle等关系型数据库,只是命令不同罢了。</p><p>2、优化时先考虑单台数据库服务器，如果单台优化完成后,实在满足不了需求再考虑多机集群和分布式。(有的公司不会使用多台数据库)</p><h3 id="4-数据准备-模拟海量数据-搞出问题-才能分析问题-找到原因-解决问题"><a href="#4-数据准备-模拟海量数据-搞出问题-才能分析问题-找到原因-解决问题" class="headerlink" title="4 数据准备-模拟海量数据,搞出问题,才能分析问题,找到原因,解决问题"></a>4 数据准备-模拟海量数据,搞出问题,才能分析问题,找到原因,解决问题</h3><p>见“准备数据.doc“</p><h2 id="二-定位慢SQL"><a href="#二-定位慢SQL" class="headerlink" title="二.定位慢SQL"></a>二.定位慢SQL</h2><h3 id="1-Mysql执行原理-mysql的架构"><a href="#1-Mysql执行原理-mysql的架构" class="headerlink" title="1.Mysql执行原理(mysql的架构)"></a>1.Mysql执行原理(mysql的架构)</h3><p>select * from emp where id&lt;50 and name like ‘%s%’</p><p>select * from emp where name like ‘%s%’ and id&lt;50</p><blockquote><p>上面这两条sql的执行效率是一样的，因为mysql自己会对sql语句进行相应的优化</p></blockquote><img src="/breeze/797f8627/1635844211527.png" alt="1635844211527" style="zoom:80%"><p>mysql服务端主要分为Server层和存储引擎层</p><p>Server层：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog日志模块。</p><p>存储引擎： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持InnoDB、MyISAM、Memory等多个存储引擎，其中InnoDB引擎有自有的日志模块redolog 模块。InnoDB 5.5版本作为默认引擎。</p><ul><li>连接器</li></ul><p>主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即时管理员修改了该用户的权限，该用户也是不受影响的。</p><ul><li>查询缓存</li></ul><p>​ 连接建立后，执行查询语句的时候，会先查询缓存，Mysql会先校验这个sql是否执行过，以Key-Value的形式缓存在内存中，Key是查询预计，Value是结果集。如果缓存key被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。</p><p>Mysql 查询不建议使用缓存，因为对于经常更新的数据来说，缓存的有效时间太短了，往往带来的效果并不好，对于不经常更新的数据来说，使用缓存还是可以的，Mysql 8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。 <strong>还不如用redis中央缓存甚至mybatis二级缓存</strong></p><ul><li>分析器</li></ul><p>mysql 没有命中缓存，那么就会进入分析器，分析器主要是用来分析SQL语句是来干嘛的，分析器也会分为几步：</p><p>第一步，词法分析，一条SQL语句有多个字符串组成，首先要提取关键字，比如select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。</p><p>第二步，语法分析，主要就是判断你输入的sql是否正确，是否符合mysql的语法。</p><p>完成这2步之后，mysql就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。</p><ul><li>优化器</li></ul><p>优化器的作用就是它认为的最优的执行方案去执行（虽然有时候也不是最优），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。</p><ul><li>执行器</li></ul><p>当选择了执行方案后，mysql就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用存储引擎的接口，返回接口执行的结果。</p><p>​ <strong>所有的sql都要发到mysql执行，mysql可以监控到这些sql执行，并且有需要可以保存下来。我们就能找到慢sql。</strong></p><p>​ 所有数据操作最终都交给存储引擎来做.</p><h3 id="2-找出执行慢sql"><a href="#2-找出执行慢sql" class="headerlink" title="2.找出执行慢sql"></a>2.找出执行慢sql</h3><p>​	我们使用数据库，实质上就是连接数据库，发送SQL、服务器执行SQL并返回结果、关闭连接。也就是所有的SQL语句MySQL服务器都能感知到，比如执行了那些SQL，都执行了多少时间等。我们做优化就是找出执行时间长的Sql进行优化。问题是： 如何从一个大项目中，迅速的定位执行速度慢的语句. (定位慢查询)</p><p><strong>所有的sql都是由mysql执行，当它发现客户端执行sql慢的时候，会把结果记录下来。方便用户查找定位。</strong></p><h4 id="2-1-查询数据库-mysql-基本状态"><a href="#2-1-查询数据库-mysql-基本状态" class="headerlink" title="2.1.查询数据库(mysql)基本状态"></a>2.1.查询数据库(mysql)基本状态</h4><p>首先我们了解mysql数据库的一些运行状态(比如想知道当前mysql运行的时间&#x2F;一共执行了多少次select&#x2F;update&#x2F;delete.. &#x2F; 当前连接&#x2F;最大连接)</p><ul><li><p>show status like ‘uptime’;</p></li><li><p>CRUD执行次数</p><p>show status like ‘%Com_%’</p><p>show status like ‘%Com_select%’</p><p>show status like ‘%Com_insert%’</p><p>show status like ‘%Com_update%’</p><p>show status like ‘%Com_delete%’</p></li></ul><p>完整语法：Show session&#x2F;global status like ‘%Com_select%’</p><p>show [session|global] status like …. 如果你不写[session|global] 默认是session 会话(指取出当前窗口的执行)，如果你想看所有(从mysql 启动到现在)，则应该 global。</p><ul><li><p>查看INNODB引擎的CRUD行数</p><p>show status like ‘%Innodb_rows%’;</p></li><li><p>查询所有连接数</p><p>show status like ‘connections’</p></li><li><p>查看服务器响应的最大使用连接数</p><p>show status like ‘Max_used_connections’</p></li></ul><p>通过该连接数可以知道应用的DB并发，从而设置Mysql的最大连接数</p><p>通过查询（工作环境）最大并发连接数可以配置作为我们配置mysql最大连接数的依据。通常，mysql的最大连接数默认是100(mysql55),151(mysql57), 最大可以达到16384（理论上）。可以通过my.ini中的max_connections&#x3D;100配置项目进行修改</p><h4 id="2-2-定位慢查询"><a href="#2-2-定位慢查询" class="headerlink" title="2.2.定位慢查询"></a>2.2.定位慢查询</h4><ul><li><p>查询慢查询次数</p><p>show status like ‘slow_queries’ 慢查询，通常指花了2S以上的查询(默认10s)</p></li><li><p>查看和修改慢查询时间阈值</p><p>show variables like ‘long_query_time’ ; &#x2F;&#x2F;可以显示当前慢查询时间 ， 默认阈值 10s</p><p>set long_query_time&#x3D;1 ;	&#x2F;&#x2F;可以修改慢查询时间 ， 可以通过my.ini永久修改</p><p>注意：直接修改global 的long_query_time 之后在当前的的窗口中是没有效果的，在新打开的窗口中	才会有效果。如果想让本窗口也有效果 的话，不用加 global关键字。</p></li><li><p>查看慢查询的日志路径</p><p>show variables like ‘%slow_query_log%’;</p><p>5.6 以上版本使用： show variables like ‘%slow-query-log-file%’</p></li></ul><p><img src="/breeze/797f8627/1635844542184.png" alt="1635844542184"></p><p>可以使用 select * from mysql.slow_log ，查看日志内容</p><ul><li><p>开启全局日志慢查询日志</p><p>SET GLOBAL slow_query_log &#x3D; 1 &#x2F;&#x2F;开启慢查询日志</p><p>SET GLOBAL slow_query_log_file&#x3D;’路径\Data\LAPTOP-20VLGCRC-slow.log’ &#x2F;&#x2F;指定慢查询日志文件</p></li></ul><p>上面的修改是临时性的，要永久修改还是要改my.ini文件</p><ul><li><p>把查询日志记录到table</p><p>通过执行： set global log_output&#x3D;’TABLE’; 或者修改my.ini ：log_output&#x3D;”FILE,TABLE”</p><p>通过执行：select * from mysql.slow_log; 查看日志内容</p></li></ul><p><img src="/breeze/797f8627/1635844620001.png" alt="1635844620001"></p><ul><li><p>记录未使用索引的SQL</p><p>set global log_queries_not_using_indexes&#x3D;ON</p></li></ul><p>配置总结</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="comment">#慢SQL阈值</span></span><br><span class="line"><span class="attr">long_query_time</span>=<span class="number">0.00001</span></span><br><span class="line"><span class="comment">#开启慢sql日志</span></span><br><span class="line"><span class="attr">slow_query_log</span>=<span class="number">1</span></span><br><span class="line"><span class="comment">#慢SQL日志</span></span><br><span class="line"><span class="attr">slow_query_log_file</span>=<span class="string">&quot;D:/opensource/MySQL/MySQL Server 5.5/slow.log&quot;</span></span><br><span class="line"><span class="comment">#日志记录到文件和表中</span></span><br><span class="line"><span class="attr">log_output</span>=<span class="string">&quot;FILE,TABLE&quot;</span></span><br></pre></td></tr></table></figure><h4 id="2-3-步骤总结"><a href="#2-3-步骤总结" class="headerlink" title="2.3.步骤总结"></a>2.3.步骤总结</h4><ol><li><p>关闭原有mysql服务</p></li><li><p>修改mysql.ini支持记录慢查询到文件</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="comment">#慢SQL阈值</span></span><br><span class="line"><span class="attr">long_query_time</span>=<span class="number">0.00001</span></span><br><span class="line"><span class="comment">#开启慢sql日志</span></span><br><span class="line"><span class="attr">slow_query_log</span>=<span class="number">1</span></span><br><span class="line"><span class="comment">#慢SQL日志</span></span><br><span class="line"><span class="attr">slow_query_log_file</span>=<span class="string">&quot;D:/opensource/MySQL/MySQL Server 5.5/slow.log&quot;</span></span><br><span class="line"><span class="comment">#日志记录到文件和表中</span></span><br><span class="line"><span class="attr">log_output</span>=<span class="string">&quot;FILE,TABLE&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>重新启动,让配置生效</p></li><li><p>构造慢sql</p></li><li><p>到日志文件中找慢sql（data.dir）</p></li></ol><p><strong>开启日志记录是会影响性能的,什么时候开启慢查询,开启后,覆盖所有功能跑一遍,没有才是暂时没有!</strong></p><p><strong>敏捷迭代: 确定迭代计划(要开发哪些功能,要改哪些bug)-分配对多个研发人员研发&#x2F;分配给测试写测试用例—-并行开发(本地)—开发者自验(git代码打包部署开发环境)-转测试(部署测试环境覆盖测试)-改bug-这个版本结束-多个迭代都开发完成-上线</strong></p><ul><li>开发者自验：</li></ul><p>​ 开发完成后，需要统一打包，统一部署，统一验证，可以在自验环境开启慢查询记录</p><ul><li>测试人员测试：</li></ul><p>​ 测试人员需要测试所有功能。 可以在测试环境开启慢查询记录.</p><p>​ – 应该有一条测试用例,测试完成后,到慢查询日志中找是否有慢查询</p><ul><li><p>项目上线：开一段时间,把它关了.或者不开</p><p>用户用了所有功能。</p></li></ul><h3 id="3-分析sql语句"><a href="#3-分析sql语句" class="headerlink" title="3.分析sql语句"></a>3.分析sql语句</h3><h4 id="3-1-查看执行的线程状态"><a href="#3-1-查看执行的线程状态" class="headerlink" title="3.1  查看执行的线程状态"></a>3.1 查看执行的线程状态</h4><p>show processlist 查看正在执行的连接-死锁</p><p>可以用来查看当前数据库SQL正在执行的情况，定位SQL的状态<img src="/breeze/797f8627/wps2119.tmp.jpg" alt="img"></p><p>可以通过state查看SQL的状态，比如Locked 就是被锁住了</p><p>Checking table<br>　正在检查数据表（这是自动的）。<br>Closing tables<br>　正在将表中修改的数据刷新到磁盘中，同时正在关闭已经用完的表。这是一个很快的操作，如果不是这样的话，就应该确认磁盘空间是否已经满了或者磁盘是否正处于重负中。<br>Connect Out<br>　复制从服务器正在连接主服务器。<br>Copying to tmp table on disk<br>　由于临时结果集大于tmp_table_size，正在将临时表从内存存储转为磁盘存储以此节省内存。<br>Creating tmp table<br>　正在创建临时表以存放部分查询结果。<br>deleting from main table<br>　服务器正在执行多表删除中的第一部分，刚删除第一个表。<br>deleting from reference tables<br>　服务器正在执行多表删除中的第二部分，正在删除其他表的记录。<br>Flushing tables<br>　正在执行FLUSH TABLES，等待其他线程关闭数据表。<br>Killed<br>　发送了一个kill请求给某线程，那么这个线程将会检查kill标志位，同时会放弃下一个kill请求。MySQL会在每次的主循环中检查kill标志位，不过有些情况下该线程可能会过一小段才能死掉。如果该线程程被其他线程锁住了，那么kill请求会在锁释放时马上生效。<br><strong>Locked</strong><br>　被其他查询锁住了。<br>Sending data<br>　正在处理SELECT查询的记录，同时正在把结果发送给客户端。<br>Sorting for group<br>　正在为GROUP BY做排序。<br>　Sorting for order<br>　正在为ORDER BY做排序。<br>Opening tables<br>　这个过程应该会很快，除非受到其他因素的干扰。例如，在执ALTER TABLE或LOCK TABLE语句行完以前，数据表无法被其他线程打开。正尝试打开一个表。<br>Removing duplicates<br>　正在执行一个SELECT DISTINCT方式的查询，但是MySQL无法在前一个阶段优化掉那些重复的记录。因此，MySQL需要再次去掉重复的记录，然后再把结果发送给客户端。<br>Reopen table<br>　获得了对一个表的锁，但是必须在表结构修改之后才能获得这个锁。已经释放锁，关闭数据表，正尝试重新打开数据表。<br>Repair by sorting<br>　修复指令正在排序以创建索引。<br>Repair with keycache<br>　修复指令正在利用索引缓存一个一个地创建新索引。它会比Repair by sorting慢些。<br>Searching rows for update<br>　正在讲符合条件的记录找出来以备更新。它必须在UPDATE要修改相关的记录之前就完成了。<br>Sleeping<br>　正在等待客户端发送新请求.<br>System lock<br>　正在等待取得一个外部的系统锁。如果当前没有运行多个mysqld服务器同时请求同一个表，那么可以通过增加–skip-external-locking参数来禁止外部系统锁。<br>Upgrading lock<br>　INSERT DELAYED正在尝试取得一个锁表以插入新记录。<br>Updating<br>　正在搜索匹配的记录，并且修改它们。<br>User Lock<br>　正在等待GET_LOCK()。<br>Waiting for tables<br>　该线程得到通知，数据表结构已经被修改了，需要重新打开数据表以取得新的结构。然后，为了能的重新打开数据表，必须等到所有其他线程关闭这个表。以下几种情况下会产生这个通知：FLUSH TABLES tbl_name, ALTER TABLE, RENAME TABLE, REPAIR TABLE, ANALYZE TABLE,或OPTIMIZE TABLE。<br>waiting for handler insert<br>　INSERT DELAYED已经处理完了所有待处理的插入操作，正在等待新的请求。<br>　大部分状态对应很快的操作，只要有一个线程保持同一个状态好几秒钟，那么可能是有问题发生了，需要检查一下。<br>　还有其他的状态没在上面中列出来，不过它们大部分只是在查看服务器是否有存在错误是才用得着。</p><h4 id="3-2-explan"><a href="#3-2-explan" class="headerlink" title="3.2.explan"></a>3.2.explan</h4><p>通过 explain 语句可以分析，mysql如何执行你的sql语句.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_course </span><br></pre></td></tr></table></figure><p><img src="/breeze/797f8627/1635844971708.png" alt="1635844971708"></p><p>解释：该SQL是一个简单的select语句，查询的是t_couse表，使用的是全表扫描，没有用到索引，找到所需的记录所需要读取11行数据</p><table><thead><tr><th>信息</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>查询的序号，包含一组数字，表示查询中执行select子句或操作表的顺序 <strong>两种情况</strong> id相同，执行顺序从上往下 id不同，id值越大，优先级越高，越先执行</td></tr><tr><td>select_type</td><td>查询类型，主要用于区别普通查询，联合查询，子查询等的复杂查询 1、simple ——简单的select查询，查询中不包含子查询或者UNION 2、primary ——查询中若包含任何复杂的子部分，最外层查询被标记 3、subquery——在select或where列表中包含了子查询 4、derived——在from列表中包含的子查询被标记为derived（衍生），MySQL会递归执行这些子查询，把结果放到临时表中 5、union——如果第二个select出现在UNION之后，则被标记为UNION，如果union包含在from子句的子查询中，外层select被标记为derived 6、union result:UNION 的结果</td></tr><tr><td>table</td><td>输出的行所引用的表</td></tr><tr><td>type</td><td>显示联结类型，显示查询使用了何种类型，按照从最佳到最坏类型排序 1、system：表中仅有一行（&#x3D;系统表）这是const联结类型的一个特例。 2、const：表示通过索引一次就找到，const用于比较primary key或者unique索引。因为只匹配一行数据，所以如果将主键置于where列表中，mysql能将该查询转换为一个常量 3、eq_ref:唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于唯一索引或者主键扫描 4、ref:非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，可能会找多个符合条件的行，属于查找和扫描的混合体 5、range:只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引，一般就是where语句中出现了between,in等范围的查询。这种范围扫描索引扫描比全表扫描要好，因为它开始于索引的某一个点，而结束另一个点，不用全表扫描 6、index:index 与all区别为index类型只遍历索引树。通常比all快，因为索引文件比数据文件小很多。 7、<strong>all</strong>：遍历全表以找到匹配的行 注意:一般保证查询至少达到range级别，最好能达到ref。</td></tr><tr><td>possible_keys</td><td>指出MySQL能使用哪个索引在该表中找到行</td></tr><tr><td>key</td><td>显示MySQL实际决定使用的键(索引)。如果没有选择索引,键是NULL。查询中如果使用覆盖索引，则该索引和查询的select字段重叠。</td></tr><tr><td>key_len</td><td>表示索引中使用的字节数，该列计算查询中使用的索引的长度在不损失精度的情况下，长度越短越好。如果键是NULL,则长度为NULL。该字段显示为索引字段的最大可能长度，并非实际使用长度。</td></tr><tr><td>ref</td><td>显示索引的哪一列被使用了，如果有可能是一个常数，哪些列或常量被用于查询索引列上的值</td></tr><tr><td>rows</td><td>根据表统计信息以及索引选用情况，大致估算出找到所需的记录所需要读取的行数</td></tr><tr><td>Extra</td><td>包含不适合在其他列中显示，但是十分重要的额外信息 1、Using filesort：说明mysql会对数据适用一个外部的索引排序。而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成排序操作称为“文件排序” 2、Using temporary:使用了临时表保存中间结果，mysql在查询结果排序时使用临时表。常见于排序order by和分组查询group by。 3、Using index:表示相应的select操作用使用覆盖索引，避免访问了表的数据行。如果同时出现using where，表名索引被用来执行索引键值的查找；如果没有同时出现using where，表名索引用来读取数据而非执行查询动作。 4、Using where :表明使用where过滤 5、using join buffer:使用了连接缓存 6、impossible where:where子句的值总是false，不能用来获取任何元组 7、select tables optimized away：在没有group by子句的情况下，基于索引优化Min、max操作或者对于MyISAM存储引擎优化count（*），不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。 8、distinct：优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作。</td></tr></tbody></table><h4 id="3-3-分析详细执行过程"><a href="#3-3-分析详细执行过程" class="headerlink" title="3.3 分析详细执行过程"></a>3.3 分析详细执行过程</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span> 开启Profiling</span><br><span class="line"></span><br><span class="line"># 使用 cmd去执行mysql，不用navcat工具</span><br><span class="line"></span><br><span class="line">Mysql<span class="operator">&gt;</span> <span class="keyword">set</span> profiling <span class="operator">=</span> <span class="number">1</span>;    </span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>开启<span class="keyword">SQL</span>的profiling统计Mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> uer   </span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>执行sqlMysql<span class="operator">&gt;</span> <span class="keyword">set</span> profiling <span class="operator">=</span> <span class="number">0</span>;   </span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>关闭profiling</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># <span class="number">2.</span> 查看记录的Query</span><br><span class="line"></span><br><span class="line">Mysql<span class="operator">&gt;</span> <span class="keyword">show</span> profiles;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"># <span class="number">3.</span> 查看cpu,io等</span><br><span class="line"></span><br><span class="line">Mysql<span class="operator">&gt;</span> <span class="keyword">show</span> profile cpu,block io <span class="keyword">for</span> query <span class="number">6</span>;</span><br><span class="line">Mysql<span class="operator">&gt;</span> <span class="keyword">show</span> profile <span class="keyword">for</span> query <span class="number">6</span>;</span><br></pre></td></tr></table></figure><h2 id="三-单机优化（常规优化）"><a href="#三-单机优化（常规优化）" class="headerlink" title="三.单机优化（常规优化）"></a>三.单机优化（常规优化）</h2><h3 id="1-范式"><a href="#1-范式" class="headerlink" title="1.范式"></a>1.范式</h3><p>范式（规范）-常见有三种规范3NF</p><p>表的范式，是首先符合1NF, 才能满足2NF , 进一步满足3NF</p><ul><li><p>1NF: 即表的列的具有<strong>原子性</strong>,不可再分解，即列的信息，不能分解.只要数据库是关系型数据库(mysql&#x2F;oracle&#x2F;db2&#x2F;sysbase&#x2F;sql server)，就自动的满足1NF.关系型数据库中是不允许分割列的即：列唯一</p></li><li><p>2NF : 表中的记录是唯一的.通常我们设计一个<strong>主键</strong>来实现，即：行唯一</p></li><li><p>3NF： 即表中不要有冗余数据，就是说，表的信息如果能够被推导出来，就不应该单独的设计一个字段来存放。可以理解为：A表不能出现B表中非主键字段。 <strong>外键</strong></p><p><img src="/breeze/797f8627/1666594542440.png" alt="1666594542440"></p></li><li><p>反3NF ：3NF指的是A表不能出现B表中非主键字段，如果出现了，那这个字段就是冗余字段，违反了三范式。</p></li></ul><h4 id="1-1-冗余字段"><a href="#1-1-冗余字段" class="headerlink" title="1.1.冗余字段"></a>1.1.冗余字段</h4><p>举例：<strong>使用冗余字段减少JOIN连表提高查询效率</strong></p><p><img src="/breeze/797f8627/1666596812687.png" alt="1666596812687"></p><p>​ 方案1: 执行两条sql</p><p>​ 改店铺名称</p><p>​ 改该店铺下面的车辆信息里面的店铺的名称(批量修改)</p><p>​ 方案2: 执行一条sql,触发一个触发器执行</p><p>​ 触发器 存储过程,都是提前写好了,编译保存到数据库,只需要调用一下就ok,效率很高.</p><p><img src="/breeze/797f8627/1666597255118.png" alt="1666597255118"></p><p>车辆表中出现了店铺表的非主键字典，shop_name ，这违反了三范式，这种字段叫冗余字段。 冗余字段的好处是减少表的JOIN ,提高SQL的执行效率。坏处是原始值发生变动，冗余的值也需要跟着变</p><p>数据库触发器：</p><p><a target="_blank" rel="noopener" href="https://www.python100.com/html/24688.html">https://www.python100.com/html/24688.html</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> updateShopNameTrigger AFTER <span class="keyword">UPDATE</span> <span class="keyword">ON</span> t_org_shop <span class="keyword">for</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">		<span class="keyword">UPDATE</span> T_car_car  <span class="keyword">SET</span> shopname <span class="operator">=</span> new.name <span class="keyword">WHERE</span> shop_id <span class="operator">=</span> new.id;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> triggers;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> updateShopNameTrigger;</span><br></pre></td></tr></table></figure><p>跨库?怎么处理—&gt;服务之间的接口调用—&gt;分布式事务</p><p>mysql其他高级知识</p><p>1)自定义函数(封装操作给多个地方调用) -完成小功能 concat() now() … sum count–&gt;聚合函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> getNthHighestSalary(N <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	#声明一个变量a</span><br><span class="line">	<span class="keyword">declare</span> a <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">	#给变量赋值</span><br><span class="line">	<span class="keyword">set</span> a<span class="operator">=</span>N<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">RETURN</span> a;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> getNthHighestSalary(<span class="number">2</span>) 函数名(实参)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2)触发器</p><p><img src="/breeze/797f8627/1690267703006.png" alt="1690267703006"></p><p>3)存储过程–封装很多sql逻辑,实现某种业务逻辑</p><p>​ 不同多次执行sql,提前编译只需要调用就ok,效率杠杠的…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="comment">//</span></span><br><span class="line">CREATE PROCEDURE <span class="title function_">student</span><span class="params">(过程参数)</span></span><br><span class="line">BEGIN</span><br><span class="line">   SELECT * FROM student;</span><br><span class="line">END</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">call 过程名(参数)</span><br><span class="line">    </span><br><span class="line"> mybatis   </span><br><span class="line">     &lt;select id=<span class="string">&quot;callStoredProcedure&quot;</span> statementType=<span class="string">&quot;CALLABLE&quot;</span>&gt;</span><br><span class="line">       &#123;call <span class="title function_">your_stored_procedure</span><span class="params">(#&#123;param1, mode=IN, jdbcType=VARCHAR&#125;, #&#123;param2, mode=OUT, jdbcType=VARCHAR&#125;)</span>&#125;</span><br><span class="line">   &lt;/select&gt;</span><br></pre></td></tr></table></figure><p>4)视图:把复杂查询封装为视图,以后只需要调用视图就ok—只能做查询,是一条sql语句</p><p>​ <img src="/breeze/797f8627/1679985728543.png" alt="1679985728543"></p><p><img src="/breeze/797f8627/1690268356843.png" alt="1690268356843"></p><h3 id="2-存储引擎"><a href="#2-存储引擎" class="headerlink" title="2.存储引擎"></a>2.存储引擎</h3><h4 id="2-1-存储引擎介绍"><a href="#2-1-存储引擎介绍" class="headerlink" title="2.1.存储引擎介绍"></a>2.1.存储引擎介绍</h4><p>分类：mysql:myisam,innodb,memory</p><p>优缺点：问 MyISAM 和 INNODB的区别(主要)</p><ul><li><strong>事务安全：MYISAM不支持事务，INNODB支持</strong></li><li>查询和添加速度：MyISAM速度快，INNODB速度慢</li><li>锁机制 MyIsam表锁 innodb行锁</li><li>支持全文索引：MyIsam支持(默认不支持中文,需要一些插件,还不如es)，innodb不支持(5.6以后可以支持)</li><li><strong>外键 MyISAM 不支持外键约束， INNODB支持外键. (通常不设置物理外键，通常是在程序中保证数据的一致)</strong></li></ul><p><img src="/breeze/797f8627/1635845224358.png" alt="1635845224358"></p><h4 id="2-2-使用场景"><a href="#2-2-使用场景" class="headerlink" title="2.2.使用场景"></a>2.2.使用场景</h4><ul><li><p>MyISAM存储引擎：如果表对事务要求不高，同时是以查询和添加为主的，我们考虑使用myisam存储引擎. 比如 bbs（论坛，博客） 中的 发帖表，回复表. —项目实战：车辆百科，文章</p></li><li><p>INNODB存储引擎: 对事务要求高，保存的数据都是重要数据，我们建议使用INNODB,比如订单表，账号表.</p></li><li><p>Memory 存储：比如我们数据变化频繁，不需要入库，同时又频繁的查询和修改，我们考虑使用memory, 速度极快.</p></li></ul><p>操作</p><ul><li>创建表时指定存储引擎</li></ul><p>create table 表名(字段列表) engine 存储引擎名称;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_temp(id <span class="type">BIGINT</span> <span class="keyword">PRIMARY</span> key,name <span class="type">VARCHAR</span>(<span class="number">20</span>))  ENGINE myisam;</span><br></pre></td></tr></table></figure><p>注意：如果不指定则使用默认的存储引擎，这个默认实在my.ini配置</p><p>My.ini增加配置： default-storage-engine&#x3D;INNODB</p><p>修改存储引擎：alter table table_name engine&#x3D;innodb;</p><h3 id="3-Mysql的索引-重点中的重点"><a href="#3-Mysql的索引-重点中的重点" class="headerlink" title="3.Mysql的索引 重点中的重点"></a>3.Mysql的索引 重点中的重点</h3><h4 id="3-1-索引的认识"><a href="#3-1-索引的认识" class="headerlink" title="3.1.索引的认识"></a>3.1.索引的认识</h4><p>​	索引（Index）是帮助DBMS（mysql等）高效获取数据的<strong>数据结构</strong>，索引是为了加速对表中数据行的检索而创建的一种分散的存储结构。如同：字典的目录。</p><p>比如：根据id查找数据，如果没有使用索引，就会从第一行记录开始扫表，直到找到想要的ID为止，当数据量比较大，恰好想要的数据在最后一条，那么查询速度就会非常慢：如： where id &#x3D; 9</p><p><img src="/breeze/797f8627/1635845340503.png" alt="1635845340503"></p><p>使用索引：Id列使用索引后，Mysql会为id列维护一个索引结构，数据检索的时候就从索引中进行检索，能大大提高检索速度。举例：</p><p><img src="/breeze/797f8627/1635845354979.png" alt="1635845354979"></p><p>如果 没有使用索引，要全表查询，如果有了索引先在索引中找到对应的地址，然后关联过去！而且索引中查找效率贼高。可以使用b+树等数据结构增强查询效率</p><h4 id="3-2-mysql索引的类型"><a href="#3-2-mysql索引的类型" class="headerlink" title="3.2.mysql索引的类型"></a>3.2.mysql索引的类型</h4><p>mysql中索引的分类</p><p><img src="/breeze/797f8627/1635845531010.png" alt="1635845531010"></p><ul><li><p><strong>普通索引Normal：允许重复的值出现，可以在任何字段上面添加</strong></p></li><li><p><strong>唯一索引 Unique：除了不能有重复的记录外，其它和普通索引一样，可以在值是唯一的字段添加（用户名、手机号码、身份证、email，QQ），可以为null,并且可以有多个null</strong></p></li><li><p><strong>主键索引：是随着设定主键而创建的，也就是把某个列设为主键的时候，数据库就会給该列创建索引。这就是主键索引.唯一且没有null值,</strong></p></li><li><p>全文索引：用来对表中的文本域(char，varchar，text,bigtext)进行索引， 全文索引针对MyISAM有用InnoDB不支持全文索引，所以一般不用,默认只支持英文. -使用ES,Lucene代替就ok</p></li><li><p>空间索引: 空间索引是对空间数据类型的字段建立的索引，MySQL 中的空间数据类型有 4 种：geometry、point、linestring、polygon。MySQL 使用 spatial 关键字进行扩展，使得能够用于创建正规索引类似的语法创建空间索引。创建空间索引的列，必须将其声明为 not null。</p><p>空间索引只能在存储引擎为 MyISAM 的表中创建。</p></li></ul><h4 id="3-3-mysql常见存储引擎支持索引方式构"><a href="#3-3-mysql常见存储引擎支持索引方式构" class="headerlink" title="3.3. mysql常见存储引擎支持索引方式构"></a>3.3. mysql常见存储引擎支持索引方式构</h4><h5 id="3-3-1-MyISAM是MySQL数据库中一种常用的存储引擎-如果你的数据库使用的是myisam-你创建索引的时候可以选择以下索引方式"><a href="#3-3-1-MyISAM是MySQL数据库中一种常用的存储引擎-如果你的数据库使用的是myisam-你创建索引的时候可以选择以下索引方式" class="headerlink" title="3.3.1 MyISAM是MySQL数据库中一种常用的存储引擎   如果你的数据库使用的是myisam,你创建索引的时候可以选择以下索引方式"></a>3.3.1 MyISAM是MySQL数据库中一种常用的存储引擎 如果你的数据库使用的是myisam,你创建索引的时候可以选择以下索引方式</h5><p>​	它支持多种索引类型，包括以下四种：</p><ol><li><strong>B-tree索引</strong>：也称为普通索引，是最常用的索引类型，适合用于全值匹配查询和前缀查询。–底层用到了b+树</li><li>全文本索引：用于对文本进行全文搜索。MyISAM引擎支持全文本索引的创建和查询。 全文检索算法</li><li>前缀索引：适用于文本列，只对字符列的前若干个字符建立索引，可以提高索引效率，但精确度会有所降低。</li><li>空间索引：用于地理信息系统（GIS）和其他需要处理空间数据的应用程序，可以加快空间数据查询的速度。</li></ol><h5 id="3-3-2-InnoDB是MySQL数据库中另一种常用的存储引擎"><a href="#3-3-2-InnoDB是MySQL数据库中另一种常用的存储引擎" class="headerlink" title="3.3.2 InnoDB是MySQL数据库中另一种常用的存储引擎"></a>3.3.2 InnoDB是MySQL数据库中另一种常用的存储引擎</h5><p>​	它也支持多种索引类型，包括以下五种：</p><ol><li><p><strong>B-tree索引</strong>：与MyISAM相同，也是最常用的索引类型。</p></li><li><p>全文本索引：用于对文本进行全文搜索。InnoDB引擎支持全文本索引的创建和查询。</p></li><li><p>哈希索引：通过把索引列的值哈希为一个整数，然后以该整数作为索引建立索引。只能用于精确匹配。</p></li><li><p>空间索引：与MyISAM相同，可用于地理信息系统（GIS）和其他需要处理空间数据的应用程序。</p></li><li><p>全文本检索索引（FTS）：这是一种针对英文全文搜索的特殊索引类型，可以建立在CHAR、VARCHAR、TEXT等数据类型的列上。与全文本索引不同，全文本检索索引不提供通配符搜索。</p><p>在实际应用中，我们需要根据具体业务场景选择不同的<strong>索引类型</strong>并且选择对应<strong>索引方式</strong>来提升数据库的查询效率。需要注意的是，InnoDB引擎使用B-tree索引时，其使用方式与MyISAM略有不同，因此在具体使用中需要注意其差异。但是最终都是使用<strong>B+树这种数据结构</strong></p></li></ol><h5 id="3-3-3-b-tree索引方式"><a href="#3-3-3-b-tree索引方式" class="headerlink" title="3 3.3 b-tree索引方式"></a>3 3.3 b-tree索引方式</h5><p>在MySQL数据库中，B-tree是一种常用的索引方式，被广泛应用于数据表的索引中。MySQL中的B-tree索引利用了B+tree树的特点，支持快速的查找、插入和删除操作，并能提升查询效率和性能。下面是MySQL B-tree索引的一些特点：</p><ol><li>MySQL中的B-tree索引采用多路搜索树的结构，通常称为<strong>B+树。</strong></li><li>所有数据都存储在叶子节点中，而非叶子节点只包含指向下一级节点的指针，可以加速范围查询和区间查询。</li><li>在MySQL中，每个索引项包含一个关键字和一个对应的行指针，行指针指向数据表中的某一行。</li><li>MySQL B-tree索引的分裂和合并策略较为灵活，能够自适应地调整节点大小，避免出现空洞和浪费空间。</li><li>MySQL支持在B-tree索引的基础上建立前缀索引和全文搜索索引等，以满足不同的查询需求。</li></ol><p>总之，MySQL B-tree索引是一种高效的索引结构,因为它底层使用B+数据，其优点在于支持快速的查找、插入和删除操作，而且能够提升查询效率和性能，因此在实际的应用中被广泛采用。</p><h4 id="3-4-b-tree索引方式的底层原理（超级重要）-说一下索引原理-必问"><a href="#3-4-b-tree索引方式的底层原理（超级重要）-说一下索引原理-必问" class="headerlink" title="3.4.b-tree索引方式的底层原理（超级重要）-说一下索引原理-必问"></a>3.4.b-tree索引方式的底层原理（超级重要）-说一下索引原理-必问</h4><p>​ mysql中使用得最多的索引方式是b-tree,底层使用的是b+树这种数据结构……….</p><p>但是在myisam和innodb中它们的实现有有差距.</p><p>在innodb索引和数据放到一起的?</p><p>在myisam….</p><h5 id="1-InnoDB与myisam索引物理结构"><a href="#1-InnoDB与myisam索引物理结构" class="headerlink" title="1.InnoDB与myisam索引物理结构"></a>1.InnoDB与myisam索引物理结构</h5><h6 id="1-1-innodb-数据和索引在一个文件中"><a href="#1-1-innodb-数据和索引在一个文件中" class="headerlink" title="1.1 innodb-数据和索引在一个文件中"></a>1.1 innodb-数据和索引在一个文件中</h6><p>MySQL如果使用InnoDB存储引擎，数据库文件类型就包括.frm、ibdata1，默认存储到“C:\ProgramData\MySQL\MySQL Server 5.5\data”目录下</p><p>表结构文件：xxx.frm</p><p><img src="/breeze/797f8627/1635845748935.png" alt="1635845748935"></p><p>索引数据文件：ibdata1</p><p><img src="/breeze/797f8627/1635845761437.png" alt="1635845761437"></p><p>InnoDB使用了b+tree作为索引结构，在InnoDB中索引和数据在同一个文件ibdata1，所以数据会存储在索引结构中。</p><h6 id="1-2-myisam-数据和索引分开放"><a href="#1-2-myisam-数据和索引分开放" class="headerlink" title="1.2 myisam-数据和索引分开放"></a>1.2 myisam-数据和索引分开放</h6><p>myisam的数据和索引是分开的，所以树的节点指向的是数据的地址。数据存储在 course.MYD文件，索引存储在course.MYI文件中，coursr.frm是表结构定义文件，所以Myiasm的索引不存储数据，而是存储数据的磁盘地址。</p><p><img src="/breeze/797f8627/1635846149528.png" alt="1635846149528"></p><h5 id="2-B-Tree索引方式底层数据结构B-树"><a href="#2-B-Tree索引方式底层数据结构B-树" class="headerlink" title="2.B-Tree索引方式底层数据结构B+树"></a>2.B-Tree索引方式底层数据结构B+树</h5><p>下图是InnoDB的B+树索引结构，它的优势体现在：</p><ul><li><p>B+Tree属于多路树，每次查询都要走到叶子节点，查询效率稳定</p></li><li><p>非叶子节点不存储完整数据，而是存储键值 KEY ，和子树节点的引用，可以存储更多的KEY，充分利用每个节点的存储空间 16KB，减少了节点数，树高变矮，IO次数变少，性能更高。</p></li><li><p>叶子节点存储完整数据，叶子节点是有序的，每个叶子节点指向下一个节点的引用，形成一个链表，适合范围查询。</p></li></ul><p><img src="/breeze/797f8627/1635845818734.png" alt="1635845818734"></p><h5 id="3-b-tree索引方式在InnoDB的实现原理"><a href="#3-b-tree索引方式在InnoDB的实现原理" class="headerlink" title="3.b-tree索引方式在InnoDB的实现原理"></a>3.b-tree索引方式在InnoDB的实现原理</h5><p><mark>主键索引和辅助索引</mark></p><p>对于主键默认会创建主键索引，其他列创建的索引就叫辅助索引，也叫二级索引，辅助索引的叶子节点存储的是主键索引的键值，这就意味着辅助索引需要查询两个B+Tree.</p><p><img src="/breeze/797f8627/1635845847467.png" alt="1635845847467"></p><p>这里有2个概念：</p><ul><li><p><strong>回表：辅助索引扫描完之后还会扫描主键索引，这叫回表</strong></p></li><li><p>覆盖索引：如果Select name&#x2F;主键字段 查询的列正好包含在辅助索引的节点的键值中，它就不需要在扫描主键索引了，这个叫覆盖索引。所以不要写Select *</p><pre><code><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> <span class="keyword">where</span> name <span class="operator">=</span> &quot;zs&quot;</span><br></pre></td></tr></table></figure>
</code></pre></li></ul><p>问：如果表没有主键怎么办？</p><ol><li>如果没有主键，Mysql会选择第一个不包含null的唯一索引作为主键索引，</li><li>如果不满足条件一，那么会选择一个隐藏的行RowID作为主键索引</li></ol><p>查看隐藏rowId：Select _rowid from t_user</p><p>问：为什么用B+Tree</p><p>为什么不使用其他数据结构，比如数组？链表？AVL-Tree，B-Tree 而要使用B+Tree：</p><ul><li><p>有序数组：在查询的时候性能很高，可以二分查找，但是修改删除数据的时候会移动数组下标，性能比较差，这种结构只适合静态数据</p></li><li><p>链表：链表的删除，修改性能高，打算查询性能极差</p></li><li><p>综合上面的优势，有没有支持二分查找的链表结构呢？有：就是二叉查找树。</p></li><li><p>二叉查找树：它的查询性能和树高有关系，二叉树树高越高，查询越慢，而且在子树极端不平衡的情况下二叉树可能会变成链表，性能比较差。</p></li><li><p>AVL-Tree 平衡二叉树结构：平衡二叉查找树，如果每个节点放一个键值，数据地址，子树的引用 ，<mark>InnoDB节点默认最大存储为16KB，那AVL-Tree平衡二叉树的节点存储数据是远远达不到16K的，浪费了大量的存储空间。</mark>如果数据量大，就意味着树高非常高，查找一个KEY就需要遍历很多的节点，时间复杂度大，I&#x2F;O次数非常高,所以查询是比较慢的。</p></li></ul><p><img src="/breeze/797f8627/1635845939369.png" alt="1635845939369"></p><p>B-Tree : B-Tree：多路平衡查找树：多叉树意味着每个节点可以存储更多的KEY，多叉树可以解决每个节点空间浪费问题，也可以解决树高问题从而达到较少IO次数提高效率。</p><p><img src="/breeze/797f8627/1635845974338.png" alt="1635845974338"></p><p>但是Btree性能已经不错了，但是还不够优化，InnoDB没有使用BTree，而是使用一个更优化的树：B+树</p><p>B+Tree : 子节点存储数据，而且是有些了，相比BTree来说有如下优势：</p><ul><li><p>查询效率稳定：B+Tree属于多路树，每次查询都要走到叶子节点，查询效率稳定</p></li><li><p>磁盘读写能力强：非叶子节点不存储完整数据，而是存储键值 KEY ，和子树节点的指针，这样每个节点就可以存储更多的KEY，充分利用每个节点的存储空间 16KB，减少了节点数，树高变矮，IO次数变少，性能更高。</p></li><li><p>排序能力强：叶子节点存储完整数据，叶子节点是有序的，每个叶子节点指向下一个节点的	应用，形成一个链表，适合范围查询，和对排序支持友好</p></li></ul><h5 id="4-b-tree索引方式在Myisam实现原理"><a href="#4-b-tree索引方式在Myisam实现原理" class="headerlink" title="4.b-tree索引方式在Myisam实现原理"></a>4.b-tree索引方式在Myisam实现原理</h5><ul><li>MyISAM主键索引</li></ul><p>myisam的数据和索引是分开的，所以树的节点指向的是数据的地址。数据存储在 course.MYD文件，索引存储在course.MYI文件中，coursr.frm是表结构定义文件，所以Myiasm的索引不存储数据，而是存储数据的磁盘地址。</p><p><img src="/breeze/797f8627/1635846149528.png" alt="1635846149528"></p><p>下面是MyIsam索引结构，由于数据和索引是分开存放的，所以叶子节点存储的是数据的磁盘地址，而不是数据。</p><p><img src="/breeze/797f8627/1635846166597.png" alt="1635846166597"></p><ul><li>MyISAM辅助索引</li></ul><p><img src="/breeze/797f8627/1635846187257.png" alt="1635846187257"></p><p>注意：MyIsam的辅助索引的叶子节点没有指向主键索引的键值，而是直接指向的数据的磁盘地址</p><p>总图：</p><p><img src="/breeze/797f8627/1666600981203.png" alt="1666600981203"></p><h4 id="3-5-索引的操作"><a href="#3-5-索引的操作" class="headerlink" title="3.5.索引的操作"></a>3.5.索引的操作</h4><h5 id="1-创建"><a href="#1-创建" class="headerlink" title="1 创建"></a>1 创建</h5><h6 id="1-普通索引"><a href="#1-普通索引" class="headerlink" title="1.普通索引"></a>1.普通索引</h6><p>索引分类：普通索引&#x2F;唯一索引&#x2F;主键索引&#x2F;全文索引，普通索引:允许重复的值出现，一般来说，普通索引的创建，是先创建表，然后在创建普通索引</p><ul><li>创建表时创建索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index 索引名 <span class="keyword">on</span> 表 (列<span class="number">1</span>,列名<span class="number">2</span>,...);</span><br></pre></td></tr></table></figure><ul><li>修改表添加索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名<span class="keyword">add</span> index 索引名(列<span class="number">1</span>,列名<span class="number">2</span>,..);</span><br></pre></td></tr></table></figure><ul><li>案例</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> aaa(id <span class="type">int</span> unsigned,name <span class="type">varchar</span>(<span class="number">32</span>));</span><br><span class="line"><span class="keyword">create</span> index nameIndex <span class="keyword">on</span> aaa(name);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> aaa <span class="keyword">add</span> index index1(name);</span><br></pre></td></tr></table></figure><h6 id="2-唯一索引"><a href="#2-唯一索引" class="headerlink" title="2.唯一索引"></a>2.唯一索引</h6><p>除了不能有重复的记录外，其它和普通索引一样 ，当表的某列被指定为unique约束时，这列就是一个唯一索引</p><ul><li>建表时创建索引例如</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bbb(id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment , name <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">unique</span>);</span><br></pre></td></tr></table></figure><p>这时, name 列就是一个唯一索引，也可以在创建表后，再去创建唯一索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index 索引名 <span class="keyword">on</span> 表名 (列<span class="number">1</span>,列<span class="number">2</span>,..);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名<span class="keyword">add</span> <span class="keyword">unique</span> index 索引名 (列<span class="number">1</span>,列<span class="number">2</span>,..);</span><br></pre></td></tr></table></figure><ul><li>为表添加索引例如</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> ccc(id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment, name <span class="type">varchar</span>(<span class="number">32</span>));</span><br></pre></td></tr></table></figure><p>注意：unique字段可以为NULL,并可以有多NULL, 但是如果是具体内容，则不能重复.主键字段，不能为NULL,也不能重复.</p><h6 id="3-主键索引"><a href="#3-主键索引" class="headerlink" title="3.主键索引"></a>3.主键索引</h6><p>是随着设定主键而创建的，也就是把某个列设为主键的时候，数据库就会給改列创建索引。这就是主键索引.唯一且没有null值</p><ul><li>创建表时指定主键 例如</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> ddd(id <span class="type">int</span> unsigned <span class="keyword">primary</span> key auto_increment ,name <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">not</span> <span class="keyword">null</span>  defaul ‘’);</span><br></pre></td></tr></table></figure><p>这时id 列就是主键索引. 如果你创建表时，没有指定主键，</p><ul><li>在创建表后，再添加主键</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">primary</span> key (列名);</span><br></pre></td></tr></table></figure><p>举例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> eee(id <span class="type">int</span> , name <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> ‘’);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> eee <span class="keyword">add</span> <span class="keyword">primary</span> key (id);</span><br></pre></td></tr></table></figure><h6 id="4-全文索引"><a href="#4-全文索引" class="headerlink" title="4.全文索引"></a>4.全文索引</h6><p>用来对表中的文本域(char，varchar，text)进行索引， 全文索引针对MyISAM有用</p><ul><li>创建表时定义</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> articles (</span><br><span class="line">       id <span class="type">INT</span> UNSIGNED AUTO_INCREMENT <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">       title <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">       body TEXT,</span><br><span class="line">       FULLTEXT (title,body)</span><br><span class="line">     )engine<span class="operator">=</span>myisam charset utf8;</span><br></pre></td></tr></table></figure><ul><li>为表添加索引例如</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> fulltext index 索引名 <span class="keyword">on</span> 表名(列<span class="number">1</span>,列<span class="number">2</span>);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名<span class="keyword">add</span> fulltext index 索引名 (列<span class="number">1</span>,列<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>比如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> articles (</span><br><span class="line">         id <span class="type">INT</span> UNSIGNED AUTO_INCREMENT <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">         title <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">         body TEXT</span><br><span class="line">     )engine<span class="operator">=</span>myisam charset utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">Alter</span> <span class="keyword">table</span> article <span class="keyword">add</span> fulltext index title_body_fulltext_index(title,body);</span><br></pre></td></tr></table></figure><h5 id="5-查询索引"><a href="#5-查询索引" class="headerlink" title="5.查询索引"></a>5.查询索引</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> 表名</span><br></pre></td></tr></table></figure><h5 id="6-删除索引"><a href="#6-删除索引" class="headerlink" title="6.删除索引"></a>6.删除索引</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> index 索引名; </span><br></pre></td></tr></table></figure><p>删除主键索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">primary</span> key 删除主键。      [主键定义为auto_increment时不能删除]</span><br></pre></td></tr></table></figure><h5 id="7-修改索引"><a href="#7-修改索引" class="headerlink" title="7.修改索引"></a>7.修改索引</h5><p>先删除后添加&#x3D;修改</p><h4 id="3-6-索引小技巧"><a href="#3-6-索引小技巧" class="headerlink" title="3.6.索引小技巧"></a>3.6.索引小技巧</h4><p>根据索引列的多少分为复合索引(联合索引)和普通索引</p><ul><li><p>普通索引（单列索引）：该索引只在一个列上面创建</p></li><li><p>复合索引（多列索引）：该索引只在多个列上面创建</p></li></ul><h5 id="1-组合索引"><a href="#1-组合索引" class="headerlink" title="1.组合索引"></a>1.组合索引</h5><p>对于创建的多列索引（复合索引），不是使用的第一部分就不会使用索引(向左匹配原则)。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> dept <span class="keyword">add</span> index my_indx (dname,loc); </span><br></pre></td></tr></table></figure><p>dname 左边的列,loc就是 右边的列</p><p>测试案例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dept <span class="keyword">where</span> dname<span class="operator">=</span><span class="string">&#x27;aaa&#x27;</span>       会使用到索引</span><br></pre></td></tr></table></figure><p><img src="/breeze/797f8627/1635846690688.png" alt="1635846690688"></p><p>测试案例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dept <span class="keyword">where</span> loc<span class="operator">=</span><span class="string">&#x27;aaa&#x27;</span>    就不会使用到索引</span><br></pre></td></tr></table></figure><p><img src="/breeze/797f8627/1635846728072.png" alt="1635846728072"></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wuhuayangs/article/details/122695957">https://blog.csdn.net/wuhuayangs/article/details/122695957</a></p><p>单例索引和符合索引谁效率高</p><p><img src="/breeze/797f8627/1698819013497.png" alt="1698819013497"></p><p>​ 组合索引 比对每个列分别建索引更有优势，因为索引建立得越多就越占磁盘空间，在更新数据的时候速度会更慢。另外建立多列索引时，顺序也是需要注意的，应该将严格的索引放在前面(最左原则)，这样筛选的力度会更大，效率更高。</p><h5 id="2-like匹配索引"><a href="#2-like匹配索引" class="headerlink" title="2.like匹配索引"></a>2.like匹配索引</h5><p>对于使用like的查询，查询如果是%aaa’不会使用到索引而‘aaa%’会使用到索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dept <span class="keyword">where</span> dname <span class="keyword">like</span> <span class="string">&#x27;%aaa&#x27;</span>    不能使用索引</span><br></pre></td></tr></table></figure><p><img src="/breeze/797f8627/1635846908218.png" alt="1635846908218"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dept <span class="keyword">where</span> dname <span class="keyword">like</span> <span class="string">&#x27;aaa%&#x27;</span>   使用索引.</span><br></pre></td></tr></table></figure><p><img src="/breeze/797f8627/1635846964731.png" alt="1635846964731"></p><p>所以在like查询时，‘关键字’的最前面不能使用 % 或者 _这样的字符.，如果一定要前面有变化的值，则考虑使用 全文索引-&gt;lucene或Es</p><h5 id="3-or匹配索引"><a href="#3-or匹配索引" class="headerlink" title="3.or匹配索引"></a>3.or匹配索引</h5><p>如果条件中有or，有条件没有使用索引,即使其中有条件带索引也不会使用。换言之，就是要求使用的所有字段,都必须单独使用时能使用索引. 全部能够单独使用才能使用</p><table><thead><tr><th>explain select * from dept where dname &#x3D; ‘aaa’;	&#x2F;&#x2F;如果使用索引</th></tr></thead><tbody><tr><td>explain select * from dept where loc &#x3D; ‘aaa’; &#x2F;&#x2F;如果不能使用索引</td></tr><tr><td>select * from dept where dname&#x3D;’xxx’ or loc&#x3D;’xx’;	&#x2F;&#x2F;不能使用索引，它没办法从两个索引树种去检索</td></tr></tbody></table><h5 id="4-字符串匹配索引"><a href="#4-字符串匹配索引" class="headerlink" title="4.字符串匹配索引"></a>4.字符串匹配索引</h5><p>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来。否则不使用索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dept <span class="keyword">where</span> dname<span class="operator">=</span>’<span class="number">111</span>’;</span><br></pre></td></tr></table></figure><p><img src="/breeze/797f8627/1635847058648.png" alt="1635847058648"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dept <span class="keyword">where</span> dname<span class="operator">=</span><span class="number">111</span>;（数值自动转字符串）</span><br></pre></td></tr></table></figure><p><img src="/breeze/797f8627/1635847093721.png" alt="1635847093721"></p><p>expain select * from dept where dname&#x3D;qqq; 报错</p><p>也就是，如果列是字符串类型，无论是不是字符串数字就一定要用 ‘’ 把它包括起来.</p><h4 id="3-7-注意事项"><a href="#3-7-注意事项" class="headerlink" title="3.7.注意事项"></a>3.7.注意事项</h4><h5 id="1-索引的代价"><a href="#1-索引的代价" class="headerlink" title="1.索引的代价:"></a>1.索引的代价:</h5><ul><li><p>占用磁盘空间。</p></li><li><p>对dml(增删改)操作有影响,因为要维护索引，变慢。</p></li></ul><h5 id="2-在哪些列上适合添加索引-经常查询很少修改，并且唯一性高"><a href="#2-在哪些列上适合添加索引-经常查询很少修改，并且唯一性高" class="headerlink" title="2.在哪些列上适合添加索引? 经常查询很少修改，并且唯一性高."></a>2.在哪些列上适合添加索引? 经常查询很少修改，并且唯一性高.</h5><ul><li><p>不会出现在WHERE子句中字段不该创建索引</p></li><li><p>较频繁的作为查询条件字段应该创建索引</p><p>select * from emp where empno &#x3D; 1</p></li><li><p>唯一性太差(离散度)的字段不适合单独创建索引，即使频繁作为查询条件</p><p>select * from emp where sex &#x3D; ‘男’</p></li><li><p>更新非常频繁的字段不适合创建索引</p><p>select * from emp where logincount &#x3D; 1</p></li></ul><h5 id="3-索引失效因素"><a href="#3-索引失效因素" class="headerlink" title="3.索引失效因素"></a>3.索引失效因素</h5><ul><li><p>模糊查询 like “%keyword%” 不会使用到索引,like “keyword%”可以</p></li><li><p>列是字符串类型，无论是不是字符串数字就一定要用 ‘’ 把它包括起来，否则索引失效</p></li><li><p>or会导致索引失效,每个条件都要能够单独使用索引</p></li><li><p>查询的条件列进行过运算或处理，不会走索引，因为不确定计算后的值是什么</p><p>如： where DATE_FORMART(start_time,’%y-%m-%d’) &#x3D; “21-2-23” 不会走索引 命令率</p></li><li><p>查询null值如： where name is null 不会走索引，可以去null设定为 0 来代替。</p></li><li><p>注意：not in 、not exist、!&#x3D;、&lt; &gt;、like “%_”，以及in(select子句) 会导致索引失效</p></li><li><p>如果mysql估计使用全表扫描要比使用索引快,则不使用索引，比如表里面只有一条记录</p></li></ul><h5 id="4-强制使用索引"><a href="#4-强制使用索引" class="headerlink" title="4.强制使用索引"></a>4.强制使用索引</h5><p>select xx,oo from table <strong>force</strong> index(索引名) where xxx &#x3D; xxxx;(强制使用主键)</p><p>​ <strong>索引分类:</strong></p><p>​ <strong>在哪种字段上:普通 唯一 主键 全文 空间</strong></p><p>​ <strong>是否是主键: 主键索引 辅助索引</strong></p><p>​ <strong>作用多少列: 普通 索引 复合索引</strong></p><h3 id="4-SQL优化小技巧"><a href="#4-SQL优化小技巧" class="headerlink" title="4.SQL优化小技巧"></a>4.SQL优化小技巧</h3><p>SQL：</p><ul><li><p>DDL(数据库定义语言 建库，建表，视图，索引) ，</p></li><li><p><strong>DML(DML 数据库操作语言 对表中数据 增删改)</strong></p></li><li><p><strong>DQL(数据库查询语言 对表中的记录查询)</strong></p></li><li><p>DCL数据库控制语言 对用户权限的设置，控制事务</p></li></ul><h4 id="4-1-DML优化-批量插入"><a href="#4-1-DML优化-批量插入" class="headerlink" title="4.1.DML优化-批量插入"></a>4.1.DML优化-批量插入</h4><p>bitdata.txt(500W) …. —&gt;db —–&gt;10次 50W</p><p>1、 通过禁用索引来提供导入数据性能 。 这个操作主要针对有数据库的表，追加数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>去除键</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> test3 DISABLE keys;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>批量插入数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test3 <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>恢复键</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> test3 ENABLE keys;</span><br></pre></td></tr></table></figure><p>变多次索引维护为一次索引维护</p><p>2、 关闭唯一校验</p><p>变多次唯一校验为一次唯一校验</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> unique_checks=<span class="number">0</span>  关闭</span><br><span class="line"><span class="comment">//批量插入数据</span></span><br><span class="line">insert <span class="keyword">into</span> test3 <span class="keyword">select</span> * <span class="keyword">from</span> test;</span><br><span class="line"><span class="keyword">set</span> unique_checks=<span class="number">1</span>  开启</span><br></pre></td></tr></table></figure><p>3、 修改事务提交方式(导入)</p><p>变多次事务提交为一次事务提交</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set autocommit=0   关闭</span><br><span class="line">//批量插入</span><br><span class="line">set autocommit=1   开启</span><br></pre></td></tr></table></figure><p><img src="/breeze/797f8627/1635907756246.png" alt="1635907756246"></p><h4 id="4-2-DML优化-批量插入"><a href="#4-2-DML优化-批量插入" class="headerlink" title="4.2.DML优化-批量插入"></a>4.2.DML优化-批量插入</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>合并多条为一条</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">1</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p><img src="/breeze/797f8627/1635907814612.png" alt="1635907814612"></p><p>​ 见购物车批量同步!!!!!!!</p><h4 id="4-3-DQL优化-重要-select"><a href="#4-3-DQL优化-重要-select" class="headerlink" title="4.3.DQL优化   重要  select"></a>4.3.DQL优化 重要 select</h4><p>1、order by 优化 建议都加上索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、多用索引排序</span><br><span class="line"><span class="number">2</span>、普通结果排序（非索引排序）Filesort</span><br><span class="line">索引本身就是排序的，所以多使用索引。  如果某字段要排序,可以创建索引来提高效率</span><br></pre></td></tr></table></figure><p>30种sql语句优化 ：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Little-Li/p/8031295.html">https://www.cnblogs.com/Little-Li/p/8031295.html</a></p><p>sql语句的执行顺序：from where having group by 条件 order by limit</p><p>2、 小表驱动大表 数据量小表关联大表</p><p>小表驱动大表的主要目的是通过<strong>减少表连接创建的次数，</strong>加快查询速度 。</p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38011415/article/details/103304189">https://blog.csdn.net/qq_38011415/article/details/103304189</a></p><p><strong>作业把这五点理解并抄一遍.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>’对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</span><br><span class="line"><span class="number">2.</span>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</span><br><span class="line"><span class="number">3.</span>应尽量避免在 where 子句中对字段进行 <span class="literal">null</span> 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</span><br><span class="line">select id from t where num is <span class="literal">null</span></span><br><span class="line">可以在num上设置默认值<span class="number">0</span>，确保表中num列没有<span class="literal">null</span>值，然后这样查询：</span><br><span class="line">select id from t where num=<span class="number">0</span></span><br><span class="line"><span class="number">4.</span>应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</span><br><span class="line">select id from t where num=<span class="number">10</span> or num=<span class="number">20</span></span><br><span class="line">可以这样查询：</span><br><span class="line">select id from t where num=<span class="number">10</span></span><br><span class="line">union all</span><br><span class="line">select id from t where num=<span class="number">20</span></span><br><span class="line"><span class="number">5.</span>下面的查询也将导致全表扫描：</span><br><span class="line">select id from t where name like <span class="string">&#x27;%abc%&#x27;</span></span><br><span class="line">若要提高效率，可以考虑全文检索。</span><br><span class="line"><span class="number">6.</span>in 和 not in 也要慎用，否则会导致全表扫描，如：</span><br><span class="line">select id from t where num <span class="title function_">in</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span><br><span class="line">对于连续的数值，能用 between 就不要用 in 了：</span><br><span class="line">select id from t where num between <span class="number">1</span> and <span class="number">3</span></span><br><span class="line"><span class="number">7.</span>如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</span><br><span class="line">select id from t where num=<span class="meta">@num</span></span><br><span class="line">可以改为强制查询使用索引：</span><br><span class="line">select id from t <span class="title function_">with</span><span class="params">(index(索引名)</span>) where num=<span class="meta">@num</span></span><br><span class="line"><span class="number">8.</span>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</span><br><span class="line">select id from t where num/<span class="number">2</span>=<span class="number">100</span></span><br><span class="line">应改为:</span><br><span class="line">select id from t where num=<span class="number">100</span>*<span class="number">2</span></span><br><span class="line"><span class="number">9.</span>应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</span><br><span class="line">select id from t where <span class="title function_">substring</span><span class="params">(name,<span class="number">1</span>,<span class="number">3</span>)</span>=<span class="string">&#x27;abc&#x27;</span>--name以abc开头的id</span><br><span class="line">select id from t where <span class="title function_">datediff</span><span class="params">(day,createdate,<span class="string">&#x27;2005-11-30&#x27;</span>)</span>=<span class="number">0</span>--<span class="string">&#x27;2005-11-30&#x27;</span>生成的id</span><br><span class="line">应改为:</span><br><span class="line">select id from t where name like <span class="string">&#x27;abc%&#x27;</span></span><br><span class="line">select id from t where createdate&gt;=<span class="string">&#x27;2005-11-30&#x27;</span> and createdate&lt;<span class="string">&#x27;2005-12-1&#x27;</span></span><br><span class="line"><span class="number">10.</span>不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</span><br><span class="line"><span class="number">11.</span>在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</span><br><span class="line"><span class="number">12.</span>不要写一些没有意义的查询，如需要生成一个空表结构：</span><br><span class="line">select col1,col2 into #t from t where <span class="number">1</span>=<span class="number">0</span></span><br><span class="line">这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：</span><br><span class="line">create table #t(...)</span><br><span class="line"><span class="number">13.</span>很多时候用 exists 代替 in 是一个好的选择：</span><br><span class="line">select num from a where num <span class="title function_">in</span><span class="params">(select num from b)</span></span><br><span class="line">用下面的语句替换：</span><br><span class="line">select num from a where <span class="title function_">exists</span><span class="params">(select <span class="number">1</span> from b where num=a.num)</span></span><br><span class="line"><span class="number">14.</span>并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。</span><br><span class="line"><span class="number">15.</span>索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过<span class="number">6</span>个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</span><br><span class="line"><span class="number">16.</span>应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</span><br><span class="line"><span class="number">17.</span>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</span><br><span class="line"><span class="number">18.</span>尽可能的使用 varchar/nvarchar 代替 <span class="type">char</span>/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</span><br><span class="line"><span class="number">19.</span>任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。</span><br><span class="line"><span class="number">20.</span>尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</span><br><span class="line"><span class="number">21.</span>避免频繁创建和删除临时表，以减少系统表资源的消耗。</span><br><span class="line"><span class="number">22.</span>临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。</span><br><span class="line"><span class="number">23.</span>在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</span><br><span class="line"><span class="number">24.</span>如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</span><br><span class="line"><span class="number">25.</span>尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过<span class="number">1</span>万行，那么就应该考虑改写。</span><br><span class="line"><span class="number">26.</span>使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</span><br><span class="line"><span class="number">27.</span>与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</span><br><span class="line"><span class="number">28.</span>在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。</span><br><span class="line"><span class="number">29.</span>尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</span><br><span class="line"><span class="number">30.</span>尽量避免大事务操作，提高系统并发能力。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>你写sql的时候注意什么? 给我说一下sql优化?</p><p><strong>1 小表驱动大表</strong></p><p><strong>2 .应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描</strong>，如：<br>select id from t where num is null<br>可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：<br>select id from t where num&#x3D;0<br>3.应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：<br>select id from t where num&#x3D;10 or num&#x3D;20<br>可以这样查询：<br>select id from t where num&#x3D;10<br>union all<br>select id from t where num&#x3D;20</p><p>4.in 和 not in 也要慎用，否则会导致全表扫描，如：<br>select id from t where num in(1,2,3)<br>对于连续的数值，能用 between 就不要用 in 了：<br>select id from t where num between 1 and 3</p><p><strong>5.任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。</strong></p><p><strong>6.尽可能的使用 varchar&#x2F;nvarchar 代替 char&#x2F;nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</strong></p><p><strong>7.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。</strong>如：<br>select id from t where substring(name,1,3)&#x3D;’abc’–name以abc开头的id<br>select id from t where datediff(day,createdate,’2005-11-30’)&#x3D;0–’2005-11-30’生成的id<br>应改为:<br>select id from t where name like ‘abc%’<br>select id from t where createdate&gt;&#x3D;’2005-11-30’ and createdate&lt;’2005-12-1’</p><p>8.不要在 where 子句中的“&#x3D;”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p><h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h2><h3 id="1-重点内容"><a href="#1-重点内容" class="headerlink" title="1.重点内容"></a>1.重点内容</h3><ul><li><p>组合索引 *******</p><p>组合索引 分别创建索引那个查询效率高…. 和查询语句关</p><p>….</p><p>…</p><p>….</p></li><li><p>定位慢SQL</p></li><li><p>Mysql执行流程(Mysql的架构)</p></li><li><p>索引分类&amp;索引结构&amp;索引原理</p></li><li><p>存储引擎</p></li><li><p>SQL优化技巧</p></li></ul><h3 id="2-面试必备"><a href="#2-面试必备" class="headerlink" title="2.面试必备"></a>2.面试必备</h3><ul><li><p>导致系统性能瓶颈的原因有哪些</p></li><li><p>一个页面响应很慢，你按照什么顺序去排查</p></li><li><p>你怎么去找到系统中查询慢的SQL</p></li><li><p>如何查看某个sql有没有命中索引</p></li><li><p>explain用过吗？</p></li><li><p>Mysql执行原理</p></li><li><p>是不是索引越全越好</p></li><li><p>sex和username两个字段你会在谁身上建立索引，为什么</p></li><li><p>like一定会导致索引失效吗</p></li><li><p>索引创建原则&#x2F;你一般怎么创建索引</p></li><li><p>用户的账户流水表数据量很大，达到了1千万+，select * from t_account_flow where userid &#x3D; #{userid}，你怎么优化?</p><p>一个SQL，要查询：每年 ，每月 ， 每周，的流水总额报表 ，数据量一千万+， 你怎么查，怎么优化</p></li><li><p>模糊匹配like“%abc”,“%abc%”,“abc%”谁能用到索引，谁不能用到，为什么</p></li><li><p>SQL写成 ： Select * 有什么问题</p></li><li><p>mysql索引用到了什么数据结构</p></li><li><p>InnoDB的索引树和MyIsam的索引树有什么区别</p></li><li><p>常用的SQL优化技巧讲几个</p></li><li><p>一个SQL需要JOIN多张表来查询结果，查询较慢，你可以怎么优化？</p></li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://mliutm.github.io">清风</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://mliutm.github.io/breeze/797f8627.html">https://mliutm.github.io/breeze/797f8627.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://mliutm.github.io" target="_blank">清风</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/mysql/">mysql</a></div><div class="post_share"><div class="social-share" data-image="/img/photo-1653549892896-dde02867edee.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/breeze/b3ef3604.html" title="SpringCloud-oauth-JWT"><img class="cover" src="/img/premium_photo-1695185954894-e9382c6f4da8.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">SpringCloud-oauth-JWT</div></div></a></div><div class="next-post pull-right"><a href="/breeze/498cfd8e.html" title="并发编程"><img class="cover" src="/img/premium_photo-1695185954894-e9382c6f4da8.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">并发编程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/breeze/75a56cf8.html" title="MySQL多机优化"><img class="cover" src="/img/photo-1645943020355-305df166473d.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-14</div><div class="title">MySQL多机优化</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">清风</div><div class="author-info__description">清风洒六合，邈然不可攀</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">140</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">72</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:huangpan0805@163.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div><timing></timing></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96-%E5%8D%95%E6%9C%BA%E4%BC%98%E5%8C%96"><span class="toc-text">数据库优化-单机优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AE%B9"><span class="toc-text">内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E6%A6%82%E8%BF%B0"><span class="toc-text">一.关系型数据库优化概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%BC%98%E5%8C%96"><span class="toc-text">1.为什么需要优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%BB%E5%86%99-%E9%9B%86%E7%BE%A4"><span class="toc-text">1.1.高并发读写 集群</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99-%E5%8D%95%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E9%87%8F%E6%AF%94%E8%BE%83%E5%A4%A7-%E5%88%86%E8%A1%A8-%E5%88%86%E5%BA%93"><span class="toc-text">1.2.海量数据读写(单表数据存储量比较大) 分表 分库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E9%AB%98%E6%89%A9%E5%B1%95%E6%80%A7%E5%92%8C%E5%8F%AF%E7%94%A8%E6%80%A7"><span class="toc-text">1.3.高扩展性和可用性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D%E7%9A%84%E5%9B%A0%E7%B4%A0"><span class="toc-text">2.对数据库性能影响的因素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%95%86%E4%B8%9A%E9%9C%80%E6%B1%82%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-text">2.1.商业需求对性能的影响</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-text">2.2.数据库设计对性能的影响</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-SQL%E7%BC%96%E5%86%99%E7%9A%84%E4%B8%8D%E5%90%88%E7%90%86%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-text">2.3.SQL编写的不合理对性能的影响</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E5%85%B6%E4%BB%96%E6%96%B9%E9%9D%A2"><span class="toc-text">2.4.其他方面</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%95%B4%E4%BD%93%E4%BB%8B%E7%BB%8D"><span class="toc-text">3.关系型数据库的优化技术整体介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87-%E6%A8%A1%E6%8B%9F%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE-%E6%90%9E%E5%87%BA%E9%97%AE%E9%A2%98-%E6%89%8D%E8%83%BD%E5%88%86%E6%9E%90%E9%97%AE%E9%A2%98-%E6%89%BE%E5%88%B0%E5%8E%9F%E5%9B%A0-%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98"><span class="toc-text">4 数据准备-模拟海量数据,搞出问题,才能分析问题,找到原因,解决问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%AE%9A%E4%BD%8D%E6%85%A2SQL"><span class="toc-text">二.定位慢SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Mysql%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86-mysql%E7%9A%84%E6%9E%B6%E6%9E%84"><span class="toc-text">1.Mysql执行原理(mysql的架构)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%89%BE%E5%87%BA%E6%89%A7%E8%A1%8C%E6%85%A2sql"><span class="toc-text">2.找出执行慢sql</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E5%BA%93-mysql-%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81"><span class="toc-text">2.1.查询数据库(mysql)基本状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%AE%9A%E4%BD%8D%E6%85%A2%E6%9F%A5%E8%AF%A2"><span class="toc-text">2.2.定位慢查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E6%AD%A5%E9%AA%A4%E6%80%BB%E7%BB%93"><span class="toc-text">2.3.步骤总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%86%E6%9E%90sql%E8%AF%AD%E5%8F%A5"><span class="toc-text">3.分析sql语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E6%9F%A5%E7%9C%8B%E6%89%A7%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-text">3.1 查看执行的线程状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-explan"><span class="toc-text">3.2.explan</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E5%88%86%E6%9E%90%E8%AF%A6%E7%BB%86%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">3.3 分析详细执行过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E5%8D%95%E6%9C%BA%E4%BC%98%E5%8C%96%EF%BC%88%E5%B8%B8%E8%A7%84%E4%BC%98%E5%8C%96%EF%BC%89"><span class="toc-text">三.单机优化（常规优化）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%8C%83%E5%BC%8F"><span class="toc-text">1.范式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%86%97%E4%BD%99%E5%AD%97%E6%AE%B5"><span class="toc-text">1.1.冗余字段</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-text">2.存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D"><span class="toc-text">2.1.存储引擎介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">2.2.使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Mysql%E7%9A%84%E7%B4%A2%E5%BC%95-%E9%87%8D%E7%82%B9%E4%B8%AD%E7%9A%84%E9%87%8D%E7%82%B9"><span class="toc-text">3.Mysql的索引 重点中的重点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%A4%E8%AF%86"><span class="toc-text">3.1.索引的认识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-mysql%E7%B4%A2%E5%BC%95%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.2.mysql索引的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-mysql%E5%B8%B8%E8%A7%81%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%94%AF%E6%8C%81%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F%E6%9E%84"><span class="toc-text">3.3. mysql常见存储引擎支持索引方式构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-1-MyISAM%E6%98%AFMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E4%B8%80%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E5%A6%82%E6%9E%9C%E4%BD%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AFmyisam-%E4%BD%A0%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E9%80%89%E6%8B%A9%E4%BB%A5%E4%B8%8B%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F"><span class="toc-text">3.3.1 MyISAM是MySQL数据库中一种常用的存储引擎 如果你的数据库使用的是myisam,你创建索引的时候可以选择以下索引方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-2-InnoDB%E6%98%AFMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-text">3.3.2 InnoDB是MySQL数据库中另一种常用的存储引擎</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-3-b-tree%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F"><span class="toc-text">3 3.3 b-tree索引方式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-b-tree%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%88%E8%B6%85%E7%BA%A7%E9%87%8D%E8%A6%81%EF%BC%89-%E8%AF%B4%E4%B8%80%E4%B8%8B%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86-%E5%BF%85%E9%97%AE"><span class="toc-text">3.4.b-tree索引方式的底层原理（超级重要）-说一下索引原理-必问</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-InnoDB%E4%B8%8Emyisam%E7%B4%A2%E5%BC%95%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-text">1.InnoDB与myisam索引物理结构</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-1-innodb-%E6%95%B0%E6%8D%AE%E5%92%8C%E7%B4%A2%E5%BC%95%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E4%B8%AD"><span class="toc-text">1.1 innodb-数据和索引在一个文件中</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-2-myisam-%E6%95%B0%E6%8D%AE%E5%92%8C%E7%B4%A2%E5%BC%95%E5%88%86%E5%BC%80%E6%94%BE"><span class="toc-text">1.2 myisam-数据和索引分开放</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-B-Tree%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84B-%E6%A0%91"><span class="toc-text">2.B-Tree索引方式底层数据结构B+树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-b-tree%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F%E5%9C%A8InnoDB%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">3.b-tree索引方式在InnoDB的实现原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-b-tree%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F%E5%9C%A8Myisam%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">4.b-tree索引方式在Myisam实现原理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E7%B4%A2%E5%BC%95%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">3.5.索引的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA"><span class="toc-text">1 创建</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95"><span class="toc-text">1.普通索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95"><span class="toc-text">2.唯一索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95"><span class="toc-text">3.主键索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95"><span class="toc-text">4.全文索引</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E6%9F%A5%E8%AF%A2%E7%B4%A2%E5%BC%95"><span class="toc-text">5.查询索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95"><span class="toc-text">6.删除索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E4%BF%AE%E6%94%B9%E7%B4%A2%E5%BC%95"><span class="toc-text">7.修改索引</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-%E7%B4%A2%E5%BC%95%E5%B0%8F%E6%8A%80%E5%B7%A7"><span class="toc-text">3.6.索引小技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-text">1.组合索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-like%E5%8C%B9%E9%85%8D%E7%B4%A2%E5%BC%95"><span class="toc-text">2.like匹配索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-or%E5%8C%B9%E9%85%8D%E7%B4%A2%E5%BC%95"><span class="toc-text">3.or匹配索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%B4%A2%E5%BC%95"><span class="toc-text">4.字符串匹配索引</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">3.7.注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BB%A3%E4%BB%B7"><span class="toc-text">1.索引的代价:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%88%97%E4%B8%8A%E9%80%82%E5%90%88%E6%B7%BB%E5%8A%A0%E7%B4%A2%E5%BC%95-%E7%BB%8F%E5%B8%B8%E6%9F%A5%E8%AF%A2%E5%BE%88%E5%B0%91%E4%BF%AE%E6%94%B9%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%94%AF%E4%B8%80%E6%80%A7%E9%AB%98"><span class="toc-text">2.在哪些列上适合添加索引? 经常查询很少修改，并且唯一性高.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%9B%A0%E7%B4%A0"><span class="toc-text">3.索引失效因素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%BC%BA%E5%88%B6%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-text">4.强制使用索引</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-SQL%E4%BC%98%E5%8C%96%E5%B0%8F%E6%8A%80%E5%B7%A7"><span class="toc-text">4.SQL优化小技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-DML%E4%BC%98%E5%8C%96-%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5"><span class="toc-text">4.1.DML优化-批量插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-DML%E4%BC%98%E5%8C%96-%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5"><span class="toc-text">4.2.DML优化-批量插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-DQL%E4%BC%98%E5%8C%96-%E9%87%8D%E8%A6%81-select"><span class="toc-text">4.3.DQL优化 重要 select</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E6%80%BB%E7%BB%93"><span class="toc-text">四.总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%87%8D%E7%82%B9%E5%86%85%E5%AE%B9"><span class="toc-text">1.重点内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87"><span class="toc-text">2.面试必备</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/breeze/736eb1c8.html" title="分布式任务调度--xxl-job"><img src="/img/photo-1692708632140-ee01624d558d.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="分布式任务调度--xxl-job"></a><div class="content"><a class="title" href="/breeze/736eb1c8.html" title="分布式任务调度--xxl-job">分布式任务调度--xxl-job</a><time datetime="2024-01-16T12:29:19.000Z" title="发表于 2024-01-16 20:29:19">2024-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/breeze/7a1a4477.html" title="认证授权-SpringSecurity"><img src="/img/photo-1692708632140-ee01624d558d.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="认证授权-SpringSecurity"></a><div class="content"><a class="title" href="/breeze/7a1a4477.html" title="认证授权-SpringSecurity">认证授权-SpringSecurity</a><time datetime="2024-01-16T01:41:55.000Z" title="发表于 2024-01-16 09:41:55">2024-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/breeze/7913ff38.html" title="ElasticSearch集群"><img src="/img/photo-1692708632140-ee01624d558d.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="ElasticSearch集群"></a><div class="content"><a class="title" href="/breeze/7913ff38.html" title="ElasticSearch集群">ElasticSearch集群</a><time datetime="2024-01-14T14:34:16.000Z" title="发表于 2024-01-14 22:34:16">2024-01-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/breeze/37cf2cfd.html" title="Redis集群"><img src="/img/photo-1645943020355-305df166473d.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Redis集群"></a><div class="content"><a class="title" href="/breeze/37cf2cfd.html" title="Redis集群">Redis集群</a><time datetime="2024-01-14T14:27:18.000Z" title="发表于 2024-01-14 22:27:18">2024-01-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/breeze/4b0178e0.html" title="数据结构与算法"><img src="/img/photo-1645943020355-305df166473d.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="数据结构与算法"></a><div class="content"><a class="title" href="/breeze/4b0178e0.html" title="数据结构与算法">数据结构与算法</a><time datetime="2024-01-14T13:51:48.000Z" title="发表于 2024-01-14 21:51:48">2024-01-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/img/photo-1653549892896-dde02867edee.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 <i id="heartbeat" class="fa fas fa-heartbeat"></i> 清风</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></head></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script src="/js/timing.js"></script><script id="canvas_nest" defer color="255,0,255" opacity="0.7" zindex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!0,document.body.addEventListener("input",POWERMODE)</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="天枢,天璇,天玑,天权,玉衡,开阳,瑶光" data-fontsize="15px" data-random="true" async></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>