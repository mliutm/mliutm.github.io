<!DOCTYPE html><html class="hide-aside" lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>面试实战 | 清风</title><meta name="author" content="清风"><meta name="copyright" content="清风"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="开发、运维、测试、实施的区别 JAVA9期实战面试题地址JAVA9期实战面试题地址 畅加科技有限公司一、中高级JAVA工程师笔试题1.JAVA进行数值的运算，如何防止精度丢失?防止精度丢失可以使用BiqDecimal类进行数值运算，它能够保持高精度的计算结果。 2.SpringBoot和Spring的区别?Sping和springBoot的主要区别在于Sping是一个全功能的轻量级企业应用开发框架"><meta property="og:type" content="article"><meta property="og:title" content="面试实战"><meta property="og:url" content="https://mliutm.github.io/breeze/2a548e97.html"><meta property="og:site_name" content="清风"><meta property="og:description" content="开发、运维、测试、实施的区别 JAVA9期实战面试题地址JAVA9期实战面试题地址 畅加科技有限公司一、中高级JAVA工程师笔试题1.JAVA进行数值的运算，如何防止精度丢失?防止精度丢失可以使用BiqDecimal类进行数值运算，它能够保持高精度的计算结果。 2.SpringBoot和Spring的区别?Sping和springBoot的主要区别在于Sping是一个全功能的轻量级企业应用开发框架"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://mliutm.github.io/img/photo-1653549892896-dde02867edee.jpg"><meta property="article:published_time" content="2024-02-29T02:43:59.000Z"><meta property="article:modified_time" content="2024-05-21T02:51:01.126Z"><meta property="article:author" content="清风"><meta property="article:tag" content="面试实战"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://mliutm.github.io/img/photo-1653549892896-dde02867edee.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://mliutm.github.io/breeze/2a548e97.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,top_n_per_article:1,unescape:!1,languages:{hits_empty:"找不到您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!1,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"面试实战",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-05-21 10:51:01"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,a){0!==a&&(a=864e5*a,t={value:t,expiry:(new Date).getTime()+a},localStorage.setItem(e,JSON.stringify(t)))},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!((new Date).getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=o=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.getCSS=(o,n=!1)=>new Promise((t,e)=>{const a=document.createElement("link");a.rel="stylesheet",a.href=o,n&&(a.id=n),a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">169</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">82</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/img/photo-1653549892896-dde02867edee.jpg)"><nav id="nav"><span id="blog-info"><a href="/" title="清风"><span class="site-name">清风</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试实战</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-29T02:43:59.000Z" title="发表于 2024-02-29 10:43:59">2024-02-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-21T02:51:01.126Z" title="更新于 2024-05-21 10:51:01">2024-05-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">39.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>125分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="面试实战"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/333838044">开发、运维、测试、实施的区别</a></p><h2 id="JAVA9期实战面试题地址"><a href="#JAVA9期实战面试题地址" class="headerlink" title="JAVA9期实战面试题地址"></a>JAVA9期实战面试题地址</h2><p><a target="_blank" rel="noopener" href="https://www.kdocs.cn/l/csXG6VnwmEiB">JAVA9期实战面试题地址</a></p><h2 id="畅加科技有限公司"><a href="#畅加科技有限公司" class="headerlink" title="畅加科技有限公司"></a>畅加科技有限公司</h2><h3 id="一、中高级JAVA工程师笔试题"><a href="#一、中高级JAVA工程师笔试题" class="headerlink" title="一、中高级JAVA工程师笔试题"></a>一、中高级JAVA工程师笔试题</h3><h4 id="1-JAVA进行数值的运算，如何防止精度丢失"><a href="#1-JAVA进行数值的运算，如何防止精度丢失" class="headerlink" title="1.JAVA进行数值的运算，如何防止精度丢失?"></a>1.JAVA进行数值的运算，如何防止精度丢失?</h4><p>防止精度丢失可以使用BiqDecimal类进行数值运算，它能够保持高精度的计算结果。</p><h4 id="2-SpringBoot和Spring的区别"><a href="#2-SpringBoot和Spring的区别" class="headerlink" title="2.SpringBoot和Spring的区别?"></a>2.SpringBoot和Spring的区别?</h4><p>Sping和springBoot的主要区别在于Sping是一个全功能的轻量级企业应用开发框架，而SpringBoot是一个用于快速构建独立的、基于Sping的应用程序的工具</p><h4 id="3-SpringBoot需要独立的容器运行吗"><a href="#3-SpringBoot需要独立的容器运行吗" class="headerlink" title="3.SpringBoot需要独立的容器运行吗?"></a>3.SpringBoot需要独立的容器运行吗?</h4><p>SpringBoot不需要独立的容器来运行，它内置了Tomcat等常用的Servlet容器</p><h4 id="4-SpringBoot中如何实现定时任务"><a href="#4-SpringBoot中如何实现定时任务" class="headerlink" title="4.SpringBoot中如何实现定时任务?"></a>4.SpringBoot中如何实现定时任务?</h4><p>在SpringBoot中实现定时任务可以使用@EnableScheduling注解结合@Scheduled注解来实现。</p><p>在Spring Boot中，实现定时任务有多种方式，其中最常用的方式是使用Spring框架提供的@Scheduled注解。@Scheduled注解可以用来标记一个方法，在指定的时间间隔或固定的时间点执行该方法。</p><p>下面是一个简单的示例，演示如何在Spring Boot中实现一个定时任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyScheduledTask</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = 5000)</span> <span class="comment">// 每隔5秒执行一次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myTask</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;定时任务执行了！&quot;</span>);</span><br><span class="line">        <span class="comment">// 在这里编写定时任务的具体逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，为了让Spring Boot应用识别定时任务，需要在启动类上添加@EnableScheduling注解，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableScheduling;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上配置，MyScheduledTask类中的myTask方法将会每隔5秒执行一次。除了fixedRate属性外，@Scheduled注解还支持其他属性，如cron表达式、fixedDelay等，可以根据实际需求选择合适的方式来实现定时任务。</p><h4 id="SpringCloud是什么-和SpringBoot的区别是什么"><a href="#SpringCloud是什么-和SpringBoot的区别是什么" class="headerlink" title="SpringCloud是什么?和SpringBoot的区别是什么?"></a>SpringCloud是什么?和SpringBoot的区别是什么?</h4><p>SpringCloud是一套基于SpringBoot的微服务架构解决方案,它专注于提供基于IM的分布式系统的协调支持。</p><h4 id="6-RPC调用是什么-和HTTP调用的区别是什么-SpringCloud的RPC调用框架是什么"><a href="#6-RPC调用是什么-和HTTP调用的区别是什么-SpringCloud的RPC调用框架是什么" class="headerlink" title="6.RPC调用是什么?和HTTP调用的区别是什么?SpringCloud的RPC调用框架是什么?"></a>6.RPC调用是什么?和HTTP调用的区别是什么?SpringCloud的RPC调用框架是什么?</h4><p>RPC调用是远程过程调用的缩写，与HTTP调用的区别在于RPC调用更加高效，因为它直接调用远程服务的方法，而不需要通过HTTP报文传输。SpringCloud的RPC调用框架是OpenFeign</p><h4 id="7-什么是服务治理和注册，SpringCloud的治理注册框架是什么"><a href="#7-什么是服务治理和注册，SpringCloud的治理注册框架是什么" class="headerlink" title="7.什么是服务治理和注册，SpringCloud的治理注册框架是什么?"></a>7.什么是服务治理和注册，SpringCloud的治理注册框架是什么?</h4><p>服务治理和注册是指对微服务架构中的各个服务进行管理和注册，SpringCloud的治理注册框架包括Eureka、Consul、nacos等。</p><h4 id="8-Nacos的网页管理后台默认访问路径是什么-SpringBoot如何接入Nacos"><a href="#8-Nacos的网页管理后台默认访问路径是什么-SpringBoot如何接入Nacos" class="headerlink" title="8.Nacos的网页管理后台默认访问路径是什么?SpringBoot如何接入Nacos?"></a>8.Nacos的网页管理后台默认访问路径是什么?SpringBoot如何接入Nacos?</h4><p>Nacos的网页管理后台默认访问路径是http:&#x2F;localhost:8848&#x2F;nacos，SpningBoot接入Nacos可以通过引入相应的依赖并配置application.propertièes文件</p><h4 id="9-SS0是什么-SpringCloud中如何实现SS0"><a href="#9-SS0是什么-SpringCloud中如何实现SS0" class="headerlink" title="9.SS0是什么?SpringCloud中如何实现SS0?"></a>9.SS0是什么?SpringCloud中如何实现SS0?</h4><p>SSO是单点登录的缩写，在SpringCloud中实现SSO可以使用Spring Security等组件</p><h4 id="10-K8S是什么-如何使用K8S查看服务运行日志"><a href="#10-K8S是什么-如何使用K8S查看服务运行日志" class="headerlink" title="10.K8S是什么?如何使用K8S查看服务运行日志?"></a>10.K8S是什么?如何使用K8S查看服务运行日志?</h4><p>K8s是Kubemetes的简称，是一个用于自动化部署、扩展和管理容器化应用程序的开源平台。可通过kubectl logs命令查看服务运行日志</p><h4 id="11-K8S中的node-和pod-的分别是什么"><a href="#11-K8S中的node-和pod-的分别是什么" class="headerlink" title="11.K8S中的node 和pod 的分别是什么?"></a>11.K8S中的node 和pod 的分别是什么?</h4><p>Node是K8s集群的工作节点，Pod是K8s中最小的调度单位，包含一个或多个容器。</p><h4 id="12-Java-如何实现线程变量安全隔离"><a href="#12-Java-如何实现线程变量安全隔离" class="headerlink" title="12.Java 如何实现线程变量安全隔离?"></a>12.Java 如何实现线程变量安全隔离?</h4><p>Java可以通过ThreadLocal类实现线程变量的安全隔离</p><h4 id="13-Java-分布式锁的实现方式有哪些"><a href="#13-Java-分布式锁的实现方式有哪些" class="headerlink" title="13.Java 分布式锁的实现方式有哪些?"></a>13.Java 分布式锁的实现方式有哪些?</h4><p>分布式锁的实现方式有基于数据库唯一索引、基于Redis、基于ZooKeeper等方式.</p><h4 id="14-常见的加密方式有那些-非对称加密和对称加密的区别是什么"><a href="#14-常见的加密方式有那些-非对称加密和对称加密的区别是什么" class="headerlink" title="14.常见的加密方式有那些?非对称加密和对称加密的区别是什么?"></a>14.常见的加密方式有那些?非对称加密和对称加密的区别是什么?</h4><p>常见的加密方式有AES、RSA等，非对称加密和对称加密的区别在于加密和解密使用同一密钥的是对称加密，使用不同密钥的是非对称加密。</p><h4 id="15-什么是-QPS、并发数"><a href="#15-什么是-QPS、并发数" class="headerlink" title="15.什么是 QPS、并发数?"></a>15.什么是 QPS、并发数?</h4><p>QPS是每秒查询率的缩写，表示服务器每秒处理的请求数;并发数是指同时处理请求的数量。</p><h4 id="16-Mybatis-Plus批量更新的方法是什么"><a href="#16-Mybatis-Plus批量更新的方法是什么" class="headerlink" title="16.Mybatis Plus批量更新的方法是什么?"></a>16.Mybatis Plus批量更新的方法是什么?</h4><p>Mybatis Plus中批量更新可以使用updateBatchByld方法,</p><h4 id="17-MySql如何分析-SQL-语句的关键字是什么"><a href="#17-MySql如何分析-SQL-语句的关键字是什么" class="headerlink" title="17.MySql如何分析 SQL,语句的关键字是什么?"></a>17.MySql如何分析 SQL,语句的关键字是什么?</h4><p>MySQL分析SQL语句可以使用explain关键字</p><h4 id="18-如何查看MySQL的当前连接情况-怎么杀死堵塞连接"><a href="#18-如何查看MySQL的当前连接情况-怎么杀死堵塞连接" class="headerlink" title="18.如何查看MySQL的当前连接情况?怎么杀死堵塞连接?"></a>18.如何查看MySQL的当前连接情况?怎么杀死堵塞连接?</h4><p>查看MySQL的当前连接情况可以使用show processlist命令，杀死堵塞连接可以使用kil命令</p><h4 id="19-请设计一个登录和权限控制的表结构-仅需写出设计表名字和表之间关联关系即可，无需具体字段"><a href="#19-请设计一个登录和权限控制的表结构-仅需写出设计表名字和表之间关联关系即可，无需具体字段" class="headerlink" title="19.请设计一个登录和权限控制的表结构(仅需写出设计表名字和表之间关联关系即可，无需具体字段)"></a>19.请设计一个登录和权限控制的表结构(仅需写出设计表名字和表之间关联关系即可，无需具体字段)</h4><p>设计一个登录和权限控制的表结构:用户表(User)和角色表(Role)，之间通过用户角色映射表(UserRole)建立关联.</p><h4 id="20-如果需要进行商品库存扣减，如何兼顾性能和准确性，不出现超扣、重复扣、少扣等情况"><a href="#20-如果需要进行商品库存扣减，如何兼顾性能和准确性，不出现超扣、重复扣、少扣等情况" class="headerlink" title="20.如果需要进行商品库存扣减，如何兼顾性能和准确性，不出现超扣、重复扣、少扣等情况?"></a>20.如果需要进行商品库存扣减，如何兼顾性能和准确性，不出现超扣、重复扣、少扣等情况?</h4><p>实现商品库存扣减可以使用乐观锁或分布式事务等方案，确保性能和准确性。</p><hr><h2 id="XX公司"><a href="#XX公司" class="headerlink" title="XX公司"></a>XX公司</h2><h3 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h3><h4 id="1-请解释-Arraylist-和-LinkedList-的区别"><a href="#1-请解释-Arraylist-和-LinkedList-的区别" class="headerlink" title="1.请解释 Arraylist 和 LinkedList 的区别?"></a>1.请解释 Arraylist 和 LinkedList 的区别?</h4><p>ArrayList和LinkedList都是Java中的集合类，但它们在内部实现和使用时有一些重要的区别。</p><p>ArrayList:</p><ol><li>内部实现：ArrayList是基于数组实现的动态数组，它可以自动扩展和收缩容量。当元素被添加到ArrayList中时，它会在内部自动增加容量，并且可以在需要的情况下收缩容量。</li><li>随机访问效率高：由于基于数组实现，ArrayList支持随机访问，所以可以根据索引快速获取元素。时间复杂度为O(1)。</li><li>插入和删除效率低：在中间或头部插入或删除元素时，由于需要移动大量元素，效率较低，时间复杂度为O(n)。</li><li>应用场景：适合需要快速随机访问元素的场景，而且不经常进行插入和删除操作的情况。</li></ol><p>LinkedList:</p><ol><li>内部实现：LinkedList基于双向链表实现的，每个元素都包含了指向前一个和后一个元素的引用。这使得插入和删除操作非常高效。</li><li>随机访问效率低：由于基于链表实现，不支持随机访问，需要遍历整个链表来获取指定位置的元素。时间复杂度为O(n)。</li><li>插入和删除效率高：在中间或头尾插入删除操作效率很高，因为只需要调整相邻元素的指针，时间复杂度为O(1)。</li><li>应用场景：适合频繁插入和删除操作的场景，而对随机访问效率要求不高的情况。</li></ol><p>综上所述，ArrayList适合需要快速随机访问的场景，而LinkedList适合频繁进行插入和删除操作的场景。</p><h4 id="2-break和continue-的区别"><a href="#2-break和continue-的区别" class="headerlink" title="2.break和continue 的区别?"></a>2.break和continue 的区别?</h4><p>在Java中，<code>break</code> 和 <code>continue</code> 是用于控制循环语句执行流程的关键字，它们的作用分别如下：</p><ol><li><code>break</code> 关键字用于跳出循环。当遇到 <code>break</code> 关键字时，循环会立即终止，程序将会跳出循环体，执行循环后面的代码。<code>break</code> 主要用于在满足某个条件时提前终止循环，通常和条件语句一起使用。</li></ol><p>示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 当 i 等于 5 时跳出循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>continue</code> 关键字用于跳过当前循环的后续代码，直接进入下一次循环。当遇到 <code>continue</code> 关键字时，循环会跳过当前迭代中 <code>continue</code> 后面的代码，直接进行下一次迭代。</li></ol><p>示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">// 当 i 等于 2 时跳过当前迭代，直接进行下一次迭代</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li><code>break</code> 用于终止当前循环，跳出循环体。</li><li><code>continue</code> 用于跳过当前迭代的后续代码，进入下一次迭代。</li></ul><h4 id="3-对称加密与非对称加密的区别"><a href="#3-对称加密与非对称加密的区别" class="headerlink" title="3.对称加密与非对称加密的区别?"></a>3.对称加密与非对称加密的区别?</h4><p>对称加密和非对称加密是两种常见的加密算法，它们之间的主要区别在于加密和解密时所使用的密钥类型和数量。</p><ol><li>对称加密：</li></ol><ul><li>对称加密算法使用相同的密钥来进行加密和解密数据。</li><li>加密和解密过程使用同一个密钥，因此速度较快。</li><li>密钥管理相对简单，但在密钥分发和安全性方面存在一些挑战。</li><li>典型的对称加密算法包括 DES、AES 等。</li></ul><ol start="2"><li>非对称加密：</li></ol><ul><li>非对称加密算法使用一对密钥，称为公钥和私钥，来进行加密和解密数据。</li><li>公钥用于加密数据，私钥用于解密数据，因此公钥可以公开，而私钥通常保密。</li><li>非对称加密算法相对较慢，适合对少量数据进行加密。</li><li>非对称加密算法通常用于安全通信、数字签名等领域。</li><li>典型的非对称加密算法包括 RSA、ECC 等。</li></ul><p>总的来说，对称加密适合对大量数据进行加密，速度快效率高；而非对称加密适合对少量数据进行安全传输和验证，具有更强的安全性。在实际应用中，通常会结合两种加密算法来实现更安全高效的数据加密和传输方式。</p><h4 id="4-在-Java-程序中怎么保证多线程的运行安全"><a href="#4-在-Java-程序中怎么保证多线程的运行安全" class="headerlink" title="4.在 Java 程序中怎么保证多线程的运行安全?"></a>4.在 Java 程序中怎么保证多线程的运行安全?</h4><p>在 Java 程序中，可以通过以下几种方式来保证多线程的运行安全：</p><ol><li>使用同步代码块或同步方法：使用 <code>synchronized</code> 关键字来修饰代码块或方法，确保同一时间只有一个线程可以进入临界区，避免多个线程同时访问共享资源。</li></ol><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 Lock 接口实现类：通过 <code>java.util.concurrent.locks</code> 包中的 <code>Lock</code> 接口及其实现类来进行线程同步。</li></ol><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用 volatile 关键字：在声明共享变量时使用 <code>volatile</code> 关键字，确保线程之间对变量的修改可以被立即可见，避免线程之间的数据不一致。</li></ol><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">            <span class="comment">// 循环执行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>使用线程安全的集合类：使用 <code>java.util.concurrent</code> 包中提供的线程安全的集合类（如 <code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code> 等）来替代普通的集合类，以确保并发访问时的线程安全。</li></ol><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap&lt;String, String&gt; concurrentMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><ol start="5"><li>使用原子类：使用 <code>java.util.concurrent.atomic</code> 包中的原子类（如 <code>AtomicInteger</code>、<code>AtomicLong</code> 等）实现线程安全的原子操作。</li></ol><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            count.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上方式，可以在 Java 程序中保证多线程的运行安全，避免由于并发访问共享资源而导致的数据不一致、死锁、竞态条件等问题。</p><h4 id="5-什么是缓存穿透-应该如何优化"><a href="#5-什么是缓存穿透-应该如何优化" class="headerlink" title="5.什么是缓存穿透?应该如何优化?"></a>5.什么是缓存穿透?应该如何优化?</h4><p>缓存穿透是指一个缓存中不存在的数据，而且这个数据在数据库中也不存在，但是由于缓存的失效时间较长，导致每次针对这个数据的查询请求都会穿透缓存，直接访问数据库，如果大量的操作都是无效数据的话，就会对数据库造成很大的压力，甚至可能导致宕机。</p><p>缓存穿透的典型场景是针对不存在的数据进行的查询，比如查询某个不存在的ID对应的数据。攻击者可以通过构造大量不存在的ID，使得系统频繁地查询数据库，绕过缓存直接对数据库发起请求，从而消耗数据库资源。</p><p>为了解决缓存穿透问题，可以采取以下一些优化措施：</p><ol><li><p>布隆过滤器（Bloom Filter）：使用布隆过滤器来过滤掉不存在的数据，降低对数据库的查询压力。布隆过滤器是一种数据结构，能够高效地判断一个元素是否存在于一个集合中或者可能存在于一个集合中，可以快速拦截一部分不存在的请求，避免对数据库的查询。</p></li><li><p>缓存空对象：对于那些数据库中不存在的数据，可以将其信息存储为空对象或者占位符对象于缓存中，这样当下次再请求同样的数据，就能从缓存中获取，而不会直接查询数据库。</p></li><li><p>设置合理的过期时间：对于可能存在缓存穿透的热点数据，可以设置较短的过期时间，以确保即使数据不存在或失效，也能在一段时间后自动刷新或被删除。</p></li><li><p>基于更底层的缓存技术：对于可能存在缓存穿透的热点数据，可以考虑使用更底层的缓存技术，如使用内存数据库（如 Redis）或者分布式缓存等，提高缓存的可靠性和可用性。</p></li></ol><p>综上所述，通过以上优化策略可以有效地解决缓存穿透问题，降低对数据库的请求压力，提高系统的健壮性和性能。</p><h4 id="6-数据库连接池的作用是什么"><a href="#6-数据库连接池的作用是什么" class="headerlink" title="6.数据库连接池的作用是什么?"></a>6.数据库连接池的作用是什么?</h4><p>数据库连接池是一个存储、管理数据库连接的缓冲池。它的作用是在应用程序和数据库之间建立一定数量的数据库连接，并对这些连接进行管理和复用，以提高数据库访问的效率和性能。数据库连接池的主要作用包括：</p><ol><li><p>提高性能：通过复用数据库连接，数据库连接池可以避免频繁地创建和销毁数据库连接，减少了连接的建立和释放所需的时间，从而缩短了数据库访问的响应时间，并且减轻了数据库服务器的负担，提高了系统的整体性能。</p></li><li><p>减少资源占用：数据库连接通常是一种昂贵的资源，占用较多的内存和CPU等资源。数据库连接池可以限制同时连接到数据库的数量，并对超出数量限制的连接进行排队或拒绝，以控制资源的使用，避免资源耗尽和系统崩溃。</p></li><li><p>提高应用程序的并发能力：数据库连接池可以为多个并发请求提供可用的数据库连接，提高应用程序的并发处理能力。</p></li><li><p>管理连接状态：数据库连接池能够管理数据库连接的状态，包括连接的创建、打开、关闭、超时等，以确保连接的可靠性和稳定性。</p></li><li><p>实现连接的生命周期管理：数据库连接池能够统一管理连接的生命周期，包括连接的分配、使用、回收和释放。</p></li></ol><p>总的来说，数据库连接池的作用是优化数据库访问过程，提高性能、减少资源占用，并管理和维护连接的状态，以实现更加高效可靠的数据库访问。</p><h4 id="7-SQL语句执行时，哪些情况下会产生全表扫描-分别应该如何优化"><a href="#7-SQL语句执行时，哪些情况下会产生全表扫描-分别应该如何优化" class="headerlink" title="7.SQL语句执行时，哪些情况下会产生全表扫描?分别应该如何优化?"></a>7.SQL语句执行时，哪些情况下会产生全表扫描?分别应该如何优化?</h4><p>以下情况下可能会导致产生全表扫描：</p><ol><li><p>没有合适的索引：如果表中没有适当的索引或索引被损坏，数据库引擎无法利用索引执行查询，只能进行全表扫描。</p></li><li><p>查询条件使用了非索引字段：如果查询条件使用了未被索引的字段，数据库无法利用索引定位记录，只能扫描全表。</p></li><li><p>查询使用了聚合函数：如果查询中使用了聚合函数（如SUM、AVG、COUNT等），数据库需要遍历所有符合条件的记录来计算聚合值，可能会导致全表扫描。</p></li><li><p>LIKE操作符以通配符开头：当在查询条件中使用LIKE操作符时，如果通配符（%或_）位于搜索模式的开头，数据库无法使用索引，只能进行全表扫描。</p></li></ol><p>优化的方法包括：</p><ol><li><p>创建合适的索引：根据查询条件和经常查询的字段创建索引，以便数据库能够有效地利用索引进行数据访问。</p></li><li><p>更新统计信息：及时更新数据库的统计信息，使数据库优化器能够更准确地评估和选择索引，提高查询性能。</p></li><li><p>优化查询语句：通过重构查询语句，避免使用非索引字段、聚合函数或通配符开头的LIKE操作符，以减少全表扫描的可能性。</p></li><li><p>分页查询：对于需要分页的查询，可以使用LIMIT语句限制返回的记录数量，避免扫描整个表。</p></li><li><p>使用覆盖索引：如果索引包含了查询所需的所有字段，数据库可以直接从索引中读取数据，而无需进行表的全面扫描。</p></li><li><p>优化硬件和数据库配置：如增加服务器资源、调整缓存设置等，以加快查询和减少全表扫描的时间。</p></li></ol><p>综上所述，通过创建适当的索引、优化查询语句和更新统计信息等方法，可以有效地减少全表扫描的发生，提高数据库查询性能。</p><h4 id="8-如何提升线程锁的性能"><a href="#8-如何提升线程锁的性能" class="headerlink" title="8.如何提升线程锁的性能?"></a>8.如何提升线程锁的性能?</h4><p>要提升线程锁的性能，可以考虑以下几个方面：</p><ol><li><p>减少锁的竞争：多线程并发访问同一资源时，可通过优化程序设计和数据结构，减少对共享资源的争用，从而减少锁的竞争。</p></li><li><p>细粒度锁：尽量使用细粒度的锁，即只锁定需要保护的最小数据范围，而不是锁定整个资源或对象。这样可以使得其他线程可以并发地访问其他部分，减少锁的等待时间。</p></li><li><p>避免长时间持有锁：尽量减少在锁定资源期间的处理时间，确保只有必要的代码块在锁内执行。长时间持有锁会导致其他线程等待时间增加，降低性能。</p></li><li><p>使用读写锁：如果资源的读操作远远多于写操作，可以考虑使用读写锁（ReentrantReadWriteLock），以允许多个线程并发地读取资源，而只有写操作需要互斥访问。</p></li><li><p>考虑使用乐观锁：在某些情况下，可以使用乐观锁来替代悲观锁。乐观锁是基于版本或时间戳的机制，在读取资源时不加锁，只在提交时检查是否有冲突，减少锁的使用。</p></li><li><p>锁分离和精确加锁：根据业务场景，将不同的资源分别锁定，使得不同的线程可以并发访问不同的资源，提高并发性。同时，避免过度加锁，只在必要的资源访问代码块内加锁。</p></li><li><p>合理选择锁实现方式：根据具体情况选择合适的锁实现方式，比如synchronized、Lock接口的实现类（如ReentrantLock）或并发集合类（如ConcurrentHashMap），以满足不同的性能需求。</p></li><li><p>性能测试和调优：通过性能测试和基准测试，分析和监测应用程序中的瓶颈，根据实际情况对锁的使用进行调优和优化，以提升性能。</p></li></ol><p>需要注意的是，锁的性能优化需要根据具体的业务场景和系统设计来综合考虑和实施，并没有一种通用的解决方案适用于所有情况。因此，在进行锁的性能优化时，需要根据实际情况结合以上建议进行评估和实验，以找到最佳的性能优化策略。</p><h4 id="9-请简述一致性哈希算法"><a href="#9-请简述一致性哈希算法" class="headerlink" title="9.请简述一致性哈希算法"></a>9.请简述一致性哈希算法</h4><p>一致性哈希算法是一种用于将数据分布到多个服务器节点的算法，它主要用于负载均衡和缓存分布式数据存储中。一致性哈希算法的原理如下：</p><ol><li><p>哈希环：一致性哈希算法将服务器节点和数据都映射到一个虚拟的哈希环空间上。这个哈希环通常是一个以整数表示的环状结构，即节点和数据被映射到环上的某个点上。</p></li><li><p>节点映射：每个服务器节点根据其自身的标识（例如IP地址或者名称）计算出一个哈希值，然后在哈希环上选择一个位置来表示该节点。</p></li><li><p>数据映射：对于需要被存储或查找的数据，也通过相同的哈希函数计算出其哈希值，并映射到与该哈希值最接近的服务器节点上。</p></li><li><p>加入和删除节点：当服务器节点增加或删除时，只会影响到少量的数据重新映射。通过在新添加的节点和被删除的节点之间重新映射部分数据，可以最大程度地减少数据的迁移。</p></li></ol><p>一致性哈希算法的优点是能够提供良好的负载均衡，并且在节点变化时能够最小化数据的迁移。因此，它被广泛应用于构建分布式缓存系统、负载均衡器、分布式数据库等场景中。</p><hr><h4 id="java系统开发中，怎么保证数据安全"><a href="#java系统开发中，怎么保证数据安全" class="headerlink" title="java系统开发中，怎么保证数据安全?"></a>java系统开发中，怎么保证数据安全?</h4><p>在Java系统开发中，可以采取以下措施来保证数据安全：</p><ol><li><p>访问控制：实施严格的访问控制策略，仅允许授权用户或角色访问敏感数据，通过身份验证和授权机制来限制对数据的访问。</p></li><li><p>加密：对敏感数据进行加密，包括数据传输过程中的加密（例如使用SSL&#x2F;TLS协议），以及数据存储过程中的加密（例如使用可靠的加密算法和密钥管理）。</p></li><li><p>数据备份与恢复：进行定期的数据备份，以防止数据丢失。同时，建立灾备和恢复计划，确保在发生意外情况时能够快速恢复数据。</p></li><li><p>异常处理与日志记录：在系统中实施完善的异常处理机制，及时捕获和处理错误，并记录系统运行日志。对于敏感数据的操作记录，可以采取审计日志的方式来追踪和监控。</p></li><li><p>输入验证与过滤：对用户输入的数据进行有效性验证和安全过滤，防止恶意数据输入和注入攻击。</p></li><li><p>安全测试与审计：进行系统安全性测试，包括渗透测试和漏洞扫描，及时发现并修复系统的安全漏洞。同时定期进行安全审计，评估系统的安全性和合规性。</p></li><li><p>安全编码实践：采用安全编码的最佳实践，包括避免使用已知的容易受到攻击的函数、实施输入验证和输出编码等措施。</p></li><li><p>更新与升级：及时更新和升级系统的依赖库、框架和组件，以获得最新的安全补丁和修复。</p></li><li><p>培训和意识提升：提供培训和教育，提高开发团队对数据安全的意识和技能，确保他们了解并遵守数据安全的最佳实践。</p></li></ol><p>通过以上措施综合应用，可以加强Java系统的数据安全性，减少数据泄露、数据损坏和未授权访问等风险。</p><hr><h2 id="成都伊登软件技术有限公司"><a href="#成都伊登软件技术有限公司" class="headerlink" title="成都伊登软件技术有限公司"></a>成都伊登软件技术有限公司</h2><h4 id="http和https的区别？"><a href="#http和https的区别？" class="headerlink" title="http和https的区别？"></a>http和https的区别？</h4><p>HTTP（Hypertext Transfer Protocol）是一种用于在Web上进行数据通信的协议。它使用明文进行数据传输，无法保证数据的安全性。</p><p>而HTTPS（Hypertext Transfer Protocol Secure）是HTTP的安全版本。它使用了TLS&#x2F;SSL加密协议对数据进行加密，确保数据在传输过程中的保密性和完整性。</p><p>主要区别如下：</p><ol><li>安全性：HTTP不具备数据加密的功能，数据在传输过程中可能被窃取或篡改；而HTTPS通过TLS&#x2F;SSL加密协议对数据进行加密，确保数据的安全传输。</li><li>默认端口：HTTP使用80端口进行通信，而HTTPS使用443端口进行通信。</li><li>证书：HTTPS需要使用由受信任的证书颁发机构（CA）签发的数字证书，用于验证服务器的身份；而HTTP无需证书验证。</li><li>性能：由于数据的加密与解密过程，以及握手过程的增加，HTTPS相对于HTTP会稍微降低性能。</li><li>URL前缀：HTTP的URL以”http:&#x2F;&#x2F;“开头，而HTTPS的URL以”https:&#x2F;&#x2F;“开头。</li></ol><p>总的来说，HTTPS相对于HTTP更加安全，适用于需要保护用户隐私和敏感数据的网站，如电子商务网站、金融机构网站等。而HTTP则适用于不需要数据加密和保护的普通网站。</p><h4 id="TCP的三次握手，四次挥手？"><a href="#TCP的三次握手，四次挥手？" class="headerlink" title="TCP的三次握手，四次挥手？"></a>TCP的三次握手，四次挥手？</h4><p>TCP的三次握手指的是在建立TCP连接时，通信双方需要进行三次握手来确认彼此的通信能力。</p><ol><li><p>第一次握手（SYN）：客户端发送一个带有SYN（同步）标志的数据包给服务器，请求建立连接。客户端进入SYN_SENT状态。</p></li><li><p>第二次握手（SYN+ACK）：服务器收到客户端的请求后，会发送一个带有SYN和ACK（确认）标志的数据包给客户端，表示同意建立连接。服务器进入SYN_RECV状态。</p></li><li><p>第三次握手（ACK）：客户端收到服务器的确认后，再次发送一个带有ACK标志的数据包给服务器，表示连接已建立。服务器和客户端都进入ESTABLISHED（已建立）状态，可以开始正常的数据传输。</p></li></ol><p>TCP的四次挥手指的是在关闭TCP连接时，通信双方需要进行四次挥手来确认关闭连接。</p><ol><li><p>第一次挥手（FIN）：当一方决定关闭连接时，发送一个带有FIN（连接终止）标志的数据包给对方，表示希望关闭连接。发送方进入FIN_WAIT_1状态。</p></li><li><p>第二次挥手（ACK）：接收到关闭请求后的一方发回一个带有ACK标志的数据包作为确认。发送方进入FIN_WAIT_2状态。</p></li><li><p>第三次挥手（FIN）：被动方（接收关闭请求的一方）也发送一个带有FIN标志的数据包给请求关闭的一方，表示同意关闭连接。发送方进入TIME_WAIT状态。</p></li><li><p>第四次挥手（ACK）：最后发送方收到被动方的确认后，发送一个带有ACK标志的数据包给被动方确认，双方都进入CLOSED状态，连接关闭。</p></li></ol><p>通过三次握手和四次挥手，TCP协议可以实现可靠的连接建立和释放，确保数据能够正确无误地传输。</p><h4 id="什么是单向链表，什么是双向链表？"><a href="#什么是单向链表，什么是双向链表？" class="headerlink" title="什么是单向链表，什么是双向链表？"></a>什么是单向链表，什么是双向链表？</h4><p>单向链表和双向链表都是用于存储和组织数据的数据结构，它们之间的主要区别在于节点之间的连接方式。</p><p>单向链表：<br>单向链表是由节点组成的数据结构，每个节点包含一个数据元素和一个指向下一个节点的指针。节点依次连接起来，形成一个链表。单向链表只能从头节点开始顺序访问，无法从尾部向前访问。单向链表的最后一个节点的指针通常指向一个特殊的空值（null）。</p><p>双向链表：<br>双向链表也是由节点组成的数据结构，每个节点包含一个数据元素、一个指向下一个节点的指针和一个指向上一个节点的指针。这样每个节点既可以从前向后访问，也可以从后向前访问，提供了更多的灵活性。双向链表可以从头部和尾部同时进行遍历和操作，但相对于单向链表，双向链表在空间上需要更多的指针来存储前一个节点的地址。</p><p>总的来说，单向链表适合在一个方向上进行数据的增、删、查操作，而双向链表在需要在两个方向上进行操作时提供更好的效率。</p><h4 id="java中，什么是反射？反射会带来什么问题？"><a href="#java中，什么是反射？反射会带来什么问题？" class="headerlink" title="java中，什么是反射？反射会带来什么问题？"></a>java中，什么是反射？反射会带来什么问题？</h4><p>在Java中，反射是指在运行时动态地获取类的信息（如类的属性、方法、构造函数等），并能够在运行时调用类的方法、访问属性，以及创建对象实例。通过反射，可以在编译时未知类的情况下，动态地获取和操作类的信息，从而实现更加灵活和动态的代码。</p><p>反射会带来一些问题，包括：</p><ol><li><p>性能开销：反射操作通常比直接的静态编译代码要慢，因此频繁使用反射可能会导致性能下降。</p></li><li><p>安全性问题：反射能够绕过访问修饰符的限制，可以访问并修改私有成员，这可能会破坏封装性和安全性。使用反射时需要谨慎，确保只在必要时使用，并遵守安全性的最佳实践。</p></li><li><p>运行时异常：由于反射是在运行时进行的，很难在编译时捕获潜在的错误。例如，如果使用反射调用了一个不存在的方法或字段，会在运行时抛出NoSuchMethodException或NoSuchFieldException等异常。</p></li><li><p>代码可读性和维护性降低：使用反射会增加代码的复杂性和难度，因为它需要显式地处理类型转换、异常处理和方法调用等细节。反射的代码通常比直接调用方法的代码更难理解和维护。</p></li></ol><p>总体而言，反射是一项非常有用的功能，但应慎重使用，并在有限的情况下使用。在大多数情况下，应尽量避免过度依赖于反射，而是优先考虑使用静态编译的方式编写代码，以提高性能和可靠性。</p><h4 id="mybatis-plus分页原理"><a href="#mybatis-plus分页原理" class="headerlink" title="mybatis-plus分页原理?"></a>mybatis-plus分页原理?</h4><p>MyBatis-Plus是一个紧密集成的MyBatis框架的增强工具，它为开发人员提供了更便捷的操作数据库的方法。在MyBatis-Plus中，分页查询是一个非常常见且有用的功能，它能够简化开发人员对数据库分页查询的操作。</p><p>MyBatis-Plus中的分页查询原理包括以下几个步骤：</p><ol><li><p>分页参数封装：在进行分页查询时，开发人员需要指定分页查询的页数和每页的数据量，MyBatis-Plus中通常通过Page对象来封装这些分页参数。</p></li><li><p>总记录数查询：在进行分页查询之前，需要先获取满足条件的总记录数。MyBatis-Plus中可以通过Page对象的setTotal方法来设置总记录数，通常会使用count查询来获取总记录数。</p></li><li><p>分页查询：通过在SQL中添加LIMIT关键字或者使用类似ROWNUM的数据库特定语法，在查询数据库时限制返回的结果集的数量，从而实现分页查询。</p></li><li><p>结果封装：最后，将分页查询的结果封装到Page对象中，以便于在业务逻辑中进行处理和展示。</p></li></ol><p>MyBatis-Plus框架通过对上述步骤的封装和提供简化的API，使得分页查询变得更加简单和便捷。开发人员可以通过Page对象设置分页参数，然后直接调用MyBatis-Plus提供的分页查询方法，即可完成分页查询操作。</p><h4 id="ES如何优化？"><a href="#ES如何优化？" class="headerlink" title="ES如何优化？"></a>ES如何优化？</h4><p>针对Elasticsearch（ES）的优化，可以从以下几个方面入手：</p><ol><li><p>硬件优化：确保服务器硬件资源足够强大，包括处理器、内存、磁盘和网络。使用SSD硬盘可以提升性能，而且确保具有足够的存储空间。</p></li><li><p>集群配置优化：适当配置集群的节点数和分片数。节点数量不宜过多，避免频繁的分片迁移和通信开销。分片数量不宜过多，避免过多的分片导致查询性能下降。</p></li><li><p>索引设计优化：对于大型索引，可以考虑控制分片数和副本数量。合理设置分片数和副本数可以提高查询负载的处理能力。同时，合理选择字段类型、设置合适的字段分词和索引策略，减少不必要的字段。</p></li><li><p>查询优化：尽量避免使用全量查询，使用过滤器、聚合和缓存等技术，减少查询的响应时间。使用索引字段和主键字段进行查询可以提高查询性能。对于频繁使用的查询，可以考虑使用缓存来提高性能。</p></li><li><p>内存和缓存优化：提供足够的JVM堆内存，以减少频繁的GC操作。使用操作系统级别的缓存，如操作系统页面缓存和文件系统缓存，可以提高IO性能。</p></li><li><p>性能监控和调优：使用Elasticsearch提供的监控工具和API，掌握系统的运行状态，根据情况进行调优。</p></li><li><p>其他优化措施：合理使用索引别名、分片路由、局部更新等ES提供的功能。</p></li></ol><p>需要注意的是，优化策略也需要根据特定的场景和需求来做出相应的调整，因此对于每个具体的应用场景，最好进行性能测试和调优，才能找到最优的配置和优化策略。</p><h4 id="ES如何设置索引？"><a href="#ES如何设置索引？" class="headerlink" title="ES如何设置索引？"></a>ES如何设置索引？</h4><p>在Elasticsearch（ES）中，可以通过以下步骤设置索引：</p><ol><li>创建索引：使用PUT请求，指定索引的名称和相关的参数。例如，可以使用以下命令创建名为”my_index”的索引：</li></ol><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br></pre></td></tr></table></figure><ol start="2"><li>设置索引映射：在索引创建之后，可以设置索引的映射，即定义索引中的字段名称、类型以及一些其他属性。使用PUT请求，指定索引的名称和”_mapping”后缀，然后提供映射的定义。例如，可以使用以下命令设置名为”my_index”的索引的映射：</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index/_mapping</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;field1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;field2&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>索引文档：在索引设置和映射完成之后，可以通过POST、PUT或者BULK API请求来将文档索引到指定的索引中。例如，可以使用以下命令将一个文档索引到名为”my_index”的索引中：</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index/_doc/<span class="number">1</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;field1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;field2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>需要注意的是，索引创建和映射设置可以在索引创建之前执行，也可以在索引创建之后执行，甚至可以随时修改映射。此外，ES还提供了多种设置索引的参数，如分片数、副本数、索引别名等，可以根据具体需求进行设置。</p><p>可以根据具体的业务需求和数据类型，灵活选择不同的字段类型和映射设置，以及合理配置索引参数，从而提高索引性能和查询效果。</p><hr><h2 id="正浩电力科技"><a href="#正浩电力科技" class="headerlink" title="正浩电力科技"></a>正浩电力科技</h2><h4 id="远程桌面用过吗？"><a href="#远程桌面用过吗？" class="headerlink" title="远程桌面用过吗？"></a>远程桌面用过吗？</h4><h4 id="怎么查看以前项目的版本？"><a href="#怎么查看以前项目的版本？" class="headerlink" title="怎么查看以前项目的版本？"></a>怎么查看以前项目的版本？</h4><h4 id="视频的流媒体怎么处理的"><a href="#视频的流媒体怎么处理的" class="headerlink" title="视频的流媒体怎么处理的"></a>视频的流媒体怎么处理的</h4><h4 id="分成了多少个微服务，部署了多少个服务器"><a href="#分成了多少个微服务，部署了多少个服务器" class="headerlink" title="分成了多少个微服务，部署了多少个服务器"></a>分成了多少个微服务，部署了多少个服务器</h4><h4 id="项目的版本管理"><a href="#项目的版本管理" class="headerlink" title="项目的版本管理"></a>项目的版本管理</h4><h4 id="需求文档写没写过"><a href="#需求文档写没写过" class="headerlink" title="需求文档写没写过"></a>需求文档写没写过</h4><h4 id="数组有length属性，字符串有length方法"><a href="#数组有length属性，字符串有length方法" class="headerlink" title="数组有length属性，字符串有length方法"></a><font color="red">数组有length属性，字符串有length方法</font></h4><h4 id="标准化的软件开发流程"><a href="#标准化的软件开发流程" class="headerlink" title="标准化的软件开发流程"></a>标准化的软件开发流程</h4><p>标准化的软件开发流程是指在软件开发过程中遵循一套明确、系统的步骤和方法，以提高软件质量、效率和可维护性。一个典型的标准化软件开发流程包括以下几个阶段：</p><ol><li><p><strong>需求分析</strong>：</p><ul><li>目的：理解和收集用户需求，明确软件的功能和性能要求。</li><li>方法：通过访谈、问卷调查、文档分析等方式与用户沟通，收集需求信息。</li><li>输出：需求规格说明书（SRS），它详细描述了软件的功能需求和非功能需求。</li></ul></li><li><p><strong>系统设计</strong>：</p><ul><li>目的：根据需求规格说明书设计软件的架构和组件。</li><li>方法：采用UML图、流程图等工具来设计系统的数据流、架构、接口和组件。</li><li>输出：系统设计文档，包括软件架构设计、数据库设计、接口设计等。</li></ul></li><li><p><strong>编码实现</strong>：</p><ul><li>目的：根据系统设计文档，使用编程语言编写软件代码。</li><li>方法：选择合适的编程语言和开发工具，按照编码规范和标准进行编码。</li><li>输出：源代码和可执行的软件产品。</li></ul></li><li><p><strong>软件测试</strong>：</p><ul><li>目的：通过各种测试方法确保软件质量，发现并修复缺陷。</li><li>方法：包括单元测试、集成测试、系统测试和验收测试等。</li><li>输出：测试报告，记录测试结果和未解决的问题。</li></ul></li><li><p><strong>部署与交付</strong>：</p><ul><li>目的：将软件部署到用户环境中，并确保用户可以正确使用。</li><li>方法：包括安装、配置、数据迁移和用户培训等步骤。</li><li>输出：部署完成的软件系统和用户手册。</li></ul></li><li><p><strong>维护与更新</strong>：</p><ul><li>目的：在软件交付后，持续监控其性能，解决出现的问题，满足用户新的需求。</li><li>方法：定期更新软件版本，修复缺陷，改进性能，增加新功能。</li><li>输出：更新的软件版本和维护报告。</li></ul></li></ol><p>在整个软件开发流程中，还需要注意以下几点：</p><ul><li><strong>文档管理</strong>：每个阶段的输出都应该有相应的文档记录，以便于团队成员之间的沟通和后期的维护。</li><li><strong>质量保证</strong>：在整个开发过程中，应该有专门的质量保证活动，如代码审查、设计审查等，以确保软件质量。</li><li><strong>项目管理</strong>：有效的项目管理是确保软件开发成功的关键，需要合理规划资源、时间和成本。</li></ul><p>标准化的软件开发流程有助于提高开发效率、降低开发风险，并提高软件的质量和可维护性。不同的项目和团队可能会根据实际情况对这个流程进行调整，但基本的原则和步骤是相似的。</p><h4 id="安全漏洞扫描做过没"><a href="#安全漏洞扫描做过没" class="headerlink" title="安全漏洞扫描做过没"></a>安全漏洞扫描做过没</h4><h4 id="4层TCP-IP协议"><a href="#4层TCP-IP协议" class="headerlink" title="4层TCP&#x2F;IP协议"></a>4层TCP&#x2F;IP协议</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zcjbky/p/15507147.html">TCP&#x2F;IP网络体系结构中，各层的作用，以及各层协议的作用</a></p><h4 id="什么是ffmpeg"><a href="#什么是ffmpeg" class="headerlink" title="什么是ffmpeg"></a>什么是ffmpeg</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/89872960">30分带你从认识FFmpeg到玩转FFmpeg</a></p><h4 id="使用java结合ffmpeg如何对视频进行流媒体处理以及多种清晰度处理？"><a href="#使用java结合ffmpeg如何对视频进行流媒体处理以及多种清晰度处理？" class="headerlink" title="使用java结合ffmpeg如何对视频进行流媒体处理以及多种清晰度处理？"></a>使用java结合ffmpeg如何对视频进行流媒体处理以及多种清晰度处理？</h4><p>使用Java结合ffmpeg可以对视频进行流媒体处理以及多种清晰度处理的示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VideoProcessing</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">inputFile</span> <span class="operator">=</span> <span class="string">&quot;input_video.mp4&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">outputFile</span> <span class="operator">=</span> <span class="string">&quot;output_video.mp4&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用ffmpeg进行视频流媒体处理</span></span><br><span class="line">        <span class="type">ProcessBuilder</span> <span class="variable">processBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(<span class="string">&quot;ffmpeg&quot;</span>, <span class="string">&quot;-i&quot;</span>, inputFile, <span class="string">&quot;-c:v&quot;</span>, <span class="string">&quot;libx264&quot;</span>, <span class="string">&quot;-c:a&quot;</span>, <span class="string">&quot;aac&quot;</span>, <span class="string">&quot;-movflags&quot;</span>, <span class="string">&quot;faststart&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;mp4&quot;</span>, outputFile);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> processBuilder.start();</span><br><span class="line">            process.waitFor();</span><br><span class="line">            System.out.println(<span class="string">&quot;视频流媒体处理完成！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用ffmpeg进行多种清晰度处理</span></span><br><span class="line">        String[] resolutions = &#123;<span class="string">&quot;480x360&quot;</span>, <span class="string">&quot;640x480&quot;</span>, <span class="string">&quot;1280x720&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (String resolution : resolutions) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">outputFilename</span> <span class="operator">=</span> <span class="string">&quot;output_video_&quot;</span> + resolution + <span class="string">&quot;.mp4&quot;</span>;</span><br><span class="line">            <span class="type">ProcessBuilder</span> <span class="variable">resizeProcessBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(<span class="string">&quot;ffmpeg&quot;</span>, <span class="string">&quot;-i&quot;</span>, inputFile, <span class="string">&quot;-vf&quot;</span>, <span class="string">&quot;scale=&quot;</span> + resolution, <span class="string">&quot;-c:v&quot;</span>, <span class="string">&quot;libx264&quot;</span>, <span class="string">&quot;-c:a&quot;</span>, <span class="string">&quot;aac&quot;</span>, <span class="string">&quot;-movflags&quot;</span>, <span class="string">&quot;faststart&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;mp4&quot;</span>, outputFilename);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Process</span> <span class="variable">resizeProcess</span> <span class="operator">=</span> resizeProcessBuilder.start();</span><br><span class="line">                resizeProcess.waitFor();</span><br><span class="line">                System.out.println(<span class="string">&quot;多种清晰度处理完成：&quot;</span> + resolution);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例代码中，我们使用了ProcessBuilder来调用ffmpeg命令进行视频流媒体处理和多种清晰度处理。视频流媒体处理使用了-c:v和-c:a参数指定视频编码器和音频编码器，同时指定了输出文件格式为mp4。多种清晰度处理使用了-vf参数来指定视频尺寸，生成了多个不同分辨率的视频文件。</p><p>请注意，要使用ffmpeg需要先安装ffmpeg，并将ffmpeg的bin目录添加到系统环墓环境变量中。另外，使用ProcessBuilder来执行外部命令时需要处理IO异常和InterruptedException。</p><hr><h2 id="xx公司"><a href="#xx公司" class="headerlink" title="xx公司"></a>xx公司</h2><h4 id="MySQL有几种索引，有哪些情况什么情况下会索引失效"><a href="#MySQL有几种索引，有哪些情况什么情况下会索引失效" class="headerlink" title="MySQL有几种索引，有哪些情况什么情况下会索引失效?"></a>MySQL有几种索引，有哪些情况什么情况下会索引失效?</h4><p>MySQL主要有以下几种索引：</p><ol><li>B-Tree索引：最常见的索引类型，适用于等值查询、范围查询和排序查询。</li><li>哈希索引：只支持等值查询，适用于频繁使用等值查询并且数据量很大的表。</li><li>全文索引：适用于全文搜索功能。</li></ol><p>索引会在以下情况下失效：</p><ol><li>不使用索引列进行查询：如果查询条件中不包含任何索引列，那么索引将无法被使用。</li><li>对索引列进行函数操作：如果在查询条件中对索引列进行函数操作，如使用函数进行计算、转换、拼接等，那么索引将无法被使用。</li><li>使用通配符前缀查询：如果在查询条件中使用LIKE ‘%xxx’这样的通配符前缀查询，索引将无法被使用。</li><li>范围查询过于宽泛：如果在查询条件中使用范围查询，但范围过于宽泛，涉及的数据量很大，那么索引可能会失效。</li><li>组合索引顺序问题：如果创建了多列的组合索引，但查询条件中的列顺序与索引中的顺序不一致，索引将无法被使用。</li><li>表数据过小：如果表的数据量很小，使用索引可能不会带来太大性能优势，甚至可能影响查询性能。</li></ol><p>以上是一些常见的情况，具体的索引失效情况还会受到数据库的版本、表结构以及查询语句的复杂度等因素的影响。</p><h4 id="java单例模式代码"><a href="#java单例模式代码" class="headerlink" title="java单例模式代码"></a>java单例模式代码</h4><p>下面是一个简单的线程安全的单例模式的Java代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 私有化构造方法，禁止外部实例化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，通过私有化构造方法和静态方法<code>getInstance()</code>实现了单例模式。在<code>getInstance()</code>方法中，使用双重检查锁定来保证线程安全。关键点在于使用<code>volatile</code>关键字修饰<code>instance</code>变量，确保在多线程环境下的可见性和有序性。在第一次调用<code>getInstance()</code>方法时，会进行双重检查，避免多次创建实例。只有在<code>instance</code>为<code>null</code>时才会创建一个新的实例。这种方式既保证了线程安全，又避免了每次调用<code>getInstance()</code>都加锁导致的性能损耗。</p><p>此外，还有其他实现单例模式的方式，如饿汉式单例模式、懒汉式单例模式、静态内部类单例模式等。具体选择哪种方式取决于实际场景和需求。</p><h4 id="hashMap与hashTable区别"><a href="#hashMap与hashTable区别" class="headerlink" title="hashMap与hashTable区别?"></a>hashMap与hashTable区别?</h4><p>HashMap和Hashtable是两种在Java中常用的Map接口的实现类，它们之间的主要区别如下所示：</p><ol><li><p>线程安全性：Hashtable是线程安全的，它的方法都是同步的，适用于多线程环境；而HashMap是非线程安全的，如果在多线程环境下使用HashMap，需要外部保证线程安全性。</p></li><li><p>null值与null键：Hashtable不允许存储null值和null键，当尝试存储null值或者null键时，会抛出NullPointerException；而HashMap允许存储一个null值，并且允许最多一个null键。</p></li><li><p>继承关系：Hashtable是早期的Java类，实现了Dictionary接口，并继承自Hashtable类；而HashMap实现了Map接口，继承自AbstractMap类。</p></li><li><p>迭代器（Iterator）：Hashtable的迭代器是通过Enumeration接口实现的；而HashMap的迭代器是通过Iterator接口实现的，支持快速失败（Fail-Fast）机制。</p></li><li><p>集合视图（Collection Views）：Hashtable提供了一个方法keys()用于获取以枚举（Enumeration）形式返回键的集合视图；而HashMap提供了keySet()、values()和entrySet()方法，分别返回键、值和键值对的集合视图。</p></li></ol><p>总的来说，HashMap相对于Hashtable来说更常用，由于它不是线程安全的，它的性能更好。但是，在多线程环境下，如果要保证安全性，可以选择使用ConcurrentHashMap。</p><h4 id="jdk8新特性"><a href="#jdk8新特性" class="headerlink" title="jdk8新特性"></a>jdk8新特性</h4><p>Java 8引入了许多新特性，其中一些最重要和最显著的包括：</p><ol><li><p>Lambda表达式：Lambda表达式允许将函数作为一种方法参数传递，这种特性大大简化了Java中的函数式编程。Lambda表达式的引入使得代码更加简洁和易读。</p></li><li><p>Stream API：Stream API 提供了一种高效的处理集合数据的途径，它支持串行和并行操作。Stream API可以让开发者以一种声明式的方式对集合数据进行操作，例如筛选、映射、过滤、聚合等。</p></li><li><p>新的日期和时间API：Java 8引入了java.time包，提供了新的日期和时间API，其中包括新的日期、时间、时区、持续时间等类，这些类简化了日期和时间的处理。</p></li><li><p>接口的默认方法和静态方法：Java 8允许在接口中包含默认方法和静态方法的实现，这使得接口的演变更加灵活，并且可以向现有的接口中添加新的方法，而不会破坏已有的实现类。</p></li><li><p>类型注解：Java 8引入了新的ElementType.TYPE_USE类型注解，允许开发者在许多表达式中使用注解，这为编写更安全和更精确的代码提供了更大的灵活性。</p></li></ol><p>除了上述特性之外，Java 8还引入了其他一些较小的改进，比如重复注解、Optional类、CompletableFuture类等等。这些新特性使得Java在现代编程环境中更加强大和灵活。</p><h4 id="java中，抽象类和接口的区别？"><a href="#java中，抽象类和接口的区别？" class="headerlink" title="java中，抽象类和接口的区别？"></a>java中，抽象类和接口的区别？</h4><p>抽象类和接口是Java中两种不同的机制，它们有以下区别：</p><ol><li><p>实现方式：抽象类是通过使用关键字abstract来定义的类，它可以包含抽象方法和非抽象方法，可以有成员变量和构造方法；而接口是通过使用关键字interface来定义的，它只包含抽象方法、常量和默认方法，不包含成员变量和构造方法。</p></li><li><p>继承关系：一个类只能继承一个抽象类，而一个类可以实现多个接口。</p></li><li><p>方法实现：抽象类中的抽象方法可以有默认实现，也可以有普通方法的实现；而接口中的抽象方法必须由实现类实现，接口中的方法默认都是public abstract的，而抽象类可以包含任意访问权限的方法。</p></li><li><p>变量：抽象类可以包含成员变量，也可以包含常量；而接口只能包含常量。</p></li><li><p>构造方法：抽象类可以有构造方法，而接口不能包含构造方法。</p></li></ol><p>由于抽象类和接口各有不同的特性，需要根据具体情况来选择使用抽象类还是接口。通常来说，如果需要定义一种类型，但不关心它的具体实现，可以使用接口；如果需要共享代码或者有部分默认实现，可以使用抽象类。在实际项目中，常常将抽象类和接口一起使用，来实现更灵活和功能强大的设计。</p><h4 id="vue中computed和watch的区别"><a href="#vue中computed和watch的区别" class="headerlink" title="vue中computed和watch的区别?"></a>vue中computed和watch的区别?</h4><p>在Vue中，computed和watch都可以用于监听和处理数据的变化，但它们之间有以下区别：</p><p>computed属性：</p><ul><li>用于定义一个根据其他响应式数据计算得出的属性，类似于计算属性。</li><li>computed属性会根据它依赖的响应式数据的变化而自动更新，只有在依赖的数据发生改变时才会重新计算，避免了重复计算。</li><li>计算属性一般用于获取数据的过程中进行一些逻辑操作，例如格式化日期、筛选数组等。</li><li>computed属性是基于缓存的，只要依赖的响应式数据不发生变化，多次访问computed属性会直接返回上一次的计算结果，不会重新计算。</li></ul><p>watch属性：</p><ul><li>用于观察一个响应式数据的变化，并在变化时执行一些异步操作或复杂逻辑。</li><li>watch属性可以监听一个或多个特定属性的变化，当这些属性的值发生变化时，会触发watch回调函数。</li><li>watch属性的回调函数接收两个参数：新值(newVal)和旧值(oldVal)，可以根据新旧值的变化来执行逻辑。</li><li>watch属性适用于需要执行异步操作或复杂计算的情况，例如发送Ajax请求、计算某些数据等。</li></ul><p>综上所述，computed适用于需要根据其他响应式数据进行计算得出结果的场景，而watch适用于需要在数据变化时执行一些副作用操作的场景。在实际使用中，可以根据具体需求选择合适的方式。</p><h4 id="怎样理解vue的单向数据流"><a href="#怎样理解vue的单向数据流" class="headerlink" title="怎样理解vue的单向数据流?"></a>怎样理解vue的单向数据流?</h4><p>Vue 的单向数据流是指数据在应用程序中的流动方向是单向的，即数据从父组件流向子组件，子组件不能直接修改父组件的数据。这一概念有助于代码的可维护性和可预测性，使得应用程序更容易理解和调试。</p><p>具体来说，Vue 的单向数据流表现在以下几个方面：</p><ol><li><p>父组件通过 props 属性向子组件传递数据。子组件接收父组件传递的数据后，可以在子组件内部使用这些数据，但不能直接修改它们。</p></li><li><p>子组件通过触发事件（$emit）的方式向父组件传递消息。当子组件需要修改数据时，它要求父组件执行相应的变更操作，子组件本身不直接修改父组件的数据。</p></li><li><p>Vue 的响应式数据系统负责将数据的变化通知给相关的组件，当数据在父组件中发生变化时，此变化会自动传播到子组件，从而保持了数据流的单向性。</p></li></ol><p>通过遵循单向数据流的原则，我们可以更好地组织组件之间的关系，使得代码更易于维护和调试。同时，这也有助于改善代码的可测试性和可预测性，因为我们可以清晰地知道数据的流动路径，从而更容易定位和解决问题。</p><h4 id="v-if和-v-show的区别是什么"><a href="#v-if和-v-show的区别是什么" class="headerlink" title="v-if和 v-show的区别是什么?"></a>v-if和 v-show的区别是什么?</h4><p>在 Vue.js 中，v-if 和 v-show 是用来控制元素显示和隐藏的指令，它们之间的区别主要体现在以下几个方面：</p><ol><li><p>渲染方式：</p><ul><li>v-if：通过在 DOM 树中添加或移除元素来实现条件渲染。当条件为假时，元素将会被从 DOM 中移除，条件为真时则会被重新添加到 DOM 中。</li><li>v-show：通过 CSS 的 display 属性来控制元素的显示和隐藏。元素会一直保持在 DOM 中，通过修改 display 属性来控制其显示状态。</li></ul></li><li><p>初始渲染开销：</p><ul><li>v-if：在条件为假时，元素在初始渲染时不会被渲染到页面中，只有在条件为真时才会被渲染到页面上。</li><li>v-show：在初始渲染时，元素会被渲染到页面中，只是通过 CSS 的 display 属性来控制其显示状态。</li></ul></li><li><p>变化时开销：</p><ul><li>v-if：当条件从假变为真，或者从真变为假时，元素会被添加或移除，涉及到 DOM 操作和组件的销毁和重新创建，性能开销较大。</li><li>v-show：当条件变化时，只需要修改 CSS 属性，不会涉及到 DOM 操作和组件的销毁和重新创建，性能开销较小。</li></ul></li></ol><p>因此，可以根据实际需求来选择 v-if 和 v-show。如果需要频繁地在条件为真和假之间切换的情况下，使用 v-show 可能更加高效；而如果在条件变化不频繁的情况下，可以选择使用 v-if 来减少页面初始渲染的开销。</p><h4 id="AOP技术常用于哪些地方"><a href="#AOP技术常用于哪些地方" class="headerlink" title="AOP技术常用于哪些地方?"></a>AOP技术常用于哪些地方?</h4><p>AOP（面向切面编程）技术常用于以下几个方面：</p><ol><li><p>日志记录：通过AOP技术，可以在程序的关键流程或方法调用前后插入日志记录的逻辑，实现日志的自动记录和统一管理。</p></li><li><p>安全检查：利用AOP，可以在方法执行前对用户的权限进行检查，确保只有有权限的用户能够访问和执行特定的方法。</p></li><li><p>事务处理：AOP可以很方便地管理事务，通过在方法调用前后进行事务的开启和提交或回滚操作，确保数据的一致性和完整性。</p></li><li><p>性能监控：通过在方法执行前后插入性能监控代码，可以统计方法的执行时间、调用次数等信息，以便进行性能优化和监测系统健康状况。</p></li><li><p>异常处理：利用AOP可以在方法执行时捕获和处理异常，可以对异常进行统一的处理和封装，避免代码中出现大量的try-catch块。</p></li><li><p>缓存管理：通过AOP可以很方便地在方法执行前后进行缓存的设置和清理，提高系统的响应速度和性能。</p></li></ol><p>总之，AOP技术可以在很多地方应用，主要是用于将与核心业务逻辑无关的横切关注点（如日志、安全、事务等）从业务代码中分离出来，提高代码的可维护性、可读性和复用性。</p><h4 id="Spring事务失效的情况有哪些"><a href="#Spring事务失效的情况有哪些" class="headerlink" title="Spring事务失效的情况有哪些?"></a>Spring事务失效的情况有哪些?</h4><p>在使用Spring事务管理时，可能会遇到以下几种情况导致事务失效：</p><ol><li><p>方法未被声明为事务：如果要使用Spring事务管理器来管理方法的事务，需要在方法上添加<code>@Transactional</code>注解或者在XML配置中声明事务。</p></li><li><p>异常被catch并处理：默认情况下，Spring只会在发生未捕获异常时回滚事务，如果方法捕获并处理了异常，事务可能不会回滚。为了确保事务回滚，可以在catch块中重新抛出异常或使用<code>TransactionAspectSupport.currentTransactionStatus().setRollbackOnly()</code>手动标记事务为回滚。</p></li><li><p>非受检异常没有被声明：默认情况下，Spring只会回滚由于抛出的受检异常导致的事务，对于非受检异常（运行时异常）默认不回滚。如果需要对非受检异常也进行回滚，可以通过在<code>@Transactional</code>注解上添加<code>rollbackFor</code>属性明确指定需要回滚的异常类型。</p></li><li><p>多个事务管理器不正确配置：如果在项目中使用了多个事务管理器，需要确保正确配置了<code>@Transactional</code>注解或XML配置中指定了要使用的事务管理器。如果没有指定事务管理器，可能会导致事务失效。</p></li><li><p>事务传播属性错误配置：事务传播属性定义了当一个事务方法调用另一个事务方法时，事务应该如何进行传播和合并。如果事务传播属性配置错误，可能导致事务失效，例如将一个无事务方法调用标记为REQUIRES_NEW，会导致当前事务挂起并始终创建一个新的事务。</p></li><li><p>数据库引擎不支持事务：有些数据库引擎可能不支持事务，或者在特定情况下不支持某些事务特性，这可能导致事务失效。</p></li><li><p>事务隔离级别不正确：在使用Spring事务管理时，需要确保所使用的事务隔离级别与数据库的支持一致，否则可能导致事务失效或产生脏读、幻读等问题。</p></li></ol><p>总之，Spring事务失效可能是由于方法未声明为事务、异常被catch并处理、非受检异常未声明、多个事务管理器配置错误、事务传播属性配置错误、数据库引擎不支持事务或事务隔离级别不正确等原因导致的。在使用Spring事务管理时，需要仔细检查配置和异常处理，确保事务正常生效。</p><h4 id="java中，什么是深拷贝与浅拷贝？"><a href="#java中，什么是深拷贝与浅拷贝？" class="headerlink" title="java中，什么是深拷贝与浅拷贝？"></a>java中，什么是深拷贝与浅拷贝？</h4><p>在Java中，深拷贝和浅拷贝是两种不同的对象复制方式。</p><p>浅拷贝是指只复制对象本身，而不复制对象所引用的其他对象。换句话说，浅拷贝创建一个新对象，但是该对象内部引用的其他对象则与原对象共享。当对其中一个对象的引用对象进行修改时，会影响到另一个对象。</p><p>深拷贝是指复制对象本身以及对象所引用的其他对象，创建一个全新的对象并复制其所有相关对象。这意味着完全独立于原对象，对深拷贝对象的修改不会影响到原对象。</p><p>在Java中，使用<code>clone()</code>方法进行对象复制通常是浅拷贝。如果需要实现深拷贝，可以通过序列化和反序列化、手动复制对象的所有字段等方式来完成。</p><p>总之，深拷贝和浅拷贝是指对象复制的两种不同方式，浅拷贝只复制对象本身，深拷贝则复制对象及其所引用的其他对象。在实现对象复制时，需要根据需求选择合适的方式。</p><h4 id="String-StringBuffer-StringBuilder-区别"><a href="#String-StringBuffer-StringBuilder-区别" class="headerlink" title="String  StringBuffer StringBuilder 区别?"></a>String StringBuffer StringBuilder 区别?</h4><p>在 Java 中，String、StringBuffer 和 StringBuilder 是用于处理字符串的类，它们之间有以下区别：</p><p>String：</p><ul><li>String 类是不可变的，也就是说一旦创建了 String 对象，它的值就不能被改变。</li><li>对 String 对象进行操作（例如连接、替换、修改等）会创建一个新的字符串对象。</li><li>因为 String 是不可变的，所以它适合用于表示那些不会被修改的字符串，例如常量字符串。</li></ul><p>StringBuffer：</p><ul><li>StringBuffer 是可变的字符串序列，它可以修改包含其中的字符。</li><li>在进行字符串操作时，如果需要频繁地进行添加、插入、删除等操作，应该使用 StringBuffer，因为它的性能会比较好。</li><li>StringBuffer 是线程安全的，这意味着多个线程可以同时使用 StringBuffer 对象而不会产生数据不一致的问题。但是由于它是同步的，所以会有一定的性能损耗。</li></ul><p>StringBuilder：</p><ul><li>StringBuilder 也是可变的字符串序列，它与 StringBuffer 类似，但是不是线程安全的。</li><li>如果在单线程环境下，需要频繁进行字符串操作，可以选择使用 StringBuilder，因为它的性能会比 StringBuffer 更好。</li><li>与 StringBuffer 相比，由于 StringBuilder 不是线程安全的，简单的操作不会产生额外的线程同步开销。</li></ul><p>综上所述，String 适用于不需要修改的字符串，StringBuffer 适用于多线程环境下的字符串操作，而 StringBuilder 适用于单线程环境下的字符串操作。根据具体的需求和线程环境，选择合适的类来处理字符串。</p><hr><h2 id="实习面试过程中遇到的面试题"><a href="#实习面试过程中遇到的面试题" class="headerlink" title="实习面试过程中遇到的面试题"></a>实习面试过程中遇到的面试题</h2><h3 id="亚信第一轮线上面试"><a href="#亚信第一轮线上面试" class="headerlink" title="亚信第一轮线上面试"></a>亚信第一轮线上面试</h3><h4 id="1-使用-Redis-解决集群模式下-Session-共享问题是如何实现的？"><a href="#1-使用-Redis-解决集群模式下-Session-共享问题是如何实现的？" class="headerlink" title="1 使用 Redis 解决集群模式下 Session 共享问题是如何实现的？"></a>1 使用 Redis 解决集群模式下 Session 共享问题是如何实现的？</h4><p><strong>session共享问题</strong>：多台Tomcat并不共享session存储空间，当请求切换到不同tomcat服务时导致数据丢失的问题(登录失败，会被拦截)。</p><p>早期的修改方案是session拷贝，就是每当任意一台服务器的session修改后，都会同步到其它tomcat的session，这样的话，就可以实现session的共享了。但是这种解决方案会出现两个大问题（1. 每台服务器中都有完整的一份session数据，服务器压力过大。2. session拷贝数据时，可能会出现延迟，导致登录失败。）</p><p>**使用redis实现session共享redis的数据本身就是共享的，就可以解决session共享的问题了 **</p><p>使用手机号作为key：数据太敏感，这样的数据存储在redis中并且从页面带过来不太合适（类似于jssionId）</p><p>(首次登录请求会将用户存储到redis中,并向前端返回随机token作为key,之后前端的每个请求都会携带此token作为请求头,服务端利用该请求头(即token数据)得到User对象,实现登陆验证。)</p><p><strong>使用UUID生成随机字符串token作为key,存储该手机号对应的用户User信息(hash结构),并且此token作为类似于session中Jsessionid功能的登陆凭证,将此token返回给前端界面.之后登录校验流程类似于使用session:前端界面再进行登录请求时,会携带着此token进行访问,从redis中取出token对应的value,即为用户User信息。</strong></p><p>当注册完成后，用户去登录会去校验用户提交的手机号和验证码，是否一致，如果一致，则根据手机号查询用户信息，不存在则新建，最后将用户数据保存到redis，并且生成token作为redis的key，当校验当前请求的用户是否登录时，当前请求携带着token进行访问，从redis中取出token对应的value，判断是否存在这个数据，如果没有则拦截，如果存在则将其保存到threadLocal中，并且放行。实现redis解决session的共享问题。</p><p><strong>注意：</strong>此时存在的问题是，我们设置了token的有效期是30分钟。也就是说只要将token存储进了redis中，不管用户操作与否，只要30分钟一到，token就会被删除，这显然是不合理的。反观session的存储机制，它的默认效时间也是30分钟，但是只要在这30分钟内，用户进行了相关的访问操作，则这个session的会被继续刷新30分钟。那么，如何改进呢？</p><p><strong>改进：</strong>我们之前设计了一个拦截器，<strong>所有的请求都会被拦截器进行拦截校验</strong>（手动放行的请求除外）。只要经过了拦截器，就说明是登录过的用户，且在活跃状态，在访问应用。所以只要请求通过了拦截器，我们就刷新token的有效期（类似于session的存活机制）。只有用户什么操作都不做，没有请求经过拦截器，超过30分钟后，token才会被移除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);  <span class="comment">// token在请求头中是用authorization表示的</span></span><br><span class="line"><span class="keyword">if</span>(StrUtil.isBlank(token))&#123;</span><br><span class="line">    <span class="comment">// 4.不存在，拦截，返回401状态码</span></span><br><span class="line">    response.setStatus(<span class="number">401</span>);</span><br><span class="line">    <span class="comment">// 返回 false，则后续的请求处理流程将被中断，即请求被拦截</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.获取session中的用户 --&gt; 基于token获取redis中的用户</span></span><br><span class="line"><span class="comment">// Object user = session.getAttribute(&quot;user&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> LOGIN_USER_KEY + token;</span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line"><span class="comment">// 7.刷新token有效期</span></span><br><span class="line">stringRedisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line"><span class="comment">// 8.放行</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;这里引入一个新的问题，token是直接保存在redis内存中的吗？&#x3D;&#x3D;</p><p>回答：是，但是设置了有效期为30分钟，过期自动删除。在登录时定义了一个拦截器，所有请求都会被拦截（手动放行的除外），所以只要请求通过了拦截器，我们就刷新token的有效期为30分钟（类似于session的存活机制）。</p><p>&#x3D;&#x3D;新问题：&#x3D;&#x3D;</p><p>在这个方案中，他确实可以使用对应路径的拦截，同时刷新登录token令牌的存活时间，但是现在这个拦截器他只是拦截需要被拦截的路径，假设当前用户访问了一些不需要拦截的路径，那么这个拦截器就不会生效，所以此时令牌刷新的动作实际上就不会执行，所以这个方案他是存在问题的。</p><p>既然之前的拦截器无法对不需要拦截的路径生效，那么我们可以添加一个拦截器，在第一个拦截器中拦截所有的路径，把第二个拦截器做的事情放入到第一个拦截器中，同时刷新令牌，因为第一个拦截器有了threadLocal的数据，所以此时第二个拦截器只需要判断拦截器中的user对象是否存在即可，完成整体刷新功能。</p><p><img src="/breeze/2a548e97/image-20230904170426459.png" alt="image-20230904170426459"></p><h4 id="2-缓存空对象解决缓存穿透是如何实现的？（如何解决缓存穿透问题）"><a href="#2-缓存空对象解决缓存穿透是如何实现的？（如何解决缓存穿透问题）" class="headerlink" title="2 缓存空对象解决缓存穿透是如何实现的？（如何解决缓存穿透问题）"></a>2 缓存空对象解决缓存穿透是如何实现的？（如何解决缓存穿透问题）</h4><ul><li><p>缓存空对象并设置过期时间</p></li><li><p>使用布隆过滤</p><ul><li><p><strong>布隆过滤：</strong>布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，</p><p>假设布隆过滤器判断这个数据不存在，则直接返回</p><p>这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突</p></li></ul></li></ul><h4 id="3-如何向redis写入缓存？（如何确保数据库和redis的双写一致性？）"><a href="#3-如何向redis写入缓存？（如何确保数据库和redis的双写一致性？）" class="headerlink" title="3 如何向redis写入缓存？（如何确保数据库和redis的双写一致性？）"></a>3 如何向redis写入缓存？（如何确保数据库和redis的双写一致性？）</h4><ol><li><p>从数据库定时写入</p></li><li><p><strong>异步更新缓存(基于订阅binlog的同步机制)</strong></p><p><strong>1.技术整体思路：</strong></p><p>MySQL binlog增量订阅消费+消息队列+增量数据更新到redis</p><ul><li><strong>读Redis</strong>：热数据基本都在Redis</li><li><strong>写MySQL</strong>:增删改都是操作MySQL</li><li><strong>更新Redis数据</strong>：MySQ的数据操作binlog，来更新到Redis</li></ul><p><strong>2.Redis更新</strong></p><p><strong>(1）数据操作主要分为两大块：</strong></p><ul><li>一个是全量(将全部数据一次写入到redis)</li><li>一个是增量（实时更新）</li></ul><p>这里说的是增量,指的是mysql的update、insert、delate变更数据。</p><p><strong>(2）读取binlog后分析 ，利用消息队列,推送更新各台的redis缓存数据。</strong></p><p>这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。</p><p>其实这种机制，很类似MySQL的主从备份机制，因为MySQL的主备也是通过binlog来实现的数据一致性。</p><p>这里可以结合使用canal(阿里的一款开源框架)，通过该框架可以对MySQL的binlog进行订阅，而canal正是模仿了mysql的slave数据库的备份请求，使得Redis的数据更新达到了相同的效果。</p><p>当然，这里的消息推送工具你也可以采用别的第三方：kafka、rabbitMQ等来实现推送更新Redis!</p><p>&#x3D;&#x3D;而Canal就是把自己伪装成MySQL的一个slave节点，从而监听master的binary log变化。再把得到的变化信息通知给Canal的客户端，进而完成对其它数据库的同步。&#x3D;&#x3D;</p></li><li><p>通过消息队列的方式进行异步更新，会有一定的延时，但可以达到最终一致性</p></li></ol><p><strong>拓展：mysql主从复制原理</strong></p><ul><li>1）MySQL master 将数据变更写入二进制日志( binary log），其中记录的数据叫做binary log events</li><li>2）MySQL slave 将 master 的 binary log events拷贝到它的中继日志(relay log)</li><li>3）MySQL slave 重放 relay log 中事件，将数据变更反映它自己的数据</li></ul><h4 id="4-基于-Lua-脚本实现用户秒杀资格验证，解决超卖和一人一单问题，lua脚本是怎样写的？是怎样实现的？"><a href="#4-基于-Lua-脚本实现用户秒杀资格验证，解决超卖和一人一单问题，lua脚本是怎样写的？是怎样实现的？" class="headerlink" title="4 基于 Lua 脚本实现用户秒杀资格验证，解决超卖和一人一单问题，lua脚本是怎样写的？是怎样实现的？"></a>4 基于 Lua 脚本实现用户秒杀资格验证，解决超卖和一人一单问题，lua脚本是怎样写的？是怎样实现的？</h4><p>加锁：涉及到悲观锁和乐观锁</p><p>加悲观锁，让线程串行执行（简单粗暴，性能一般）</p><p>超卖问题时使用乐观锁解决的（版本号机制），只要版本号大于0就对版本号进行操作即可。如果非要修改前后保持一致，比如：version&#x3D;1才能进行操作的话，会有成功率低的问题。（性能好，存在成功率低的问题）</p><p>更建议使用乐观锁&#x3D;&#x3D;乐观锁比较适合更新数据，但是插入数据，需要使用悲观锁操作&#x3D;&#x3D;</p><p>**一人一单:**同一个用户发起多个线程抢夺优惠卷，在多线程并发的情况下可能会导致线程安全问题，导致同一个用户抢夺多个优惠卷。可以通过加锁让线程串行执行来解决这个问题，通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了，因为锁是在一个jvm中有效。</p><p>分布式锁：通过redis的setnx命令获取锁，获取锁的线程执行程序。</p><p>分布式锁需要满足的要求：</p><ul><li>高可用：程序不易崩溃，时时刻刻保持较高的可用性</li><li>多进程可见：多个进程都能看到相同的结果</li><li>互斥：互斥时分布式锁的最基本条件，使得程序串行执行</li><li>高性能：加锁和释放锁本身就会影响新能，所以分布式锁需要具有较高的性能</li><li>安全性</li></ul><p>释放锁：手动释放和超时释放</p><ul><li><p>存在的问题：多线程并发的情况下，线程一获取了锁然后因为某种原因被阻塞了，然后锁的超时时间，锁自动释放了；此时线程二抢到了锁，开始执行业务逻辑，但是线程一反应过来了，继续执行业务，走到了删除锁的逻辑，然后就把线程二的锁删除了。（所以这种方式会存在锁的误删问题）</p></li><li><p>解决方案：删除锁的时候判断锁是否属于当前线程，若不是，则不进行锁的删除。假设还是上面的逻辑，线程一卡顿，锁自动释放，线程2进入锁的内部执行逻辑，此时线程一反应过来然后删除锁，但是线程1，一看当前这把锁不是属于自己，于是不进行锁的删除逻辑，当线程2走到删除锁的逻辑时，如果锁没有到自动释放锁的时间点，判断当前锁是否属于自己，是，则删除。</p></li><li><p>实现：在获取分布式锁的时候存入线程标识（可以用uuid来表示），在释放锁时先获取锁中的线程标识，判断锁是否与当前线程标识</p></li><li><p><strong>具体代码如下（都在SimpleRedisLock类中）：</strong>加锁</p><ul><li><pre><code class="java">// 给threadId加一个前缀，减少不同jvm中的线程id相同的情况
private static final String ID_PREFIX = UUID.randomUUID().toString(true) + &quot;-&quot;;
@Override
public boolean tryLock(long timeoutSec) &#123;
   // 获取线程标示
   String threadId = ID_PREFIX + Thread.currentThread().getId();
   // 获取锁
   Boolean success = stringRedisTemplate.opsForValue()
                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);
   return Boolean.TRUE.equals(success);
&#125;
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 释放锁</span><br><span class="line"></span><br><span class="line">  - ```<span class="function">java</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span>()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取线程标示</span></span><br><span class="line">        String threadId = ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">        <span class="comment">// 获取锁中的标示</span></span><br><span class="line">        String id = stringRedisTemplate.opsForValue().<span class="keyword">get</span>(KEY_PREFIX + name);</span><br><span class="line">        <span class="comment">// 判断标示是否一致</span></span><br><span class="line">        <span class="keyword">if</span>(threadId.<span class="keyword">equals</span>(id)) &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre></li></ul></li><li><p><strong>更为极端的误删逻辑说明：</strong></p></li><li><p>线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了，那么此时线程2进来，但是线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的原子性问题，之所以有这个问题，是因为线程1的拿锁，比锁，删锁，实际上并不是原子性的，我们要防止刚才的情况发生，</p></li><li><p>&#x3D;&#x3D;使用lua脚本解决多条命令原子性的问题&#x3D;&#x3D;、</p></li></ul><p>基于setnx实现的分布式锁存在下面的问题：</p><p><strong>重入问题</strong>：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</p><p><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p><p><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</p><p><strong>主从一致性：</strong> 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p><ul><li><p><strong>对RabbitMQ了解吗？如果因为某种原因造成消息堆积，该怎么处理?(不要只想着增加消费者，加机器得加钱啊)</strong></p><p>RabbitMQ 是一个开源的消息中间件（Message Broker），用于在分布式系统中进行消息传递和异步通信。它实现了高效可靠的消息队列模型，提供了基于 AMQP（Advanced Message Queuing Protocol）的消息传递机制。</p><p>消息中间件是一种软件应用或服务，它充当消息的中转站，使得不同的应用程序和组件能够通过异步消息传递来进行通信。RabbitMQ 提供了一个可靠的消息传递解决方案，其中包括生产者（Producer）将消息发送到消息队列（Queue），然后消费者（Consumer）从队列中接收和处理消息。</p><p>RabbitMQ 的主要特点包括：</p><ol><li>灵活的消息路由：RabbitMQ 支持灵活的消息路由机制，可以根据消息的属性、内容以及目标队列进行路由和过滤。</li><li>消息持久化：RabbitMQ 可以将消息持久化到磁盘，即使在发生故障或重启之后，消息也不会丢失。</li><li>高可用性和可伸缩性：RabbitMQ 支持集群和镜像队列，可以实现高可用性和更好的可伸缩性，确保消息传递的可靠性和性能。</li><li>多种通信模式：RabbitMQ 支持多种通信模式，包括点对点、发布&#x2F;订阅、RPC（远程过程调用）等，可以满足不同的应用场景需求。</li><li>插件机制：RabbitMQ 提供了丰富的插件机制，可以轻松地扩展和定制功能，例如支持不同的消息协议、身份验证、监控和管理等。</li></ol><p>由于其可靠性、灵活性和性能等特点，RabbitMQ 在分布式系统、微服务架构以及异步通信场景中被广泛应用。它为应用程序提供了可靠的消息传递机制，并实现了解耦、增强容错性和可伸缩性的优势。</p></li></ul><p><strong>RabbitMQ中，如果因为某种原因造成消息堆积，该怎么处理?(不要只想着增加消费者，加机器得加钱啊)</strong></p><p>当消息堆积发生时，可以采取以下几种方式来处理：</p><ol><li>&#x3D;&#x3D;增加消费者数量&#x3D;&#x3D;：增加消费者的数量可以提高消息的处理速度，减少消息堆积。可以动态地扩展消费者，以应对消息处理压力。</li><li>调整消费者的处理能力：优化消费者的处理能力，例如通过&#x3D;&#x3D;增加线程数&#x3D;&#x3D;、调整消费者的资源配置等来提高消费者的并发处理能力。</li><li>增加 RabbitMQ 节点或分片：当 RabbitMQ 是以集群方式运行时，可以增加节点或者进行分片设置。这样可以将负载分散到多个节点上，提高消息处理的吞吐量和并发性能。（带有负载均衡的集群（Load-Balancing Cluster）：带有负载均衡的集群通过在前端添加负载均衡器来实现消息的负载均衡。负载均衡器将消息发送到不同的 RabbitMQ 节点，以平衡集群中各节点的负载。这样可以提高整个集群的性能和扩展性。）</li><li>&#x3D;&#x3D;设置消息过期时间&#x3D;&#x3D;：如果消息堆积是因为消息长时间未被消费导致的，可以在发送消息时设置消息的过期时间。超过一定时间后，未被消费的消息会自动从队列中删除，避免不必要的堆积。</li><li>&#x3D;&#x3D;使用死信队列（Dead Letter Queue）&#x3D;&#x3D;：将未能成功处理的消息转移到一个专门的死信队列中，再进行处理或者延迟重试。这可以帮助将异常或无法处理的消息从主队列中剥离出来，防止消息堆积影响正常的消息流转。</li><li>&#x3D;&#x3D;增大队列容量&#x3D;&#x3D;：增大队列的容量可以在一定程度上缓解消息堆积。当消息堆积时，可以考虑增加队列的最大长度或者容量。</li><li>监控和报警：设置合适的监控和报警机制，及时发现消息堆积情况，并采取相应的处理措施。</li></ol><p>需要根据具体的业务场景和系统架构选择适合的处理方法。同时，还要注意及时分析消息堆积的原因，并针对性地解决问题，以避免持续的消息堆积。</p><ul><li><p>基于 List 实现点赞列表，SortedSet 实现点赞排行榜是如何实现的？</p><ul><li><p><strong>list实现点赞列表</strong>（其实用set更好，set可以保证唯一性）</p></li><li><p>当用户点击某个博客的点赞按钮时，（会根据博客的id进行业务处理）根据当前登录用户的id去redis中实现点赞列表的list集合中判断是否有当前用户的信息，若有，则说明已经点赞过了，则取消点赞，数据库点赞数-1，把用户从redis的list集合中移除；如果没有当前用户信息，则说明之前没有点赞，则数据库点赞数+1（数据库中以博客id为主键），保存用户数到redis的list集合中。</p></li><li><p>SortedSet实现点赞排行榜</p><p>&#x3D;&#x3D;其实使用上面的list依旧可以实现点赞排行榜的功能，因为list本身就是有序的&#x3D;&#x3D;</p><p>&#x3D;&#x3D;这里使用SortedSet实现点赞排行榜，可以说是使用了第二种方法来实现点赞排行榜&#x3D;&#x3D;</p><p>Redis 的 Sorted Set（有序集合）是一种键值对的数据结构，它包含一个有序的成员（member）集合，每个成员关联着一个分数（score），Sorted Set 中的成员按分数从小到大排序。</p><p>由于页面不可能展示所有点赞过的用户，所以只取前五位进行展示。查询top5的点赞用户 zrange key 0 4</p><p>如果是用的list lrange key 0 4</p></li></ul></li></ul><h4 id="5-JVM-的内存结构？"><a href="#5-JVM-的内存结构？" class="headerlink" title="5 JVM 的内存结构？"></a>5 JVM 的内存结构？</h4><ul><li><p>JVM（Java Virtual Machine）的内存结构主要分为以下几个部分：</p><ol><li>程序计数器（Program Counter Register）：程序计数器是一块较小的内存区域，它用于记录当前线程执行的字节码指令的地址。在多线程环境下，每个线程都有自己独立的程序计数器，用于控制线程的执行流程。</li><li>Java 虚拟机栈（Java Virtual Machine Stacks）：每个线程在运行时都会创建一个虚拟机栈，用于存储方法调用的局部变量、操作数栈、动态链接、方法出口等信息。虚拟机栈通过栈帧（Stack Frame）来表示方法的调用和返回。</li><li>本地方法栈（Native Method Stack）：与虚拟机栈类似，本地方法栈用于支持 Java 程序调用本地（非 Java）方法。它也是线程私有的，每个线程都有一个对应的本地方法栈。</li><li>堆（Heap）：堆是 JVM 中最大的一块内存区域，被所有线程共享。它用于存储 Java 对象实例。堆空间被划分为新生代（Young Generation）、老年代（Old Generation）和永久代（Permanent Generation，或者在 JDK 8 及以后版本中被 Metaspace 取代）。<ul><li>新生代（Young Generation）：新创建的对象首先被分配到新生代中，新生代又分为 Eden 区和两个 Survivor 区（通常是 From 区和 To 区）。大部分对象在短时间内就会被回收，只有少部分对象会进入老年代。</li><li>老年代（Old Generation）：当对象经过多次垃圾回收仍然存活时，它们会被移到老年代。老年代一般存放较长时间存活的对象。</li><li>永久代（PermGen 或 Metaspace）：永久代在旧版本的 JVM 中用于存储类的元数据（如类信息、方法信息等）和常量池等信息。从 JDK 8 开始，永久代被 Metaspace 取代，Metaspace 使用本地内存来存储类和方法元数据，不再受固定大小的限制。</li></ul></li><li>方法区（Method Area）：方法区也被称为非堆（Non-Heap），它用于存储类的元数据、静态变量、常量等。方法区在逻辑上属于堆的一部分，但在物理上与堆分开，有独立的分配和回收机制。</li><li>直接内存（Direct Memory）：直接内存并不是 JVM 运行时数据区的一部分，它是使用 NIO 时可选使用的一种内存分配方式。直接内存并不和 JVM 堆关联，而是由操作系统管理的，通过 Java 的 Native 方法进行访问。</li></ol><p>需要注意的是，具体 JVM 内存结构的实现可能因不同的 JVM 实现厂商和版本而有所差异。上述的内存结构是一般情况下的常见 JVM 内存布局。</p></li></ul><h4 id="6-jvm什么时候下会触发full-GC"><a href="#6-jvm什么时候下会触发full-GC" class="headerlink" title="6 jvm什么时候下会触发full GC?"></a>6 jvm什么时候下会触发full GC?</h4><ul><li><p>JVM（Java Virtual Machine）会在以下几种情况下触发 Full GC（Full Garbage Collection，全局垃圾回收）：</p><ol><li>当老年代（Old Generation）空间不足时：当老年代空间中的对象数量达到一定阈值，无法再分配更多的对象时，就会触发 Full GC 来进行老年代的垃圾回收。</li><li>永久代（PermGen 或 Metaspace）空间不足：在旧版本的 JVM 中，永久代用于存储类的元数据和常量池等信息。如果永久代空间不足，例如加载了大量的类或者创建了大量的字符串常量等，JVM 会触发 Full GC 来进行永久代的垃圾回收。在 JDK 8 及以后的版本，永久代被 Metaspace 取代，因此 Full GC 不再针对永久代，而是针对 Metaspace 的垃圾回收。</li><li>显式调用 System.gc() 方法：虽然使用 System.gc() 方法只是建议 JVM 进行垃圾回收，但在某些情况下，JVM 可能会响应这个请求并执行 Full GC。</li><li>CMS 老年代并发失败：在使用并发标记清除（Concurrent Mark Sweep，CMS）作为老年代的垃圾回收算法时，如果 CMS 因为内存碎片或其他原因无法为新的对象分配空间，就会触发 Full GC。</li><li>分配担保失败：在进行 Minor GC 时，如果老年代的剩余空间不足以容纳新生代中的所有存活对象，且启用了分配担保策略（Allocation Failure Promotion），JVM 可能会选择进行 Full GC，以清理整个堆空间。</li></ol><p>需要注意的是，Full GC 是一种较为耗时的操作，通常会产生较长的停顿时间（Stop-The-World）。因此，在系统设计和调优时，应尽量减少 Full GC 的频率和停顿时间，避免影响系统的性能和响应时间。</p></li></ul><h4 id="7-如何使用redis模拟消息队列？"><a href="#7-如何使用redis模拟消息队列？" class="headerlink" title="7 如何使用redis模拟消息队列？"></a>7 如何使用redis模拟消息队列？</h4><ul><li>Redis的list结构是一个双向队列，可以模拟队列的效果。队列的出口和入口不再一边，所以可以使用LPUSH结合RPOP或者是RPOP结合LPUSH来实现。</li><li>需要注意的是，当队列中没有消失的时候，LPOP或者RPOP会返回null，并不会向jvm阻塞队列那样来阻塞并等待消息。因此应该使用BRPOP或者BLPOP来实现阻塞效果。</li><li>基于List的消息队列有哪些优缺点？<ul><li>优点：<ul><li>利用Redis存储，不受限于JVM内存上线</li><li>基于Redis的持久化机制，数据安全性有保证</li><li>可以满足消息有序性</li></ul></li><li>缺点:<ul><li>无法避免消失丢失</li><li>只支持单消费者</li></ul></li></ul></li></ul><h4 id="8-sql优化的步骤（重难点）"><a href="#8-sql优化的步骤（重难点）" class="headerlink" title="8 sql优化的步骤（重难点）"></a>8 sql优化的步骤（重难点）</h4><p>SQL 优化是提高数据库查询性能的关键过程。下面是一般情况下进行 SQL 优化的步骤：</p><ol><li>分析现有 SQL：首先，分析当前的 SQL 查询语句，了解其结构、逻辑和执行计划。可以使用数据库提供的查询分析工具或者 Explain Plan 来获取执行计划。</li><li>确定性能问题：识别 SQL 查询存在的性能问题，如查询慢、资源占用过多等。分析可能导致性能问题的原因，如数据量过大、索引缺失、不合适的连接方式等。</li><li>优化查询逻辑：检查 SQL 查询的逻辑，确保它是最简洁且可理解的。消除冗余的子查询、联合查询和不必要的连接操作等，简化查询语句以提高性能。</li><li>索引优化：根据查询条件和数据访问模式，确定是否需要创建适当的索引，以加速查询的执行。注意选择合适的索引类型、列顺序和索引覆盖等。</li><li>数据库统计信息更新：确保数据库的统计信息是最新的，这样优化器能够做出准确的执行计划选择。可以使用数据库提供的收集统计信息的工具或命令来更新统计信息。</li><li>重构查询语句：通过改变查询语句的写法和结构，可以优化查询性能。例如，使用 EXISTS 替代 IN 子查询、使用 JOIN 替代子查询等。</li><li>限制查询结果集：如果查询结果集很大，但实际上只需要部分数据，可以考虑添加适当的条件或使用分页技术来限制返回的结果集大小。</li><li>避免过度连接：减少不必要的表连接操作，尽量降低连接的复杂度和层级。确保连接字段上存在合适的索引以提高连接操作的性能。</li><li>缓存重复查询结果：对于频繁执行的查询，可以考虑将结果缓存起来，避免重复执行相同的查询操作。</li><li>监控和测试：对优化后的 SQL 查询进行监控和测试，评估其性能和效果。根据测试结果进行进一步调整和优化。</li></ol><p>需要注意的是，SQL 优化是一个迭代的过程，可能需要多次尝试和调整才能达到最佳性能。此外，具体的优化方法和技术取决于数据库的类型、版本和实际场景的要求。</p><p>对于MySQL层优化我一般遵从五个原则：</p><ol><li>减少数据访问： 设置合理的字段类型，启用压缩，通过索引访问等减少磁盘IO</li><li>返回更少的数据： 只返回需要的字段和数据分页处理 减少磁盘io及网络io</li><li>减少交互次数： 批量DML操作，函数存储等减少数据连接次数</li><li>减少服务器CPU开销： 尽量减少数据库排序操作以及全表查询，减少cpu 内存占用</li><li>利用更多资源： 使用表分区，可以增加并行操作，更大限度利用cpu资源</li></ol><p>总结到SQL优化中，就三点:</p><ul><li>最大化利用索引；</li><li>尽可能避免全表扫描；</li><li>减少无效数据的查询；</li></ul><p>理解SQL优化原理 ，首先要搞清楚SQL执行顺序：</p><h5 id="SELECT语句-语法顺序："><a href="#SELECT语句-语法顺序：" class="headerlink" title="SELECT语句 - 语法顺序："></a>SELECT语句 - 语法顺序：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> SELECT </span><br><span class="line"><span class="number">2.</span> DISTINCT &lt;select_list&gt;</span><br><span class="line"><span class="number">3.</span> FROM &lt;left_table&gt;</span><br><span class="line"><span class="number">4.</span> &lt;join_type&gt; JOIN &lt;right_table&gt;</span><br><span class="line"><span class="number">5.</span> ON &lt;join_condition&gt;</span><br><span class="line"><span class="number">6.</span> WHERE &lt;where_condition&gt;</span><br><span class="line"><span class="number">7.</span> GROUP BY &lt;group_by_list&gt;</span><br><span class="line"><span class="number">8.</span> HAVING &lt;having_condition&gt;</span><br><span class="line"><span class="number">9.</span> ORDER BY &lt;order_by_condition&gt;</span><br><span class="line"><span class="number">10.</span>LIMIT &lt;limit_number&gt;</span><br></pre></td></tr></table></figure><h5 id="SELECT语句-执行顺序："><a href="#SELECT语句-执行顺序：" class="headerlink" title="SELECT语句 - 执行顺序："></a>SELECT语句 - 执行顺序：</h5><blockquote><p><strong>FROM</strong><br>&lt;表名&gt; # 选取表，将多个表数据通过笛卡尔积变成一个表。<br><strong>ON</strong><br>&lt;筛选条件&gt; # 对笛卡尔积的虚表进行筛选<br><strong>JOIN</strong>&lt;join, left join, right join…&gt;<br>&lt;join表&gt; # 指定join，用于添加数据到on之后的虚表中，例如left join会将左表的剩余数据添加到虚表中<br><strong>WHERE</strong><br>&lt;where条件&gt; # 对上述虚表进行筛选<br><strong>GROUP BY</strong><br>&lt;分组条件&gt; # 分组<br>&lt;SUM()等聚合函数&gt; # 用于having子句进行判断，在书写上这类聚合函数是写在having判断里面的<br><strong>HAVING</strong><br>&lt;分组筛选&gt; # 对分组后的结果进行聚合筛选<br><strong>SELECT</strong><br>&lt;返回数据列表&gt; # 返回的单列必须在group by子句中，聚合函数除外<br><strong>DISTINCT</strong><br># 数据除重<br><strong>ORDER BY</strong><br>&lt;排序条件&gt; # 排序<br><strong>LIMIT</strong><br>&lt;行数限制&gt;</p></blockquote><h4 id="9-SQL优化策略"><a href="#9-SQL优化策略" class="headerlink" title="9 SQL优化策略"></a>9 SQL优化策略</h4><blockquote><p>声明：以下SQL优化策略适用于数据量较大的场景下，如果数据量较小，没必要以此为准，以免画蛇添足。</p></blockquote><h5 id="一、避免不走索引的场景"><a href="#一、避免不走索引的场景" class="headerlink" title="一、避免不走索引的场景"></a>一、避免不走索引的场景</h5><p><strong>1. 尽量避免在字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫描。</strong>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t WHERE username LIKE <span class="string">&#x27;%陈%&#x27;</span></span><br></pre></td></tr></table></figure><p>优化方式：尽量在字段后面使用模糊查询。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t WHERE username LIKE <span class="string">&#x27;陈%&#x27;</span></span><br></pre></td></tr></table></figure><p>如果需求是要在前面使用模糊查询，</p><ul><li>使用MySQL内置函数INSTR(str,substr) 来匹配，作用类似于java中的indexOf()，查询字符串出现的角标位置</li><li>使用FullText全文索引，用match against 检索</li><li>数据量较大的情况，建议引用ElasticSearch、solr，亿级数据量检索速度秒级</li><li>当表数据量较少（几千条儿那种），别整花里胡哨的，直接用like ‘%xx%’。</li></ul><h5 id="2-尽量避免使用in-和not-in，会导致引擎走全表扫描。如下："><a href="#2-尽量避免使用in-和not-in，会导致引擎走全表扫描。如下：" class="headerlink" title="2. 尽量避免使用in 和not in，会导致引擎走全表扫描。如下："></a><strong>2. 尽量避免使用in 和not in，会导致引擎走全表扫描。</strong>如下：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t WHERE id <span class="title function_">IN</span> <span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span></span><br></pre></td></tr></table></figure><p>优化方式：如果是连续数值，可以用between代替。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">优化方式：如果是连续数值，可以用between代替。如下：</span><br></pre></td></tr></table></figure><p>如果是子查询，可以用exists代替。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 不走索引</span><br><span class="line">select * from A where A.id <span class="title function_">in</span> <span class="params">(select id from B)</span>;</span><br><span class="line">-- 走索引</span><br><span class="line">select * from A where <span class="title function_">exists</span> <span class="params">(select * from B where B.id = A.id)</span>;</span><br></pre></td></tr></table></figure><h5 id="3-尽量避免使用-or，会导致数据库引擎放弃索引进行全表扫描。如下："><a href="#3-尽量避免使用-or，会导致数据库引擎放弃索引进行全表扫描。如下：" class="headerlink" title="3. 尽量避免使用 or，会导致数据库引擎放弃索引进行全表扫描。如下："></a><strong>3. 尽量避免使用 or，会导致数据库引擎放弃索引进行全表扫描。</strong>如下：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM <span class="type">t</span> <span class="variable">WHEREid</span> <span class="operator">=</span> 1ORid = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>优化方式：可以用union代替or。如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t <span class="type">WHERE</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">   UNION</span><br><span class="line">SELECT * FROM t <span class="type">WHERE</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>4. 尽量避免进行null值的判断，会导致数据库引擎放弃索引进行全表扫描。</strong>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t WHERE score IS NULL</span><br></pre></td></tr></table></figure><p>优化方式：可以给字段添加默认值0，对0值进行判断。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t <span class="type">WHERE</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h5 id="5-尽量避免在where条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描。"><a href="#5-尽量避免在where条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描。" class="headerlink" title="5.尽量避免在where条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描。"></a><strong>5.尽量避免在where条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描。</strong></h5><p>可以将表达式、函数操作移动到等号右侧。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 全表扫描</span><br><span class="line">SELECT * FROM T WHERE score/<span class="number">10</span> = <span class="number">9</span></span><br><span class="line">-- 走索引</span><br><span class="line">SELECT * FROM T <span class="type">WHERE</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">10</span>*<span class="number">9</span></span><br></pre></td></tr></table></figure><h5 id="6-当数据量大时，避免使用where-1-1的条件。通常为了方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引进行全表扫描。如下："><a href="#6-当数据量大时，避免使用where-1-1的条件。通常为了方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引进行全表扫描。如下：" class="headerlink" title="6. 当数据量大时，避免使用where 1&#x3D;1的条件。通常为了方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引进行全表扫描。如下："></a><strong>6. 当数据量大时，避免使用where 1&#x3D;1的条件。通常为了方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引进行全表扫描。</strong>如下：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT username, age, sex FROM T WHERE <span class="number">1</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>优化方式：用代码拼装sql时进行判断，没 where 条件就去掉 where，有where条件就加 and。</p><h5><a href="#" class="headerlink"></a></h5><p><strong>7. 查询条件不能用 &lt;&gt; 或者 !&#x3D;</strong></p><p>使用索引列作为条件进行查询时，需要避免使用&lt;&gt;或者!&#x3D;等判断条件。如确实业务需要，使用到不等于符号，需要在重新评估索引建立，避免在此字段上建立索引，改由查询条件中其他索引字段代替。</p><h5 id="8-where条件仅包含复合索引非前置列"><a href="#8-where条件仅包含复合索引非前置列" class="headerlink" title="8. where条件仅包含复合索引非前置列"></a><strong>8. where条件仅包含复合索引非前置列</strong></h5><p>如下：复合（联合）索引包含key_part1，key_part2，key_part3三列，但SQL语句没有包含索引前置列”key_part1”，按照MySQL联合索引的最左匹配原则，不会走联合索引。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select col1 from table where key_part2=<span class="number">1</span> and key_part3=<span class="number">2</span></span><br></pre></td></tr></table></figure><h5 id="-1"><a href="#-1" class="headerlink"></a></h5><h5 id="9-隐式类型转换造成不使用索引"><a href="#9-隐式类型转换造成不使用索引" class="headerlink" title="9. 隐式类型转换造成不使用索引"></a><strong>9. 隐式类型转换造成不使用索引</strong></h5><p>如下SQL语句由于索引对列类型为varchar，但给定的值为数值，涉及隐式类型转换，造成不能正确走索引。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select col1 from table where col_varchar=<span class="number">123</span>; </span><br></pre></td></tr></table></figure><h5 id="-2"><a href="#-2" class="headerlink"></a></h5><h5 id="10-order-by-条件要与where中条件一致，否则order-by不会利用索引进行排序"><a href="#10-order-by-条件要与where中条件一致，否则order-by不会利用索引进行排序" class="headerlink" title="10. order by 条件要与where中条件一致，否则order by不会利用索引进行排序"></a><strong>10. order by 条件要与where中条件一致，否则order by不会利用索引进行排序</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 不走age索引</span><br><span class="line">SELECT * FROM t order by age;</span><br><span class="line"></span><br><span class="line">-- 走age索引</span><br><span class="line">SELECT * FROM t where age &gt; <span class="number">0</span> order by age;</span><br></pre></td></tr></table></figure><p>对于上面的语句，数据库的处理顺序是：</p><ul><li>第一步：根据where条件和统计信息生成执行计划，得到数据。</li><li>第二步：将得到的数据排序。当执行处理数据（order by）时，数据库会先查看第一步的执行计划，看order by 的字段是否在执行计划中利用了索引。如果是，则可以利用索引顺序而直接取得已经排好序的数据。如果不是，则重新进行排序操作。</li><li>第三步：返回排序后的数据。</li></ul><p>当order by 中的字段出现在where条件中时，才会利用索引而不再二次排序，更准确的说，order by 中的字段在执行计划中利用了索引时，不用排序操作。</p><p>这个结论不仅对order by有效，对其他需要排序的操作也有效。比如group by 、union 、distinct等。</p><h5 id="11-正确使用hint优化语句"><a href="#11-正确使用hint优化语句" class="headerlink" title="11. 正确使用hint优化语句"></a><strong>11. 正确使用hint优化语句</strong></h5><p>MySQL中可以使用hint指定优化器在执行时选择或忽略特定的索引。一般而言，处于版本变更带来的表结构索引变化，更建议避免使用hint，而是通过Analyze table多收集统计信息。但在特定场合下，指定hint可以排除其他索引干扰而指定更优的执行计划。</p><ol><li>USE INDEX 在你查询语句中表名的后面，添加 USE INDEX 来提供希望 MySQL 去参考的索引列表，就可以让 MySQL 不再考虑其他可用的索引。例子: SELECT col1 FROM table USE INDEX (mod_time, name)…</li><li>IGNORE INDEX 如果只是单纯的想让 MySQL 忽略一个或者多个索引，可以使用 IGNORE INDEX 作为 Hint。例子: SELECT col1 FROM table IGNORE INDEX (priority) …</li><li>FORCE INDEX 为强制 MySQL 使用一个特定的索引，可在查询中使用FORCE INDEX 作为Hint。例子: SELECT col1 FROM table FORCE INDEX (mod_time) …</li></ol><p>在查询的时候，数据库系统会自动分析查询语句，并选择一个最合适的索引。但是很多时候，数据库系统的查询优化器并不一定总是能使用最优索引。如果我们知道如何选择索引，可以使用FORCE INDEX强制查询使用指定的索引。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM students FORCE <span class="title function_">INDEX</span> <span class="params">(idx_class_id)</span> <span class="type">WHERE</span> <span class="variable">class_id</span> <span class="operator">=</span> <span class="number">1</span> ORDER BY id DESC;</span><br></pre></td></tr></table></figure><h5 id="二、SELECT语句其他优化"><a href="#二、SELECT语句其他优化" class="headerlink" title="二、SELECT语句其他优化"></a>二、SELECT语句其他优化</h5><p><strong>1. 避免出现select *</strong></p><p>首先，select * 操作在任何类型数据库中都不是一个好的SQL编写习惯。</p><p>使用select * 取出全部列，会让优化器无法完成索引覆盖扫描这类优化，会影响优化器对执行计划的选择，也会增加网络带宽消耗，更会带来额外的I&#x2F;O,内存和CPU消耗。</p><p>建议提出业务实际需要的列数，将指定列名以取代select *。</p><p><strong>2. 避免出现不确定结果的函数</strong></p><p>特定针对主从复制这类业务场景。由于原理上从库复制的是主库执行的语句，使用如now()、rand()、sysdate()、current_user()等不确定结果的函数很容易导致主库与从库相应的数据不一致。另外不确定值的函数,产生的SQL语句无法利用query cache。</p><p><strong>3.多表关联查询时，小表在前，大表在后。</strong></p><p>在MySQL中，执行 from 后的表关联查询是从左往右执行的（Oracle相反），第一张表会涉及到全表扫描，所以将小表放在前面，先扫小表，扫描快效率较高，在扫描后面的大表，或许只扫描大表的前100行就符合返回条件并return了。</p><p>例如：表1有50条数据，表2有30亿条数据；如果全表扫描表2，你品，那就先去吃个饭再说吧是吧。</p><p><strong>4. 使用表的别名</strong></p><p>当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个列名上。这样就可以减少解析的时间并减少哪些友列名歧义引起的语法错误。</p><p><strong>5. 用where字句替换HAVING字句</strong></p><p>避免使用HAVING字句，因为HAVING只会在检索出所有记录之后才对结果集进行过滤，而where则是在聚合前刷选记录，如果能通过where字句限制记录的数目，那就能减少这方面的开销。HAVING中的条件一般用于聚合函数的过滤，除此之外，应该将条件写在where字句中。</p><p>where和having的区别：where后面不能使用组函数</p><p><strong>6.调整Where字句中的连接顺序</strong></p><p>MySQL采用从左往右，自上而下的顺序解析where子句。根据这个原理，应将过滤数据多的条件往前放，最快速度缩小结果集。</p><h4 id="三、增删改-DML-语句优化"><a href="#三、增删改-DML-语句优化" class="headerlink" title="三、增删改 DML 语句优化"></a>三、增删改 DML 语句优化</h4><p><strong>1. 大批量插入数据</strong></p><p>如果同时执行大量的插入，建议使用多个值的INSERT语句(方法二)。这比使用分开INSERT语句快（方法一），一般情况下批量插入效率有几倍的差别。</p><p>方法一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert into T <span class="title function_">values</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span>; </span><br><span class="line">insert into T <span class="title function_">values</span><span class="params">(<span class="number">1</span>,<span class="number">3</span>)</span>; </span><br><span class="line">insert into T <span class="title function_">values</span><span class="params">(<span class="number">1</span>,<span class="number">4</span>)</span>;</span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Insert into T <span class="title function_">values</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span>,(<span class="number">1</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">4</span>); </span><br></pre></td></tr></table></figure><p>选择后一种方法的原因有三。</p><ul><li>减少SQL语句解析的操作，MySQL没有类似Oracle的share pool，采用方法二，只需要解析一次就能进行数据的插入操作；</li><li>在特定场景可以减少对DB连接次数</li><li>SQL语句较短，可以减少网络传输的IO。</li></ul><p><strong>2. 适当使用commit</strong></p><p>适当使用commit可以释放事务占用的资源而减少消耗，commit后能释放的资源如下：</p><ul><li>事务占用的undo数据块；</li><li>事务在redo log中记录的数据块；</li><li>释放事务施加的，减少锁争用影响性能。特别是在需要使用delete删除大量数据的时候，必须分解删除量并定期commit。</li></ul><p><strong>3. 避免重复查询更新的数据</strong></p><p>针对业务中经常出现的更新行同时又希望获得改行信息的需求，MySQL并不支持PostgreSQL那样的UPDATE RETURNING语法，在MySQL中可以通过变量实现。</p><p>例如，更新一行记录的时间戳，同时希望查询当前记录中存放的时间戳是什么，简单方法实现：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Update t1 set time=now() where col1=1; </span><br><span class="line">Select time from t1 where id =1; </span><br></pre></td></tr></table></figure><p>使用变量，可以重写为以下方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Update t1 set time=now () where col1=<span class="number">1</span> and <span class="meta">@now</span>: = now (); </span><br><span class="line">Select <span class="meta">@now</span>; </span><br></pre></td></tr></table></figure><p>前后二者都需要两次网络来回，但使用变量避免了再次访问数据表，特别是当t1表数据量较大时，后者比前者快很多。</p><p>4.查询优先还是更新（insert、update、delete）优先</p><p>MySQL 还允许改变语句调度的优先级，它可以使来自多个客户端的查询更好地协作，这样单个客户端就不会由于锁定而等待很长时间。改变优先级还可以确保特定类型的查询被处理得更快。我们首先应该确定应用的类型，判断应用是以查询为主还是以更新为主的，是确保查询效率还是确保更新的效率，决定是查询优先还是更新优先。下面我们提到的改变调度策略的方法主要是针对只存在表锁的存储引擎，比如 MyISAM 、MEMROY、MERGE，对于Innodb 存储引擎，语句的执行是由获得行锁的顺序决定的。MySQL 的默认的调度策略可用总结如下：</p><p>1）写入操作优先于读取操作。</p><p>2）对某张数据表的写入操作某一时刻只能发生一次，写入请求按照它们到达的次序来处理。</p><p>3）对某张数据表的多个读取操作可以同时地进行。MySQL 提供了几个语句调节符，允许你修改它的调度策略：</p><ul><li>LOW_PRIORITY关键字应用于DELETE、INSERT、LOAD DATA、REPLACE和UPDATE；</li><li>HIGH_PRIORITY关键字应用于SELECT和INSERT语句；</li><li>DELAYED关键字应用于INSERT和REPLACE语句。</li></ul><p>如果写入操作是一个 LOW_PRIORITY（低优先级）请求，那么系统就不会认为它的优先级高于读取操作。在这种情况下，如果写入者在等待的时候，第二个读取者到达了，那么就允许第二个读取者插到写入者之前。只有在没有其它的读取者的时候，才允许写入者开始操作。这种调度修改可能存在 LOW_PRIORITY写入操作永远被阻塞的情况。</p><p>SELECT 查询的HIGH_PRIORITY（高优先级）关键字也类似。它允许SELECT 插入正在等待的写入操作之前，即使在正常情况下写入操作的优先级更高。另外一种影响是，高优先级的 SELECT 在正常的 SELECT 语句之前执行，因为这些语句会被写入操作阻塞。如果希望所有支持LOW_PRIORITY 选项的语句都默认地按照低优先级来处理，那么 请使用–low-priority-updates 选项来启动服务器。通过使用 INSERTHIGH_PRIORITY 来把 INSERT 语句提高到正常的写入优先级，可以消除该选项对单个INSERT语句的影响。</p><h4 id="四、查询条件优化"><a href="#四、查询条件优化" class="headerlink" title="四、查询条件优化"></a>四、查询条件优化</h4><p><strong>1. 对于复杂的查询，可以使用中间临时表 暂存数据；</strong></p><p><strong>2. 优化group by语句</strong></p><p>默认情况下，MySQL 会对GROUP BY分组的所有值进行排序，如 “GROUP BY col1，col2，….;” 查询的方法如同在查询中指定 “ORDER BY col1，col2，…;” 如果显式包括一个包含相同的列的 ORDER BY子句，MySQL 可以毫不减速地对它进行优化，尽管仍然进行排序。</p><p>因此，如果查询包括 GROUP BY 但你并不想对分组的值进行排序，你可以指定 ORDER BY NULL禁止排序。例如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT col1, col2, COUNT(*) FROM table GROUP BY col1, col2 ORDER BY NULL ;</span><br></pre></td></tr></table></figure><p><strong>3. 优化join语句</strong></p><p>MySQL中可以通过子查询来使用 SELECT 语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的 SQL 操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接(JOIN)..替代。</p><p>例子：假设要将所有没有订单记录的用户取出来，可以用下面这个查询完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT col1 FROM customerinfo WHERE CustomerID NOT <span class="title function_">in</span> <span class="params">(SELECT CustomerID FROM salesinfo )</span></span><br></pre></td></tr></table></figure><p>如果使用连接(JOIN).. 来完成这个查询工作，速度将会有所提升。尤其是当 salesinfo表中对 CustomerID 建有索引的话，性能将会更好，查询如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT col1 FROM customerinfo </span><br><span class="line">LEFT JOIN salesinfoON customerinfo.CustomerID=salesinfo.CustomerID </span><br><span class="line">WHERE salesinfo.CustomerID IS NULL </span><br></pre></td></tr></table></figure><p>连接(JOIN).. 之所以更有效率一些，是因为 MySQL 不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。</p><p><strong>4. 优化union查询</strong></p><p>MySQL通过创建并填充临时表的方式来执行union查询。除非确实要消除重复的行，否则建议使用union all。原因在于如果没有all这个关键词，MySQL会给临时表加上distinct选项，这会导致对整个临时表的数据做唯一性校验，这样做的消耗相当高。</p><p>高效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT COL1, COL2, COL3 FROM TABLE <span class="type">WHERE</span> <span class="variable">COL1</span> <span class="operator">=</span> <span class="number">10</span> </span><br><span class="line">UNION ALL </span><br><span class="line">SELECT COL1, COL2, COL3 FROM TABLE WHERE COL3= <span class="string">&#x27;TEST&#x27;</span>; </span><br></pre></td></tr></table></figure><p>低效：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT COL1, COL2, COL3 FROM TABLE WHERE COL1 = 10 </span><br><span class="line">UNION </span><br><span class="line">SELECT COL1, COL2, COL3 FROM TABLE WHERE COL3= &#x27;TEST&#x27;;</span><br></pre></td></tr></table></figure><p><strong>5.拆分复杂SQL为多个小SQL，避免大事务</strong></p><ul><li>简单的SQL容易使用到MySQL的QUERY CACHE；</li><li>减少锁表时间特别是使用MyISAM存储引擎的表；</li><li>可以使用多核CPU。</li></ul><p><strong>6. 使用truncate代替delete</strong></p><p>当删除全表中记录时，使用delete语句的操作会被记录到undo块中，删除记录也记录binlog，当确认需要删除全表时，会产生很大量的binlog并占用大量的undo数据块，此时既没有很好的效率也占用了大量的资源。</p><p>使用truncate替代，不会记录可恢复的信息，数据不能被恢复。也因此使用truncate操作有其极少的资源占用与极快的时间。另外，使用truncate可以回收表的水位，使自增字段值归零。</p><p><strong>7. 使用合理的分页方式以提高分页效率</strong></p><p>使用合理的分页方式以提高分页效率 针对展现等分页需求，合适的分页方式能够提高分页的效率。</p><p>案例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from t <span class="type">where</span> <span class="variable">thread_id</span> <span class="operator">=</span> <span class="number">10000</span> <span class="type">and</span> <span class="variable">deleted</span> <span class="operator">=</span> <span class="number">0</span> </span><br><span class="line">order by gmt_create asc limit <span class="number">0</span>, <span class="number">15</span>;</span><br></pre></td></tr></table></figure><p>上述例子通过一次性根据过滤条件取出所有字段进行排序返回。数据访问开销&#x3D;索引IO+索引全部记录结果对应的表数据IO。因此，该种写法越翻到后面执行效率越差，时间越长，尤其表数据量很大的时候。</p><p>适用场景：当中间结果集很小（10000行以下）或者查询条件复杂（指涉及多个不同查询字段或者多表连接）时适用。</p><p>案例2：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t.<span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> thread_id <span class="operator">=</span> <span class="number">10000</span> <span class="keyword">and</span> deleted <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> gmt_create <span class="keyword">asc</span> limit <span class="number">0</span>, <span class="number">15</span>) a, t </span><br><span class="line"><span class="keyword">where</span> a.id <span class="operator">=</span> t.id;</span><br></pre></td></tr></table></figure><p>上述例子必须满足t表主键是id列，且有覆盖索引secondary key:(thread_id, deleted, gmt_create)。通过先根据过滤条件利用覆盖索引取出主键id进行排序，再进行join操作取出其他字段。数据访问开销&#x3D;索引IO+索引分页后结果（例子中是15行）对应的表数据IO。因此，该写法每次翻页消耗的资源和时间都基本相同，就像翻第一页一样。</p><p>适用场景：当查询和排序字段（即where子句和order by子句涉及的字段）有对应覆盖索引时，且中间结果集很大的情况时适用。</p><h4 id="五、建表优化"><a href="#五、建表优化" class="headerlink" title="五、建表优化"></a>五、建表优化</h4><p>\1. 在表中建立索引，优先考虑where、order by使用到的字段。</p><p>\2. 尽量使用数字型字段（如性别，男：1 女：2），若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。<br>这是因为引擎在处理查询和连接时会 逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p><p>\3. 查询数据量大的表 会造成查询缓慢。主要的原因是扫描行数过多。这个时候可以通过程序，分段分页进行查询，循环遍历，将结果合并处理进行展示。要查询100000到100050的数据，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM (SELECT <span class="title function_">ROW_NUMBER</span><span class="params">()</span> OVER(ORDER BY ID ASC) AS rowid,* </span><br><span class="line">FROM infoTab)t WHERE t.rowid &gt; <span class="number">100000</span> AND t.rowid &lt;= <span class="number">100050</span></span><br></pre></td></tr></table></figure><p>\4. 用varchar&#x2F;nvarchar 代替 char&#x2F;nchar</p><p>尽可能的使用 varchar&#x2F;nvarchar 代替 char&#x2F;nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。<br>不要以为 NULL 不需要空间，比如：char(100) 型，在字段建立时，空间就固定了， 不管是否插入值（NULL也包含在内），都是占用 100个字符的空间的，如果是varchar这样的变长字段， null 不占用空间。</p><hr><h3 id="中智智人面试"><a href="#中智智人面试" class="headerlink" title="中智智人面试"></a>中智智人面试</h3><h4 id="1-mysql中，什么是索引？索引什么情况下会失效？"><a href="#1-mysql中，什么是索引？索引什么情况下会失效？" class="headerlink" title="1 mysql中，什么是索引？索引什么情况下会失效？"></a>1 mysql中，什么是索引？索引什么情况下会失效？</h4><p><strong>什么时候没用</strong></p><ol><li>有or必全有索引;</li><li>复合索引未用左列字段;</li><li>like以%开头;</li><li>需要类型转换;</li><li>where中索引列有运算;</li><li>where中索引列使用了函数;</li><li>如果mysql觉得全表扫描更快时（数据少）;</li></ol><p><strong>什么时没必要用</strong></p><ol><li>唯一性差;</li><li>频繁更新的字段不用（更新索引消耗）;</li><li>where中不用的字段;</li><li>索引使用&lt;&gt;时，效果一般;</li></ol><p><strong>详述</strong></p><p>索引并不是时时都会生效的，比如以下几种情况，将导致索引失效：</p><ul><li>如果条件中有or，即使其中有部分条件带索引也不会使用(这也是为什么尽量少用or的原因)，例子中user_id无索引</li></ul><p>注意：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引</p><p><img src="/breeze/2a548e97/v2-29ce09d919837faee69931465d38e02f_720w.webp" alt="img"></p><ul><li>对于复合索引，如果不使用前列，后续列也将无法使用，类电话簿。</li><li>like查询是以%开头</li></ul><p><img src="/breeze/2a548e97/v2-d34853b5666e55835f422b3709fe817d_720w.webp" alt="img"></p><ul><li>存在索引列的数据类型隐形转换，则用不上索引，比如列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引</li></ul><p><img src="/breeze/2a548e97/v2-9f065a7d0f8b281337afce4138c5a2ad_720w.webp" alt="img"></p><ul><li>where 子句里对索引列上有数学运算，用不上索引</li></ul><p><img src="/breeze/2a548e97/v2-6e4efb77fa3880425fbfe1c4b758203e_720w.webp" alt="img"></p><ul><li>where 子句里对有索引列使用函数，用不上索引</li></ul><p><img src="/breeze/2a548e97/v2-1fe41a999964564d151a84475f8d068b_720w.webp" alt="img"></p><ul><li>如果mysql估计使用全表扫描要比使用索引快,则不使用索引</li></ul><blockquote><p>比如数据量极少的表</p></blockquote><p><strong>什么情况下不推荐使用索引？</strong></p><ol><li>数据唯一性差（一个字段的取值只有几种时）的字段不要使用索引</li></ol><blockquote><p>比如性别，只有两种可能数据。意味着索引的二叉树级别少，多是平级。这样的二叉树查找无异于全表扫描。</p></blockquote><ol><li>频繁更新的字段不要使用索引</li></ol><blockquote><p>比如logincount登录次数，频繁变化导致索引也频繁变化，增大数据库工作量，降低效率。</p></blockquote><ol><li>字段不在where语句出现时不要添加索引,如果where后含IS NULL &#x2F;IS NOT NULL&#x2F; like ‘%输入符%’等条件，不建议使用索引</li></ol><blockquote><p>只有在where语句出现，mysql才会去使用索引</p></blockquote><p>4） where 子句里对索引列使用不等于（&lt;&gt;），使用索引效果一般</p><h4 id="2-hashmap和treemap的区别？"><a href="#2-hashmap和treemap的区别？" class="headerlink" title="2 hashmap和treemap的区别？"></a>2 hashmap和treemap的区别？</h4><p>HashMap和TreeMap是Java中两种常见的数据结构，用于实现键值对的存储和检索，它们之间的区别如下：</p><ol><li>内部结构：HashMap使用哈希表（Hash Table）实现，而TreeMap使用红黑树（Red-Black Tree）实现。</li><li>排序：HashMap不保证键值对的顺序，而TreeMap会根据键的自然顺序（或自定义的比较器）对键值对进行排序。</li><li>效率：HashMap的插入、删除和查找操作的平均时间复杂度为O(1)，即常数级别，而TreeMap的这些操作的平均时间复杂度为O(log n)，其中n是键值对的数量。</li><li>迭代顺序：HashMap的迭代顺序是不确定的，而TreeMap的迭代顺序是按照键的顺序进行的。</li><li>空间占用：HashMap在存储大量数据时，相对于TreeMap来说具有更好的空间效率，因为它不需要额外的空间来维护树结构。</li><li>自定义比较：TreeMap可以通过实现Comparable接口或传入自定义的比较器来定义键的顺序，而HashMap没有提供直接的方式来自定义键的顺序。</li></ol><p>综上所述，如果需要快速的插入、删除和查找操作，并且不关心元素的顺序，则可以选择HashMap。但如果需要按照键的顺序进行遍历或查找操作，或需要自定义键的排序方式，则可以选择TreeMap。</p><h4 id="3-二叉树的遍历（数据结构）"><a href="#3-二叉树的遍历（数据结构）" class="headerlink" title="3 二叉树的遍历（数据结构）"></a>3 二叉树的遍历（数据结构）</h4><ul><li>前序遍历</li><li>中序遍历</li><li>后序遍历</li></ul><h4 id="4-冒泡排序（要求能直接手写）"><a href="#4-冒泡排序（要求能直接手写）" class="headerlink" title="4 冒泡排序（要求能直接手写）"></a>4 冒泡排序（要求能直接手写）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;输入要排序的值，输入的每个值用逗号隔开:&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将字符串按照&quot;,&quot;拆分成字符串数组</span></span><br><span class="line">        String[] strArray = str.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="comment">// 新建数组用来存储拆分出来的每个值</span></span><br><span class="line">        <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[strArray.length];</span><br><span class="line">        <span class="comment">// 给数组循环遍历赋值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strArray.length; i++) &#123;</span><br><span class="line">            array[i] = Integer.parseInt(strArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序前的数组：&quot;</span> + Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        sort(array);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后的数组：&quot;</span> + Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用冒泡排序算法对数组进行排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;趟&quot;</span>);</span><br><span class="line">            <span class="comment">// 优化冒泡排序，增加判断位，有序标记，每一轮的初始是true</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; array.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="comment">// 找最小数，如果前一位比后一位大，则交换位置</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    temp = array[j];</span><br><span class="line">                    array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                    array[j + <span class="number">1</span>] = temp;</span><br><span class="line">                    <span class="comment">// 有元素交换，所以不是有序，标记变为false</span></span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;  第&quot;</span> + (j + <span class="number">1</span>) + <span class="string">&quot;次：&quot;</span> + Arrays.toString(array));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 说明上面内层for循环中，没有交换任何元素，直接跳出外层循环</span></span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5 &#x3D;&#x3D; 和 equals的区别？</strong></p><p>在Java中，<code>==</code>和<code>equals</code>是用于比较对象的两种不同方式，它们之间的区别如下：</p><ol><li><code>==</code>比较的是对象的引用是否相等，即比较两个对象的内存地址是否相同。如果两个对象的引用指向同一个内存地址，返回true；否则返回false。</li><li><code>equals</code>是Object类的方法，默认情况下与<code>==</code>具有相同的行为，即比较对象的引用是否相等。但是，可以通过在类中重写<code>equals</code>方法来改变其行为。重写后的<code>equals</code>方法可以根据自定义的逻辑比较对象的属性值是否相等。</li></ol><p>实际上，<code>equals</code>方法的默认实现与<code>==</code>相同，即比较对象的引用。然而，许多类（如String、Integer等）在它们的实现中重写了<code>equals</code>方法，以便按照内容比较对象而不仅仅是比较引用。因此，在使用这些类时，应该使用<code>equals</code>方法进行比较，而不是<code>==</code>。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javaCopy <span class="type">CodeString</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(str1 == str2); <span class="comment">// false，比较的是引用</span></span><br><span class="line">System.out.println(str1.equals(str2)); <span class="comment">// true，比较的是内容</span></span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>str1</code>和<code>str2</code>内容相同（都是”Hello”），但是它们引用的内存地址不同。因此，使用<code>==</code>比较返回false，而使用<code>equals</code>比较返回true。</p><p>总结来说，<code>==</code>比较的是引用是否相等，而<code>equals</code>方法可以根据对象的重写逻辑来比较对象的内容是否相等。</p><h4 id="6-math-round-1-5-的值是多少？"><a href="#6-math-round-1-5-的值是多少？" class="headerlink" title="6 math.round(-1.5)的值是多少？"></a>6 math.round(-1.5)的值是多少？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Mr.Huang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: test</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@packageName</span>: PACKAGE_NAME</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span>: test01</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@describe</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2023年08月29日 10:47:17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result1</span> <span class="operator">=</span> a == b;</span><br><span class="line">        System.out.println(result1);</span><br><span class="line">        <span class="comment">// result1的值是false。因为a和b是通过new关键字创建的两个不同的Integer对象，它们引用的内存地址不同，所以==比较返回false。</span></span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result2</span> <span class="operator">=</span> a.equals(b);</span><br><span class="line">        System.out.println(result2);</span><br><span class="line">        <span class="comment">// result2的值是true。虽然a和b是两个不同的对象，但是它们都通过构造函数从字符串&quot;5&quot;中得到相同的值5。因此，equals方法比较的是两个对象的值，而不是引用，所以返回true。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Math.round()对于正数来说就是四舍五入</span></span><br><span class="line">        <span class="comment">// 对于负数来说就是 +0.5后向下取整，如：</span></span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">round</span> <span class="operator">=</span> Math.round(-<span class="number">2.5</span>);</span><br><span class="line">        System.out.println(round);</span><br><span class="line">        <span class="comment">//  -2.5：-2.5 + 0.5 = -2（已经是整数，不用再取整了）</span></span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">round2</span> <span class="operator">=</span> Math.round(-<span class="number">2.3</span>);</span><br><span class="line">        System.out.println(round2);</span><br><span class="line">        <span class="comment">//  -2.3：-2.3 + 0.5 = -1.8（向下取整）= -2</span></span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">round3</span> <span class="operator">=</span> Math.round(-<span class="number">2.8</span>);</span><br><span class="line">        System.out.println(round3);</span><br><span class="line">        <span class="comment">//  -2.8：-2.8 + 0.5 = -2.3（向下取整）= -3</span></span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">round33</span> <span class="operator">=</span> Math.round(-<span class="number">2.55</span>);</span><br><span class="line">        System.out.println(round33);</span><br><span class="line">        <span class="comment">//  -2.55：-2.55 + 0.5 = -2.05（向下取整）= -3</span></span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">round4</span> <span class="operator">=</span> Math.round(<span class="number">2.5</span>);</span><br><span class="line">        System.out.println(round4); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">round5</span> <span class="operator">=</span> Math.round(<span class="number">2.3</span>);</span><br><span class="line">        System.out.println(round5); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">round6</span> <span class="operator">=</span> Math.round(<span class="number">2.8</span>);</span><br><span class="line">        System.out.println(round6);<span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="7-redis的持久化方式？数据类型？什么是非关系型数据库？缓存三兄弟"><a href="#7-redis的持久化方式？数据类型？什么是非关系型数据库？缓存三兄弟" class="headerlink" title="7 redis的持久化方式？数据类型？什么是非关系型数据库？缓存三兄弟"></a>7 redis的持久化方式？数据类型？什么是非关系型数据库？缓存三兄弟</h4><p>Redis支持以下主要的数据类型：</p><ol><li>字符串（Strings）：用于存储字符串、整数或浮点数。</li><li>列表（Lists）：按照插入顺序存储的字符串元素集合。</li><li>集合（Sets）：无序、唯一且不重复的字符串元素集合。</li><li>有序集合（Sorted Sets）：类似于集合，但每个元素都关联一个分数，可以进行排序操作。</li><li>哈希表（Hashes）：存储字段和值的映射关系，适用于表示对象。</li></ol><p>此外，Redis还支持一些其他数据结构和功能，如：</p><ul><li>位图（Bitmaps）：基于位操作的特殊数据结构，可用于处理位级别的数据。</li><li>HyperLogLog：用于进行基数计数估计的数据结构。</li><li>地理空间索引（Geospatial Indexes）：用于存储地理位置信息的数据结构。</li><li>发布订阅（Pub&#x2F;Sub）：实现消息发布与订阅模式。</li><li>事务（Transactions）：一组原子操作的执行，保证原子性和一致性。</li></ul><p>这些数据类型和功能使得Redis成为了一种多用途的内存数据库和缓存系统。</p><p>关系型数据库（Relational Database）是基于关系模型（即二维表格）的数据库管理系统。在关系型数据库中，数据以表格的形式组织，由行和列组成，通过关系（关联）来表示不同表之间的关系。关系型数据库使用结构化查询语言（Structured Query Language，SQL）进行数据的定义、操作和查询。</p><p>关系型数据库的主要特点包括：</p><ol><li>数据结构化：数据以表格形式存储，每个表由若干行和列组成，每列具有固定的数据类型。</li><li>数据之间的关系：通过定义主键和外键来建立不同表之间的关系，实现数据的一致性和完整性。</li><li>预先定义的模式：在关系型数据库中，需要事先定义表的结构和字段的类型，所有数据的插入、更新和查询都需要符合事先定义好的模式。</li><li>ACID事务支持：关系型数据库提供了ACID（原子性、一致性、隔离性和持久性）事务支持，确保数据的一致性和可靠性。</li></ol><p>非关系型数据库（Non-relational Database），又称为NoSQL数据库（Not Only SQL），与关系型数据库不同，采用了不同的数据模型和存储方式，适用于处理大规模、高并发、动态结构或半结构化数据。</p><p>非关系型数据库的主要特点包括：</p><ol><li>非结构化数据模型：非关系型数据库使用灵活的数据模型，如键值对（Key-Value）、文档（Document）、列族（Wide Column）和图（Graph）等，适合存储不同类型和形式的数据。</li><li>高可扩展性：非关系型数据库采用分布式架构，可以方便地水平扩展，以应对大规模数据和高并发访问的需求。</li><li>高性能和低延迟：由于采用了内存计算和索引技术，以及去除了复杂的关系操作，非关系型数据库通常具有较高的读写性能和响应时间。</li><li>灵活的数据模型修改：非关系型数据库允许动态地修改数据模型和模式，无需事先定义固定的表结构，适合快速迭代和变化的数据需求。</li></ol><p>关系型数据库和非关系型数据库在数据建模、数据操作、数据一致性等方面有着明显的差异，适用于不同的应用场景和需求。在选择数据库时，需要根据具体的业务需求和数据特点来评估和选择适合的数据库类型。</p><h4 id="8-什么是反射？怎么禁用反射？"><a href="#8-什么是反射？怎么禁用反射？" class="headerlink" title="8 什么是反射？怎么禁用反射？"></a>8 什么是反射？怎么禁用反射？</h4><p>反射机制是在程序运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意个对象，都能够调用它的任意一个方法。在java中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。</p><p>这种动态获取信息以及动态获取对象的方法的功能称为java语言的反射机制。</p><p><strong>怎么禁用反射？</strong></p><p>在Java中，禁用反射是一项特殊需求，可能并不常见。Java语言本身并没有提供直接禁用反射的机制。然而，可以采取一些措施来限制反射的使用。下面是几个可能的示例：</p><ol><li>使用SecurityManager：<br>可以实现自定义的SecurityManager类，并重写<code>checkPermission()</code>方法，以限制对反射的访问权限。以下是一个示例：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.Permission;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySecurityManager</span> <span class="keyword">extends</span> <span class="title class_">SecurityManager</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkPermission</span><span class="params">(Permission perm)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">permName</span> <span class="operator">=</span> perm.getName();</span><br><span class="line">        <span class="keyword">if</span> (permName.startsWith(<span class="string">&quot;reflect&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;Reflective access is not allowed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在程序启动时，设置自定义的SecurityManager：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.setSecurityManager(<span class="keyword">new</span> <span class="title class_">MySecurityManager</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 禁止对反射的访问</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用字节码工具或混淆工具：<br>通过使用Java字节码工具和混淆工具，可以修改字节码文件，使其难以使用反射访问。这可能会导致一些副作用，并且可能与某些框架和库不兼容。</li></ol><p>需要注意的是，禁用反射可能会对程序的可维护性和可拓展性产生负面影响，并且有可能违反某些库或框架的使用规范。因此，在决定禁用反射之前，请仔细评估其必要性和影响，并确保了解可能引入的潜在问题和风险。</p><h4 id="9-抽象类的作用？抽象类和接口的区别？"><a href="#9-抽象类的作用？抽象类和接口的区别？" class="headerlink" title="9 抽象类的作用？抽象类和接口的区别？"></a>9 抽象类的作用？抽象类和接口的区别？</h4><p>抽象类是Java中的一种特殊类，其目的是为了被继承而设计。抽象类不能被实例化，只能作为其他类的父类，用于定义子类的共同行为和属性。抽象类通过声明抽象方法（即没有具体实现的方法）来强制要求子类实现这些方法。</p><p>抽象类的主要作用如下：</p><ol><li>定义类的通用行为：抽象类可以包含实现了的方法，这些方法可以在子类中直接使用，避免了重复编写相同代码的问题。</li><li>规范继承关系：通过抽象类，可以定义一个基类，强制要求其子类实现特定的方法，以确保子类具有某些共同的行为。</li><li>提供公共的方法和字段：抽象类可以定义公共的方法和字段，供子类直接使用，从而提供了一种代码复用的机制。</li><li>抽象方法没有方法体</li><li>抽象类无法创建对象</li><li>非抽象的类继承抽象类必须实现抽象类中的所有抽象方法</li></ol><p><strong>总结：</strong></p><ul><li>abstract不能和构造方法连用</li><li>abstract不能和static连用</li><li>abstract不能和final连用</li></ul><p>抽象类和接口都是实现类与使用者之间的契约，但它们在定义和使用上存在一些区别：</p><ol><li>实现方式：抽象类是通过继承来实现的，子类需要使用<code>extends</code>关键字继承抽象类，并可以继承一个抽象类。接口是通过实现（implements）来实现的，一个类可以实现多个接口。</li><li>构造函数：抽象类可以有构造函数，而接口不能拥有构造函数。</li><li>方法实现：抽象类中可以包含具体的方法实现，接口中只能包含抽象方法（Java 8及以前），或者默认方法和静态方法（Java 8之后）。</li><li>多继承限制：一个类只能继承一个抽象类，但可以实现多个接口。</li><li>设计用途：抽象类主要用于定义类族的公共行为和属性，提供一种基类的概念。接口更多地用于定义一组相关的操作方法，与类的具体实现无关，提供了一种更加灵活的方式来实现多态性。</li></ol><p><strong>接口总结：</strong></p><ul><li><p>接口是完全抽象的，接口没有构造方法。</p></li><li><p>接口中只允许出现常量和抽象方法。</p></li><li><p>常量和抽象方法都是public修饰的。</p></li><li><p>在接口中定义一个变量，会隐式的添加public static final</p></li><li><p>在接口中定义的一个方法会隐式的添加 public abstract</p></li><li><p>抽象方法都没有方法体（被abstract修饰的方法都没有方法体）</p></li><li><p>在java8之后，接口中新增了&#x3D;&#x3D;默认方法&#x3D;&#x3D;和&#x3D;&#x3D;静态方法&#x3D;&#x3D;</p><ul><li><p>一个类实现了接口，则这个类必须重新这个接口中所有的抽象方法；但是不需要（非必须）重写默认方法，也可以重写</p></li><li><p>一个接口中可以有多个默认方法</p></li><li><p>接口中的静态方法只能通过接口名调用</p></li><li><p>一个接口中可以有多个静态方法</p></li><li><pre><code class="java">/**
 * @author: Mr.Huang
 * @projectName: test
 * @packageName: PACKAGE_NAME
 * @className: Flayable
 * @describe: TODO
 * @date: 2023年09月04日 14:05:37
 * @version: 1.0.0
 */
public interface Flayable &#123;

    // 默认方法
    default void eating()&#123;
        System.out.println(&quot;吃饭&quot;);
    &#125;

    // 默认方法
    default void run()&#123;
        System.out.println(&quot;跑步&quot;);
    &#125;

    // 抽象方法
    void fly();

    // 静态方法
    static void staticMethod1()&#123;
        System.out.println(&quot;我是静态方法一&quot;);
    &#125;

    // 静态方法
    static void staticMethod2()&#123;
        System.out.println(&quot;我是静态方法二&quot;);
    &#125;
&#125;

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@author</span>: Mr.Huang</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@projectName</span>: test</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@packageName</span>: PACKAGE_NAME</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@className</span>: Cat</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@describe</span>:</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@date</span>: 2023年09月04日 14:10:14</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@version</span>: 1.0.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Flayable</span>&#123;</span><br><span class="line">  </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;飞猫起飞&quot;</span>);</span><br><span class="line">          <span class="comment">// this可以省略（默认就有this）</span></span><br><span class="line">          <span class="built_in">this</span>.eating();  <span class="comment">// 吃饭</span></span><br><span class="line">          run();          <span class="comment">// 重新跑</span></span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 可以重写默认方法，但是访问修饰符必须是public</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="comment">// Flayable.super.run();</span></span><br><span class="line">          System.out.println(<span class="string">&quot;重新跑&quot;</span>);  <span class="comment">// // 重新跑</span></span><br><span class="line">  </span><br><span class="line">          <span class="comment">// 调用接口中的静态方法(在实例方法中调用)</span></span><br><span class="line">          Flayable.staticMethod1();   <span class="comment">// 我是静态方法一</span></span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          <span class="type">Flayable</span> <span class="variable">flayable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">          flayable.fly();</span><br><span class="line">          flayable.run();</span><br><span class="line">          Flayable.staticMethod2(); <span class="comment">// 我是静态方法二</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
</code></pre></li></ul></li><li><p>接口中的所有方法默认都是public修饰的（抽象方法、静态方法、默认方法）</p></li></ul><p><strong>补充静态方法和实例方法之间的互相调用</strong></p><ul><li><p><strong>java中，静态方法中可以调用实例方法吗？</strong></p><ul><li><p>在 Java 中，静态方法中不能直接调用非静态实例方法。因为静态方法是在类加载时就已经存在于内存中，而非静态实例方法需要在类的实例化之后才能被调用，两者的生命周期不同，因此不能直接相互调用。</p><p>但是，可以通过创建类的对象来调用实例方法，然后在静态方法中传入该对象的引用，从而在静态方法中调用实例方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">javaCopy Codepublic <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">instanceMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实例方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">(MyClass obj)</span> &#123;</span><br><span class="line">        obj.instanceMethod(); <span class="comment">// 调用实例方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，静态方法 <code>staticMethod()</code> 的参数是一个 <code>MyClass</code> 类型的对象 <code>obj</code>。在静态方法中，可以通过传入的对象引用来调用该对象的实例方法 <code>instanceMethod()</code>。</p><p>需要注意的是，这种方式只有在确保传入的对象引用不为 null 的情况下才可以使用，否则会出现空指针异常。此外，如果静态方法需要频繁地调用同一个实例方法，最好将该实例方法声明为静态方法，或者将其提取到其他地方作为共享代码。</p></li></ul></li><li><p><strong>java中，实例方法中可以调用静态方法吗？</strong></p><ul><li><p>是的，Java 中实例方法可以调用静态方法。实例方法中可以直接通过静态方法的类名来调用静态方法，无需创建该类的对象。静态方法在类加载时就已经存在于内存中，不依赖于实例对象的创建。</p><p>例如，假设有一个类 <code>MyClass</code>，其中包含静态方法 <code>staticMethod()</code> 和实例方法 <code>instanceMethod()</code>，可以在 <code>instanceMethod()</code> 中直接调用 <code>staticMethod()</code>，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">javaCopy Codepublic <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 静态方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">instanceMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实例方法的实现</span></span><br><span class="line">        staticMethod(); <span class="comment">// 调用静态方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，在实例方法中调用静态方法时，不需要使用实例对象来调用静态方法，而是直接通过类名来调用即可。但是也可以使用实例对象来调用静态方法，但这样会被编译器解析为对应的类名进行调用。</p><p>另外，静态方法也可以直接调用其他静态方法，而无需进行实例化。</p></li></ul></li><li><p><strong>总结：</strong></p><ul><li>实例方法可以直接调用静态方法</li><li>静态方法可以直接调用静态方法</li><li>静态方法不能直接调用实例方法（可以在创建实例对象后，将该对象的引用作为参数传入静态方法，然后在静态方法中通过该应用去调用实例方法）</li></ul></li></ul><h4 id="10-final可以和abstract连用吗？为什么？"><a href="#10-final可以和abstract连用吗？为什么？" class="headerlink" title="10 final可以和abstract连用吗？为什么？"></a>10 final可以和abstract连用吗？为什么？</h4><p>在Java中，<code>final</code>和<code>abstract</code>这两个修饰符是相互冲突的，不能同时用于同一个类、方法或字段。</p><p><code>final</code>表示最终的、不可变的，它可以用于类、方法和字段。使用<code>final</code>修饰的类不能被继承，使用<code>final</code>修饰的方法不能被子类重写，使用<code>final</code>修饰的字段不能被修改。这意味着<code>final</code>修饰的元素具有不可改变性和终结性。</p><p>而<code>abstract</code>表示抽象的，它可以用于类和方法。使用<code>abstract</code>修饰的类必须是抽象类，它不能被实例化，只能作为其他类的基类。使用<code>abstract</code>修饰的方法必须在抽象类中声明，并且没有具体的实现，要求子类来实现该方法。</p><p><code>final</code>和<code>abstract</code>的含义和目的存在一定的冲突。<code>final</code>表示最终性、不可变性，而<code>abstract</code>表示待扩展、待实现，二者在用途和语义上是相反的。因此，Java语法规定，不能同时使用<code>final</code>和<code>abstract</code>修饰同一个类、方法或字段。</p><p>需要注意的是，可以同时使用<code>final</code>和<code>abstract</code>修饰内部类的方法参数和局部变量。在这种情况下，<code>final</code>表示不可变性，而<code>abstract</code>表示待实现性。这个组合的使用意义是为了在匿名内部类或Lambda表达式中引用这些参数或变量，以确保它们不被修改。</p><h4 id="11-final可以和static连用吗？为什么？"><a href="#11-final可以和static连用吗？为什么？" class="headerlink" title="11 final可以和static连用吗？为什么？"></a>11 final可以和static连用吗？为什么？</h4><p>是的，<code>final</code>修饰符可以和<code>static</code>修饰符连用。</p><p>当<code>final</code>和<code>static</code>同时修饰一个变量时，表示该变量是一个静态常量（Static Final Constant）。这意味着该变量具有以下特点：</p><ol><li>不可改变性：被<code>final</code>修饰的变量是不可修改的，即其值在初始化后不能再被改变。</li><li>类级别访问：被<code>static</code>修饰的变量属于类级别，而不是对象级别。它可以通过类名直接访问，无需实例化对象。</li><li>共享性：由于静态常量属于类级别，因此它们对于类中的所有对象来说都是共享的，只有一份拷贝。</li></ol><p>使用静态常量有一些优点：</p><ol><li>常量值的重用：避免了重复创建相同值的变量。</li><li>易于维护：只需在一个地方改变常量的值，即可使整个程序中所有引用该常量的地方生效。</li><li>更高的性能：对于基本类型的常量，因为它们存储在静态存储区，访问速度更快。</li></ol><p>下面是一个示例，展示了如何声明和使用静态常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">javaCopy Codepublic <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MY_CONSTANT</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(MyClass.MY_CONSTANT); <span class="comment">// 直接通过类名访问静态常量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，静态常量通常使用全大写字母来命名，多个单词之间使用下划线分隔，以增加可读性。</p><h4 id="12-如何保证redis和数据库的双写一致性？"><a href="#12-如何保证redis和数据库的双写一致性？" class="headerlink" title="12 如何保证redis和数据库的双写一致性？"></a>12 如何保证redis和数据库的双写一致性？</h4><p>读取缓存步骤一般没有什么问题，但是一旦涉及到数据更新：数据库和缓存更新，就容易出现缓存(Redis)和数据库（MySQL）间的数据一致性问题。</p><p>不管是先写MySQL数据库，再删除Redis缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。举一个例子：</p><p>1.如果删除了缓存Redis，还没有来得及写库MySQL，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。</p><p>2.如果先写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。</p><p>因为写和读是<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%B9%B6%E5%8F%91&spm=1001.2101.3001.7020">并发</a>的，没法保证顺序,就会出现缓存和数据库的数据不一致的问题。</p><p>如来解决？这里给出两个解决方案，先易后难，结合业务和技术代价选择使用。</p><p>二、缓存和数据库一致性解决方案</p><p>1.第一种方案：采用延时双删策略</p><p>在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。</p><p>伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String key,Object data)</span>&#123;</span><br><span class="line"> redis.delKey(key);</span><br><span class="line"> db.updateData(data);</span><br><span class="line"> Thread.sleep(<span class="number">500</span>);</span><br><span class="line"> redis.delKey(key);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><p>具体的步骤就是：</p><p>先删除缓存；<br>再写数据库；<br>休眠500毫秒；<br>再次删除缓存。<br>那么，这个500毫秒怎么确定的，具体该休眠多久呢？</p><p>需要评估自己的项目的读数据业务逻辑的耗时。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</p><p>当然这种策略还要考虑redis和数据库主从同步的耗时。最后的的写数据的休眠时间：则在读数据业务逻辑的耗时基础上，加几百ms即可。比如：休眠1秒。</p><p>设置缓存过期时间</p><p>从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。所有的写操作以数据库为准，只要到达缓存过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。</p><p>该方案的弊端</p><p>结合双删策略+缓存超时设置，这样最差的情况就是在超时时间内数据存在不一致，而且又增加了写请求的耗时。</p><p>2、第二种方案：异步更新缓存(基于订阅binlog的同步机制)</p><p>技术整体思路：</p><p>MySQL binlog增量订阅消费+消息队列+增量数据更新到redis</p><p>读Redis：热数据基本都在Redis<br>写MySQL:增删改都是操作MySQL<br>更新Redis数据：MySQ的数据操作binlog，来更新到Redis<br>Redis更新</p><p>1）数据操作主要分为两大块：</p><p>一个是全量(将全部数据一次写入到redis)<br>一个是增量（实时更新）<br>这里说的是增量,指的是mysql的update、insert、delate变更数据。</p><p>2）读取binlog后分析 ，利用消息队列,推送更新各台的redis缓存数据。</p><p>这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。</p><p>其实这种机制，很类似MySQL的主从备份机制，因为MySQL的主备也是通过binlog来实现的数据一致性。</p><p>这里可以结合使用canal(阿里的一款开源框架)，通过该框架可以对MySQL的binlog进行订阅，而canal正是模仿了mysql的slave数据库的备份请求，使得Redis的数据更新达到了相同的效果。</p><p>当然，这里的消息推送工具你也可以采用别的第三方：kafka、rabbitMQ等来实现推送更新Redis。</p><h4 id="13-redis的过期删除策略有哪些？"><a href="#13-redis的过期删除策略有哪些？" class="headerlink" title="13 redis的过期删除策略有哪些？"></a>13 redis的过期删除策略有哪些？</h4><p>Redis中的键过期策略主要有以下两种：</p><ol><li>定时删除（Active Expiration）：在每次访问键时检查其是否过期，并在过期时立即删除。这是Redis的默认过期策略，也是最常用的策略。当访问一个键时，Redis会先检查该键是否设置了过期时间，并判断是否过期，如果过期则立即删除。这种策略保证了过期键能够及时被删除。</li><li>惰性删除（Lazy Expiration）：只有在访问键时才检查其是否过期，并在过期时进行删除。Redis并不主动监测键的过期情况，而是在客户端发起读取或写入操作时进行检查，判断键是否过期并进行相应的删除操作。这种策略减少了对于过期键的检查次数，降低了开销，但可能导致过期键在一段时间内仍然存在。</li></ol><p>需要注意的是，定时删除和惰性删除策略是可以同时使用的。Redis会根据具体情况选择合适的策略。</p><p>另外，可以通过为键设置过期时间（使用EXPIRE命令）来实现有效的过期控制。设置过期时间后，Redis会自动管理键的过期和删除操作。</p><p>根据具体的业务需求，可以选择适合的过期策略来管理Redis中的键过期和删除操作。</p><h4 id="14-redis主要用来干什么？"><a href="#14-redis主要用来干什么？" class="headerlink" title="14 redis主要用来干什么？"></a>14 redis主要用来干什么？</h4><p>Redis是一个广泛应用的高性能键值存储系统，主要用来解决数据缓存、会话管理和消息队列等方面的需求。以下是Redis主要用途：</p><ol><li>缓存（Caching）：最常见的用途之一就是作为缓存层来存储经常需要读取的数据，如数据库查询结果、计算结果等。Redis的快速读写能力使其成为一个优秀的缓存解决方案，可以显著提升应用程序的响应速度和吞吐量。</li><li>会话存储（Session Storage）：Redis可以用作分布式会话存储，在分布式系统中存储和管理用户会话数据。通过将会话数据存储在Redis中，可以实现会话的共享和持久化，并支持会话过期和管理等功能。</li><li>消息队列（Message Queues）：Redis提供了发布&#x2F;订阅（Pub&#x2F;Sub）模式和阻塞队列等功能，可以作为高性能的消息队列系统。它可以用于实现异步任务、事件驱动等场景，保证不同组件之间的松耦合和高效通信。</li><li>数据存储和查询（Data Persistence and Queries）：Redis还支持持久化功能，可以将内存中的数据保存到硬盘上，以便重启后恢复数据。此外，Redis还提供丰富的数据结构和强大的查询功能，使其可以执行复杂的数据操作，如排序、计数、排行榜等。</li><li>分布式锁（Distributed Locking）：Redis提供了原子性的操作，可以用来实现分布式锁，确保在分布式环境中对共享资源的互斥访问。</li></ol><p>总之，Redis的高性能、灵活的数据结构和丰富的功能使其在许多场景下成为首选的数据存储和缓存解决方案，可以显著提升应用程序的性能和扩展性。</p><h3 id="普益标准"><a href="#普益标准" class="headerlink" title="普益标准"></a>普益标准</h3><h4 id="1-springboot和springcloud的区别"><a href="#1-springboot和springcloud的区别" class="headerlink" title="1 springboot和springcloud的区别?"></a>1 springboot和springcloud的区别?</h4><p>Spring Boot和Spring Cloud是Spring生态系统中的两个关键组件，它们在功能和定位上有所区别。</p><ol><li>Spring Boot：<ul><li>Spring Boot是一个用于简化和加速构建独立的、基于Spring的应用程序的框架。它提供了自动配置、嵌入式服务器以及一些常见的功能模块，使得开发者可以快速搭建和运行独立的Spring应用。</li><li>Spring Boot通过约定大于配置的原则，减少了繁琐的配置文件和依赖管理，帮助开发者更专注于业务逻辑实现。</li><li>Spring Boot并不是一个完整的微服务框架，而是提供了快速创建和部署微服务的方式。</li></ul></li><li>Spring Cloud：<ul><li>Spring Cloud是用于构建分布式系统中的基于微服务架构的工具集合。它基于Spring Boot构建，并提供了一系列的组件和模块，为开发者提供了创建、部署和管理分布式系统的解决方案。</li><li>Spring Cloud包括服务注册与发现、负载均衡、服务调用、断路器、配置中心、消息总线等组件和模块，用于解决微服务架构中各种常见问题。</li><li>Spring Cloud利用了Spring Boot的自动配置原理，开发者只需通过简单的注解和配置即可快速搭建和连接各个微服务。</li></ul></li></ol><p>综上所述，Spring Boot主要关注于快速构建独立的Spring应用，简化开发过程，并提供一些常见功能模块；而Spring Cloud则是基于Spring Boot构建的分布式系统解决方案，提供了一整套用于构建和管理微服务架构的组件和模块。</p><p>一般来说，使用Spring Boot作为基础框架来创建单体应用，而使用Spring Cloud来构建和管理微服务架构。它们可以很好地协同工作，为开发者提供了快速、灵活且易于维护的分布式系统开发解决方案。</p><h4 id="2-mybatis是做什么的？"><a href="#2-mybatis是做什么的？" class="headerlink" title="2 mybatis是做什么的？"></a>2 mybatis是做什么的？</h4><p>MyBatis是一个持久层框架，用于简化Java应用程序与关系型数据库之间的交互。它提供了一种将数据库操作和SQL语句与Java代码解耦的方式。</p><p>MyBatis主要用于以下几个方面：</p><ol><li>数据库访问：MyBatis可以帮助开发者进行数据库的增删改查等基本操作。它提供了灵活的SQL映射机制，可以根据需求编写、管理和执行复杂的SQL语句。</li><li>参数映射：MyBatis支持将Java对象与SQL语句中的参数进行自动映射。这样，开发者可以直接传递Java对象作为参数，而无需手动拼接SQL语句。</li><li>结果映射：MyBatis可以将查询结果自动映射到Java对象中。通过配置文件或注解，可以定义对象属性与数据库字段之间的映射关系，使得结果集处理更加简便。</li><li>缓存机制：MyBatis提供了一级缓存和二级缓存功能，帮助减少对数据库的频繁访问，提高系统性能。</li><li>动态SQL：MyBatis支持动态SQL，允许根据条件动态拼接SQL语句。开发者可以根据不同情况动态生成SQL，避免大量重复的SQL语句。</li></ol><p>总结来说，MyBatis是一个优秀的持久层框架，通过将SQL语句与Java代码解耦，帮助开发者简化数据库操作。它提供了灵活的参数映射和结果映射功能，支持缓存管理和动态SQL，使得数据库访问更加方便、高效，并且易于维护。</p><h4 id="3-linux系统中如何找出当前CPU占用最高的程序？"><a href="#3-linux系统中如何找出当前CPU占用最高的程序？" class="headerlink" title="3 linux系统中如何找出当前CPU占用最高的程序？"></a>3 linux系统中如何找出当前CPU占用最高的程序？</h4><p>在Linux系统中，可以使用以下方法找出当前CPU占用最高的程序：</p><ol><li><p>使用top命令：在终端中输入<code>top</code>命令，然后按下键盘上的<code>Shift</code>+<code>P</code>组合键，即可按照CPU占用率进行排序，最高的程序将会排在列表的顶部。可以按下<code>q</code>键退出top命令。</p></li><li><p>使用htop命令：htop是一个类似于top命令的任务管理器，提供了更直观和易用的界面。在终端中输入<code>htop</code>命令，然后按下键盘上的<code>F6</code>键选择CPU%（CPU占用率）选项，即可按照CPU占用率进行排序，最高的程序将会排在列表的顶部。按下<code>q</code>键退出htop命令。</p></li><li><p>使用ps命令结合排序选项：在终端中输入以下命令，即可找出当前CPU占用最高的程序：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copy Codeps -eo pid,ppid,%cpu,%mem,cmd --<span class="built_in">sort</span>=-%cpu | <span class="built_in">head</span></span><br></pre></td></tr></table></figure><p>这条命令使用<code>ps</code>命令获取进程信息，并按照CPU占用率进行降序排序，<code>head</code>命令只显示排名靠前的几个进程。</p></li></ol><p>通过以上方法，你可以方便地找到当前CPU占用最高的程序，并进行后续的调优或处理。</p><hr><h2 id="XX公司面试"><a href="#XX公司面试" class="headerlink" title="XX公司面试"></a>XX公司面试</h2><h4 id="创建线程池的几种方式"><a href="#创建线程池的几种方式" class="headerlink" title="创建线程池的几种方式"></a>创建线程池的几种方式</h4><p>在Java中，可以通过多种方式来创建线程池，主要是利用<code>java.util.concurrent</code>包中的<code>Executor</code>框架。以下是几种常用的创建线程池的方式：</p><ol><li><strong>使用Executors工厂类创建预定义类型的线程池：</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>); <span class="comment">// 创建一个固定大小的线程池</span></span><br></pre></td></tr></table></figure></li></ol><p>其他预定义类型的线程池还包括：</p><ul><li><code>newSingleThreadExecutor()</code>：创建一个单线程的线程池。</li><li><code>newCachedThreadPool()</code>：创建一个可缓存的线程池，线程数根据需要自动调整。</li><li><code>newScheduledThreadPool(int corePoolSize)</code>：创建一个大小固定的线程池，支持定时以及周期性任务执行。</li></ul><ol start="2"><li><strong>使用ThreadPoolExecutor自定义线程池：</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">corePoolSize</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">maximumPoolSize</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">keepAliveTime</span> <span class="operator">=</span> <span class="number">5000</span>;</span><br><span class="line">BlockingQueue&lt;Runnable&gt; workQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.MILLISECONDS, workQueue);</span><br></pre></td></tr></table></figure></li></ol><p>这种方式可以精确地定义线程池的各项参数，包括核心线程数、最大线程数、线程存活时间、任务队列等。</p><ol start="3"><li><strong>使用ThreadPoolTaskExecutor（Spring框架中）：</strong><br>Spring框架提供了<code>ThreadPoolTaskExecutor</code>类，用于创建线程池。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">executor.setCorePoolSize(<span class="number">5</span>); <span class="comment">// 设置核心线程数</span></span><br><span class="line">executor.setMaxPoolSize(<span class="number">10</span>); <span class="comment">// 设置最大线程数</span></span><br><span class="line">executor.setQueueCapacity(<span class="number">10</span>); <span class="comment">// 设置任务队列容量</span></span><br><span class="line">executor.initialize();</span><br></pre></td></tr></table></figure></li></ol><p>这种方式在Spring应用中非常常见，能够很方便地创建和管理线程池。</p><p>以上是几种创建线程池的常见方式，每种方式都有不同的适用场景和特点，可以根据具体需求选择合适的方式。</p><blockquote><p><strong>通过Executor工厂类创建的线程，默认有阻塞队列吗?</strong></p><p>在Executor工厂类中，创建的线程池通常会默认使用一个阻塞队列来存储待执行的任务。具体使用的是什么类型的阻塞队列取决于使用的工厂方法。下面是一些常见的情况：</p><ol><li><p><code>newFixedThreadPool</code>和<code>newSingleThreadExecutor</code>方法默认使用的是<code>LinkedBlockingQueue</code>，这是一个无界的阻塞队列，它会一直排队任务，不会拒绝任务，但在内存占用上可能会有问题。</p></li><li><p><code>newCachedThreadPool</code>方法使用的是<code>SynchronousQueue</code>，它是一个没有存储空间的阻塞队列，任务会立即传递给工作线程，如果没有空闲的工作线程来执行任务，它会尝试创建新的工作线程。这样可以确保所有任务都被处理，但是也会增加对系统资源的占用。</p></li><li><p><code>newScheduledThreadPool</code>方法默认使用的是<code>DelayedWorkQueue</code>，它是一个特殊类型的阻塞队列，用于支持定时任务和周期性任务的执行。</p></li></ol><p>需要注意的是，在使用Executor工厂类创建线程池时，可以对参数进行自定义设置，包括线程池的核心线程数、最大线程数、队列大小等。在实际应用中，根据需求选择合适的线程池配置是非常重要的。</p></blockquote><h4 id="java中，过滤器和拦截器的作用与区别？"><a href="#java中，过滤器和拦截器的作用与区别？" class="headerlink" title="java中，过滤器和拦截器的作用与区别？"></a>java中，过滤器和拦截器的作用与区别？</h4><p>在Java中，过滤器（Filter）和拦截器（Interceptor）都用于对HTTP请求进行处理，但它们的作用和区别如下：</p><ol><li>过滤器（Filter）：</li></ol><ul><li>过滤器是Servlet规范中定义的对象，用于在请求进入Servlet之前或响应返回客户端之前执行一些预处理或后处理任务。</li><li>过滤器可以用来实现诸如日志记录、字符编码转换、鉴权、数据压缩等功能。</li><li>过滤器在web.xml中配置，可以对所有的请求进行过滤处理。</li></ul><ol start="2"><li>拦截器（Interceptor）：</li></ol><ul><li>拦截器是Spring框架中的概念，用于在方法调用前后、异常抛出前后执行一些处理任务。</li><li>拦截器通常与Spring的AOP（面向切面编程）结合使用，可以更精细地控制方法的调用。</li><li>拦截器主要用于业务逻辑层的方法拦截，例如权限验证、日志记录、事务管理等。</li></ul><p>区别：</p><ol><li>过滤器属于Servlet规范，而拦截器属于Spring框架。</li><li>过滤器工作在Servlet之前或之后，而拦截器工作在方法调用前后。</li><li>过滤器只能对所有请求进行处理，而拦截器可以更精细地控制方法的调用。</li><li>过滤器主要用于请求和响应的预处理和后处理，而拦截器主要用于业务逻辑层的方法拦截。</li></ol><h4 id="java中，List转Array调用什么方法？Array转List调用什么方法？"><a href="#java中，List转Array调用什么方法？Array转List调用什么方法？" class="headerlink" title="java中，List转Array调用什么方法？Array转List调用什么方法？"></a>java中，List转Array调用什么方法？Array转List调用什么方法？</h4><p>在Java中，可以使用以下方法来进行List和数组之间的转换：</p><ol><li>List转Array：可以使用List接口的toArray方法，该方法可以将List转换为数组。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 添加元素到list中</span></span><br><span class="line">String[] array = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[list.size()]);</span><br></pre></td></tr></table></figure><ol start="2"><li>Array转List：可以使用Arrays类中的asList方法，该方法可以将数组转换为List。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] array = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(array);</span><br></pre></td></tr></table></figure><p>需要注意的是，List转Array时，需要指定数组的类型以及数组的大小；而Array转List时，返回的List是一个固定长度的List，不能进行增删操作，因为asList方法返回的List是一个不可变的列表。</p><hr><h4 id="ES和MySQL中的数据如何同步"><a href="#ES和MySQL中的数据如何同步" class="headerlink" title="ES和MySQL中的数据如何同步"></a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/659792107">ES和MySQL中的数据如何同步</a></h4><hr><h3 id="java应用多线程之间是如何进行通信的？"><a href="#java应用多线程之间是如何进行通信的？" class="headerlink" title="java应用多线程之间是如何进行通信的？"></a>java应用多线程之间是如何进行通信的？</h3><p>在Java中，多线程之间可以通过以下方式进行通信：</p><ol><li>共享内存：多个线程可以通过共享内存的方式进行通信，它们可以访问同一个对象或变量来交换信息。</li><li>等待&#x2F;通知机制：使用<code>wait()</code>、<code>notify()</code>和<code>notifyAll()</code>方法，线程可以等待某些条件满足后被唤醒，或者通知其他线程条件已经满足。</li><li>阻塞队列：利用<code>BlockingQueue</code>等阻塞队列，一个线程可以将数据放入队列，另一个线程则可以从队列中获取数据，从而实现线程间的通信。</li><li>信号量：使用<code>Semaphore</code>类来控制多个线程对共享资源的访问，实现线程间的协调与通信。</li><li>管道：通过<code>PipedInputStream</code>和<code>PipedOutputStream</code>，线程之间可以通过管道进行输入输出流的通信。</li></ol><p>以上这些方式都可以帮助多个线程在Java应用程序中进行有效的通信和协作。</p><hr><h3 id="在编程中，在字符串前面加什么符号，则字符串中的转义字符将不被处理"><a href="#在编程中，在字符串前面加什么符号，则字符串中的转义字符将不被处理" class="headerlink" title="在编程中，在字符串前面加什么符号，则字符串中的转义字符将不被处理"></a>在编程中，在字符串前面加什么符号，则字符串中的转义字符将不被处理</h3><p>在Java编程中，如果在字符串前面加上”@”符号，则字符串中的转义字符将不被处理。这种方式称为”原始字符串”（raw string），它可以让你在字符串中直接包含换行符、制表符以及其他转义字符，而无需对其进行额外的处理。这在编写正则表达式、多行文本或者包含大量转义字符的字符串时非常有用。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">rawString</span> <span class="operator">=</span> @<span class="string">&quot;This is a raw string.</span></span><br><span class="line"><span class="string">It can contain special characters like \n, \t without escaping them.&quot;</span>;</span><br></pre></td></tr></table></figure><p>在上面的示例中，以”@”开头的字符串被视为原始字符串，其中的”\n”和”\t”等转义字符不会被处理，而是作为普通字符原样输出。</p><hr><h3 id="如何解决第二类丢失更新问题？"><a href="#如何解决第二类丢失更新问题？" class="headerlink" title="如何解决第二类丢失更新问题？"></a>如何解决第二类丢失更新问题？</h3><p>第二类丢失更新问题通常指的是在多线程环境下，由于竞争条件或者并发操作导致的数据不一致性问题。解决这类问题可以采用以下方法：</p><ol><li><p>同步：使用Java中的<code>synchronized</code>关键字或者<code>ReentrantLock</code>等锁机制来确保对共享数据的操作是原子的，从而避免多个线程同时修改数据导致的问题。</p></li><li><p>使用并发数据结构：Java中提供了一些并发安全的数据结构，如<code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code>等，它们内部实现了线程安全的操作，可以避免大部分的并发问题。</p></li><li><p>使用Atomic类：Java中的<code>java.util.concurrent.atomic</code>包提供了一系列原子操作的类，如<code>AtomicInteger</code>、<code>AtomicLong</code>等，可以确保对这些变量的操作是原子的，从而避免竞态条件。</p></li><li><p>使用volatile关键字：<code>volatile</code>关键字可以确保多个线程之间对变量的可见性，从而避免了由于缓存不一致导致的问题。</p></li><li><p>使用线程安全的设计模式：例如使用不可变对象、单例模式等可以减少多线程环境下的数据竞争问题。</p></li></ol><p>以上方法都可以帮助解决第二类丢失更新问题，选择合适的方法取决于具体的场景和需求。</p><hr><h3 id="fail-fast机制和fail-safe机制的区别？"><a href="#fail-fast机制和fail-safe机制的区别？" class="headerlink" title="fail-fast机制和fail-safe机制的区别？"></a>fail-fast机制和fail-safe机制的区别？</h3><p>在Java编程中，”fail-fast”机制和”fail-safe”机制是处理并发操作时常见的两种策略，它们有以下区别：</p><ol><li><p><strong>Fail-Fast 机制</strong>：</p><ul><li>当多个线程对数据进行并发修改时，如果检测到其他线程的修改可能导致当前线程无法继续安全操作，就立即抛出 <code>ConcurrentModificationException</code> 异常。</li><li>Fail-Fast 机制追求快速失败，及时发现问题并尽早暴露，以避免数据结构被破坏。</li><li>典型的 Fail-Fast 结构包括 <code>HashMap</code> 和 <code>ArrayList</code>。</li></ul></li><li><p><strong>Fail-Safe 机制</strong>：</p><ul><li>在遍历数据的过程中允许其他线程对数据进行修改，但不会影响当前线程的遍历操作，即使其他线程对数据进行了修改，当前线程也不会抛出异常。</li><li>Fail-Safe 机制保证遍历操作的安全性，但可能会导致读取到过期或者不一致的数据。</li><li>典型的 Fail-Safe 结构包括 <code>ConcurrentHashMap</code> 和 <code>CopyOnWriteArrayList</code>。</li></ul></li></ol><p>总的来说，Fail-Fast 机制会在并发修改时立即抛出异常，而 Fail-Safe 机制会允许并发修改但不会影响当前操作，只是可能读取到部分过期数据。选择使用哪种机制应根据具体需求和业务场景来决定。</p><hr></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://mliutm.github.io">清风</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://mliutm.github.io/breeze/2a548e97.html">https://mliutm.github.io/breeze/2a548e97.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://mliutm.github.io" target="_blank">清风</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95%E5%AE%9E%E6%88%98/">面试实战</a></div><div class="post_share"><div class="social-share" data-image="/img/photo-1653549892896-dde02867edee.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/breeze/7ae0ca37.html" title="Redis_30道经典面试题"><img class="cover" src="/img/photo-1653549892896-dde02867edee.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Redis_30道经典面试题</div></div></a></div><div class="next-post pull-right"><a href="/breeze/4edde71e.html" title="Vue2-3-Vue3状态管理Pinia（十一）"><img class="cover" src="/img/photo-1645943020355-305df166473d.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Vue2-3-Vue3状态管理Pinia（十一）</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">清风</div><div class="author-info__description">清风洒六合，邈然不可攀</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">169</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">82</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:huangpan0805@163.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div><timing></timing></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JAVA9%E6%9C%9F%E5%AE%9E%E6%88%98%E9%9D%A2%E8%AF%95%E9%A2%98%E5%9C%B0%E5%9D%80"><span class="toc-text">JAVA9期实战面试题地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%95%85%E5%8A%A0%E7%A7%91%E6%8A%80%E6%9C%89%E9%99%90%E5%85%AC%E5%8F%B8"><span class="toc-text">畅加科技有限公司</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%AD%E9%AB%98%E7%BA%A7JAVA%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E9%A2%98"><span class="toc-text">一、中高级JAVA工程师笔试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-JAVA%E8%BF%9B%E8%A1%8C%E6%95%B0%E5%80%BC%E7%9A%84%E8%BF%90%E7%AE%97%EF%BC%8C%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1"><span class="toc-text">1.JAVA进行数值的运算，如何防止精度丢失?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-SpringBoot%E5%92%8CSpring%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">2.SpringBoot和Spring的区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-SpringBoot%E9%9C%80%E8%A6%81%E7%8B%AC%E7%AB%8B%E7%9A%84%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E5%90%97"><span class="toc-text">3.SpringBoot需要独立的容器运行吗?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-SpringBoot%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-text">4.SpringBoot中如何实现定时任务?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringCloud%E6%98%AF%E4%BB%80%E4%B9%88-%E5%92%8CSpringBoot%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">SpringCloud是什么?和SpringBoot的区别是什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-RPC%E8%B0%83%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88-%E5%92%8CHTTP%E8%B0%83%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88-SpringCloud%E7%9A%84RPC%E8%B0%83%E7%94%A8%E6%A1%86%E6%9E%B6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">6.RPC调用是什么?和HTTP调用的区别是什么?SpringCloud的RPC调用框架是什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E5%92%8C%E6%B3%A8%E5%86%8C%EF%BC%8CSpringCloud%E7%9A%84%E6%B2%BB%E7%90%86%E6%B3%A8%E5%86%8C%E6%A1%86%E6%9E%B6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">7.什么是服务治理和注册，SpringCloud的治理注册框架是什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-Nacos%E7%9A%84%E7%BD%91%E9%A1%B5%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0%E9%BB%98%E8%AE%A4%E8%AE%BF%E9%97%AE%E8%B7%AF%E5%BE%84%E6%98%AF%E4%BB%80%E4%B9%88-SpringBoot%E5%A6%82%E4%BD%95%E6%8E%A5%E5%85%A5Nacos"><span class="toc-text">8.Nacos的网页管理后台默认访问路径是什么?SpringBoot如何接入Nacos?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-SS0%E6%98%AF%E4%BB%80%E4%B9%88-SpringCloud%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0SS0"><span class="toc-text">9.SS0是什么?SpringCloud中如何实现SS0?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-K8S%E6%98%AF%E4%BB%80%E4%B9%88-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8K8S%E6%9F%A5%E7%9C%8B%E6%9C%8D%E5%8A%A1%E8%BF%90%E8%A1%8C%E6%97%A5%E5%BF%97"><span class="toc-text">10.K8S是什么?如何使用K8S查看服务运行日志?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-K8S%E4%B8%AD%E7%9A%84node-%E5%92%8Cpod-%E7%9A%84%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">11.K8S中的node 和pod 的分别是什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-Java-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%8F%98%E9%87%8F%E5%AE%89%E5%85%A8%E9%9A%94%E7%A6%BB"><span class="toc-text">12.Java 如何实现线程变量安全隔离?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-Java-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">13.Java 分布式锁的实现方式有哪些?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F%E6%9C%89%E9%82%A3%E4%BA%9B-%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">14.常见的加密方式有那些?非对称加密和对称加密的区别是什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-%E4%BB%80%E4%B9%88%E6%98%AF-QPS%E3%80%81%E5%B9%B6%E5%8F%91%E6%95%B0"><span class="toc-text">15.什么是 QPS、并发数?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-Mybatis-Plus%E6%89%B9%E9%87%8F%E6%9B%B4%E6%96%B0%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">16.Mybatis Plus批量更新的方法是什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-MySql%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90-SQL-%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">17.MySql如何分析 SQL,语句的关键字是什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8BMySQL%E7%9A%84%E5%BD%93%E5%89%8D%E8%BF%9E%E6%8E%A5%E6%83%85%E5%86%B5-%E6%80%8E%E4%B9%88%E6%9D%80%E6%AD%BB%E5%A0%B5%E5%A1%9E%E8%BF%9E%E6%8E%A5"><span class="toc-text">18.如何查看MySQL的当前连接情况?怎么杀死堵塞连接?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-%E8%AF%B7%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%99%BB%E5%BD%95%E5%92%8C%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E7%9A%84%E8%A1%A8%E7%BB%93%E6%9E%84-%E4%BB%85%E9%9C%80%E5%86%99%E5%87%BA%E8%AE%BE%E8%AE%A1%E8%A1%A8%E5%90%8D%E5%AD%97%E5%92%8C%E8%A1%A8%E4%B9%8B%E9%97%B4%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%E5%8D%B3%E5%8F%AF%EF%BC%8C%E6%97%A0%E9%9C%80%E5%85%B7%E4%BD%93%E5%AD%97%E6%AE%B5"><span class="toc-text">19.请设计一个登录和权限控制的表结构(仅需写出设计表名字和表之间关联关系即可，无需具体字段)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-%E5%A6%82%E6%9E%9C%E9%9C%80%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%95%86%E5%93%81%E5%BA%93%E5%AD%98%E6%89%A3%E5%87%8F%EF%BC%8C%E5%A6%82%E4%BD%95%E5%85%BC%E9%A1%BE%E6%80%A7%E8%83%BD%E5%92%8C%E5%87%86%E7%A1%AE%E6%80%A7%EF%BC%8C%E4%B8%8D%E5%87%BA%E7%8E%B0%E8%B6%85%E6%89%A3%E3%80%81%E9%87%8D%E5%A4%8D%E6%89%A3%E3%80%81%E5%B0%91%E6%89%A3%E7%AD%89%E6%83%85%E5%86%B5"><span class="toc-text">20.如果需要进行商品库存扣减，如何兼顾性能和准确性，不出现超扣、重复扣、少扣等情况?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XX%E5%85%AC%E5%8F%B8"><span class="toc-text">XX公司</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%94%E8%AF%95%E9%A2%98"><span class="toc-text">笔试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B7%E8%A7%A3%E9%87%8A-Arraylist-%E5%92%8C-LinkedList-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1.请解释 Arraylist 和 LinkedList 的区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-break%E5%92%8Ccontinue-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">2.break和continue 的区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">3.对称加密与非对称加密的区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%9C%A8-Java-%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%90%E8%A1%8C%E5%AE%89%E5%85%A8"><span class="toc-text">4.在 Java 程序中怎么保证多线程的运行安全?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96"><span class="toc-text">5.什么是缓存穿透?应该如何优化?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">6.数据库连接池的作用是什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%97%B6%EF%BC%8C%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E4%BA%A7%E7%94%9F%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F-%E5%88%86%E5%88%AB%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96"><span class="toc-text">7.SQL语句执行时，哪些情况下会产生全表扫描?分别应该如何优化?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E7%BA%BF%E7%A8%8B%E9%94%81%E7%9A%84%E6%80%A7%E8%83%BD"><span class="toc-text">8.如何提升线程锁的性能?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E8%AF%B7%E7%AE%80%E8%BF%B0%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95"><span class="toc-text">9.请简述一致性哈希算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%AD%EF%BC%8C%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8"><span class="toc-text">java系统开发中，怎么保证数据安全?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E9%83%BD%E4%BC%8A%E7%99%BB%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E6%9C%89%E9%99%90%E5%85%AC%E5%8F%B8"><span class="toc-text">成都伊登软件技术有限公司</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#http%E5%92%8Chttps%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">http和https的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F"><span class="toc-text">TCP的三次握手，四次挥手？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%EF%BC%9F"><span class="toc-text">什么是单向链表，什么是双向链表？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F%E5%8F%8D%E5%B0%84%E4%BC%9A%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">java中，什么是反射？反射会带来什么问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mybatis-plus%E5%88%86%E9%A1%B5%E5%8E%9F%E7%90%86"><span class="toc-text">mybatis-plus分页原理?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ES%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-text">ES如何优化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ES%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-text">ES如何设置索引？</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E6%B5%A9%E7%94%B5%E5%8A%9B%E7%A7%91%E6%8A%80"><span class="toc-text">正浩电力科技</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E7%94%A8%E8%BF%87%E5%90%97%EF%BC%9F"><span class="toc-text">远程桌面用过吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E6%9F%A5%E7%9C%8B%E4%BB%A5%E5%89%8D%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%89%88%E6%9C%AC%EF%BC%9F"><span class="toc-text">怎么查看以前项目的版本？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%86%E9%A2%91%E7%9A%84%E6%B5%81%E5%AA%92%E4%BD%93%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E7%9A%84"><span class="toc-text">视频的流媒体怎么处理的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%88%90%E4%BA%86%E5%A4%9A%E5%B0%91%E4%B8%AA%E5%BE%AE%E6%9C%8D%E5%8A%A1%EF%BC%8C%E9%83%A8%E7%BD%B2%E4%BA%86%E5%A4%9A%E5%B0%91%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">分成了多少个微服务，部署了多少个服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86"><span class="toc-text">项目的版本管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E6%96%87%E6%A1%A3%E5%86%99%E6%B2%A1%E5%86%99%E8%BF%87"><span class="toc-text">需求文档写没写过</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%9C%89length%E5%B1%9E%E6%80%A7%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%89length%E6%96%B9%E6%B3%95"><span class="toc-text">数组有length属性，字符串有length方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%8C%96%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="toc-text">标准化的软件开发流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F%E5%81%9A%E8%BF%87%E6%B2%A1"><span class="toc-text">安全漏洞扫描做过没</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E5%B1%82TCP-IP%E5%8D%8F%E8%AE%AE"><span class="toc-text">4层TCP&#x2F;IP协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFffmpeg"><span class="toc-text">什么是ffmpeg</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8java%E7%BB%93%E5%90%88ffmpeg%E5%A6%82%E4%BD%95%E5%AF%B9%E8%A7%86%E9%A2%91%E8%BF%9B%E8%A1%8C%E6%B5%81%E5%AA%92%E4%BD%93%E5%A4%84%E7%90%86%E4%BB%A5%E5%8F%8A%E5%A4%9A%E7%A7%8D%E6%B8%85%E6%99%B0%E5%BA%A6%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-text">使用java结合ffmpeg如何对视频进行流媒体处理以及多种清晰度处理？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#xx%E5%85%AC%E5%8F%B8"><span class="toc-text">xx公司</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL%E6%9C%89%E5%87%A0%E7%A7%8D%E7%B4%A2%E5%BC%95%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-text">MySQL有几种索引，有哪些情况什么情况下会索引失效?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81"><span class="toc-text">java单例模式代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hashMap%E4%B8%8EhashTable%E5%8C%BA%E5%88%AB"><span class="toc-text">hashMap与hashTable区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jdk8%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">jdk8新特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E4%B8%AD%EF%BC%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">java中，抽象类和接口的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue%E4%B8%ADcomputed%E5%92%8Cwatch%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">vue中computed和watch的区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E6%A0%B7%E7%90%86%E8%A7%A3vue%E7%9A%84%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-text">怎样理解vue的单向数据流?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#v-if%E5%92%8C-v-show%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">v-if和 v-show的区别是什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOP%E6%8A%80%E6%9C%AF%E5%B8%B8%E7%94%A8%E4%BA%8E%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9"><span class="toc-text">AOP技术常用于哪些地方?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E6%83%85%E5%86%B5%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">Spring事务失效的情况有哪些?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%9F"><span class="toc-text">java中，什么是深拷贝与浅拷贝？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-StringBuffer-StringBuilder-%E5%8C%BA%E5%88%AB"><span class="toc-text">String StringBuffer StringBuilder 区别?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">实习面试过程中遇到的面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%9A%E4%BF%A1%E7%AC%AC%E4%B8%80%E8%BD%AE%E7%BA%BF%E4%B8%8A%E9%9D%A2%E8%AF%95"><span class="toc-text">亚信第一轮线上面试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8-Redis-%E8%A7%A3%E5%86%B3%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E4%B8%8B-Session-%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-text">1 使用 Redis 解决集群模式下 Session 共享问题是如何实现的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BC%93%E5%AD%98%E7%A9%BA%E5%AF%B9%E8%B1%A1%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F%EF%BC%88%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-text">2 缓存空对象解决缓存穿透是如何实现的？（如何解决缓存穿透问题）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E5%90%91redis%E5%86%99%E5%85%A5%E7%BC%93%E5%AD%98%EF%BC%9F%EF%BC%88%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8Credis%E7%9A%84%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F%EF%BC%89"><span class="toc-text">3 如何向redis写入缓存？（如何确保数据库和redis的双写一致性？）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%9F%BA%E4%BA%8E-Lua-%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E7%A7%92%E6%9D%80%E8%B5%84%E6%A0%BC%E9%AA%8C%E8%AF%81%EF%BC%8C%E8%A7%A3%E5%86%B3%E8%B6%85%E5%8D%96%E5%92%8C%E4%B8%80%E4%BA%BA%E4%B8%80%E5%8D%95%E9%97%AE%E9%A2%98%EF%BC%8Clua%E8%84%9A%E6%9C%AC%E6%98%AF%E6%80%8E%E6%A0%B7%E5%86%99%E7%9A%84%EF%BC%9F%E6%98%AF%E6%80%8E%E6%A0%B7%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-text">4 基于 Lua 脚本实现用户秒杀资格验证，解决超卖和一人一单问题，lua脚本是怎样写的？是怎样实现的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-JVM-%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-text">5 JVM 的内存结构？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-jvm%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%8B%E4%BC%9A%E8%A7%A6%E5%8F%91full-GC"><span class="toc-text">6 jvm什么时候下会触发full GC?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8redis%E6%A8%A1%E6%8B%9F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-text">7 如何使用redis模拟消息队列？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-sql%E4%BC%98%E5%8C%96%E7%9A%84%E6%AD%A5%E9%AA%A4%EF%BC%88%E9%87%8D%E9%9A%BE%E7%82%B9%EF%BC%89"><span class="toc-text">8 sql优化的步骤（重难点）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SELECT%E8%AF%AD%E5%8F%A5-%E8%AF%AD%E6%B3%95%E9%A1%BA%E5%BA%8F%EF%BC%9A"><span class="toc-text">SELECT语句 - 语法顺序：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SELECT%E8%AF%AD%E5%8F%A5-%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9A"><span class="toc-text">SELECT语句 - 执行顺序：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-SQL%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="toc-text">9 SQL优化策略</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%81%BF%E5%85%8D%E4%B8%8D%E8%B5%B0%E7%B4%A2%E5%BC%95%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-text">一、避免不走索引的场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%B0%BD%E9%87%8F%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8in-%E5%92%8Cnot-in%EF%BC%8C%E4%BC%9A%E5%AF%BC%E8%87%B4%E5%BC%95%E6%93%8E%E8%B5%B0%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F%E3%80%82%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-text">2. 尽量避免使用in 和not in，会导致引擎走全表扫描。如下：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%B0%BD%E9%87%8F%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8-or%EF%BC%8C%E4%BC%9A%E5%AF%BC%E8%87%B4%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E%E6%94%BE%E5%BC%83%E7%B4%A2%E5%BC%95%E8%BF%9B%E8%A1%8C%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F%E3%80%82%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-text">3. 尽量避免使用 or，会导致数据库引擎放弃索引进行全表扫描。如下：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%B0%BD%E9%87%8F%E9%81%BF%E5%85%8D%E5%9C%A8where%E6%9D%A1%E4%BB%B6%E4%B8%AD%E7%AD%89%E5%8F%B7%E7%9A%84%E5%B7%A6%E4%BE%A7%E8%BF%9B%E8%A1%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%81%E5%87%BD%E6%95%B0%E6%93%8D%E4%BD%9C%EF%BC%8C%E4%BC%9A%E5%AF%BC%E8%87%B4%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E%E6%94%BE%E5%BC%83%E7%B4%A2%E5%BC%95%E8%BF%9B%E8%A1%8C%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F%E3%80%82"><span class="toc-text">5.尽量避免在where条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E5%BD%93%E6%95%B0%E6%8D%AE%E9%87%8F%E5%A4%A7%E6%97%B6%EF%BC%8C%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8where-1-1%E7%9A%84%E6%9D%A1%E4%BB%B6%E3%80%82%E9%80%9A%E5%B8%B8%E4%B8%BA%E4%BA%86%E6%96%B9%E4%BE%BF%E6%8B%BC%E8%A3%85%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E4%BC%9A%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8%E8%AF%A5%E6%9D%A1%E4%BB%B6%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E%E4%BC%9A%E6%94%BE%E5%BC%83%E7%B4%A2%E5%BC%95%E8%BF%9B%E8%A1%8C%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F%E3%80%82%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-text">6. 当数据量大时，避免使用where 1&#x3D;1的条件。通常为了方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引进行全表扫描。如下：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-where%E6%9D%A1%E4%BB%B6%E4%BB%85%E5%8C%85%E5%90%AB%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%E9%9D%9E%E5%89%8D%E7%BD%AE%E5%88%97"><span class="toc-text">8. where条件仅包含复合索引非前置列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-1"><span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E9%80%A0%E6%88%90%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-text">9. 隐式类型转换造成不使用索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-2"><span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-order-by-%E6%9D%A1%E4%BB%B6%E8%A6%81%E4%B8%8Ewhere%E4%B8%AD%E6%9D%A1%E4%BB%B6%E4%B8%80%E8%87%B4%EF%BC%8C%E5%90%A6%E5%88%99order-by%E4%B8%8D%E4%BC%9A%E5%88%A9%E7%94%A8%E7%B4%A2%E5%BC%95%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F"><span class="toc-text">10. order by 条件要与where中条件一致，否则order by不会利用索引进行排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8hint%E4%BC%98%E5%8C%96%E8%AF%AD%E5%8F%A5"><span class="toc-text">11. 正确使用hint优化语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E3%80%81SELECT%E8%AF%AD%E5%8F%A5%E5%85%B6%E4%BB%96%E4%BC%98%E5%8C%96"><span class="toc-text">二、SELECT语句其他优化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%A2%9E%E5%88%A0%E6%94%B9-DML-%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96"><span class="toc-text">三、增删改 DML 语句优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6%E4%BC%98%E5%8C%96"><span class="toc-text">四、查询条件优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%BB%BA%E8%A1%A8%E4%BC%98%E5%8C%96"><span class="toc-text">五、建表优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%99%BA%E6%99%BA%E4%BA%BA%E9%9D%A2%E8%AF%95"><span class="toc-text">中智智人面试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-mysql%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%EF%BC%9F%E7%B4%A2%E5%BC%95%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="toc-text">1 mysql中，什么是索引？索引什么情况下会失效？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-hashmap%E5%92%8Ctreemap%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">2 hashmap和treemap的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%89"><span class="toc-text">3 二叉树的遍历（数据结构）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%88%E8%A6%81%E6%B1%82%E8%83%BD%E7%9B%B4%E6%8E%A5%E6%89%8B%E5%86%99%EF%BC%89"><span class="toc-text">4 冒泡排序（要求能直接手写）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-math-round-1-5-%E7%9A%84%E5%80%BC%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">6 math.round(-1.5)的值是多少？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F%EF%BC%9F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F%E7%BC%93%E5%AD%98%E4%B8%89%E5%85%84%E5%BC%9F"><span class="toc-text">7 redis的持久化方式？数据类型？什么是非关系型数据库？缓存三兄弟</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F%E6%80%8E%E4%B9%88%E7%A6%81%E7%94%A8%E5%8F%8D%E5%B0%84%EF%BC%9F"><span class="toc-text">8 什么是反射？怎么禁用反射？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">9 抽象类的作用？抽象类和接口的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-final%E5%8F%AF%E4%BB%A5%E5%92%8Cabstract%E8%BF%9E%E7%94%A8%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">10 final可以和abstract连用吗？为什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-final%E5%8F%AF%E4%BB%A5%E5%92%8Cstatic%E8%BF%9E%E7%94%A8%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">11 final可以和static连用吗？为什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81redis%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F"><span class="toc-text">12 如何保证redis和数据库的双写一致性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-redis%E7%9A%84%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">13 redis的过期删除策略有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-redis%E4%B8%BB%E8%A6%81%E7%94%A8%E6%9D%A5%E5%B9%B2%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">14 redis主要用来干什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E7%9B%8A%E6%A0%87%E5%87%86"><span class="toc-text">普益标准</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-springboot%E5%92%8Cspringcloud%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1 springboot和springcloud的区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-mybatis%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F"><span class="toc-text">2 mybatis是做什么的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%A6%82%E4%BD%95%E6%89%BE%E5%87%BA%E5%BD%93%E5%89%8DCPU%E5%8D%A0%E7%94%A8%E6%9C%80%E9%AB%98%E7%9A%84%E7%A8%8B%E5%BA%8F%EF%BC%9F"><span class="toc-text">3 linux系统中如何找出当前CPU占用最高的程序？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XX%E5%85%AC%E5%8F%B8%E9%9D%A2%E8%AF%95"><span class="toc-text">XX公司面试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">创建线程池的几种方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E4%B8%AD%EF%BC%8C%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">java中，过滤器和拦截器的作用与区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E4%B8%AD%EF%BC%8CList%E8%BD%ACArray%E8%B0%83%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%EF%BC%9FArray%E8%BD%ACList%E8%B0%83%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">java中，List转Array调用什么方法？Array转List调用什么方法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ES%E5%92%8CMySQL%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E5%90%8C%E6%AD%A5"><span class="toc-text">ES和MySQL中的数据如何同步</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E5%BA%94%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1%E7%9A%84%EF%BC%9F"><span class="toc-text">java应用多线程之间是如何进行通信的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E7%BC%96%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%9C%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E9%9D%A2%E5%8A%A0%E4%BB%80%E4%B9%88%E7%AC%A6%E5%8F%B7%EF%BC%8C%E5%88%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6%E5%B0%86%E4%B8%8D%E8%A2%AB%E5%A4%84%E7%90%86"><span class="toc-text">在编程中，在字符串前面加什么符号，则字符串中的转义字符将不被处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%AC%AC%E4%BA%8C%E7%B1%BB%E4%B8%A2%E5%A4%B1%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">如何解决第二类丢失更新问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fail-fast%E6%9C%BA%E5%88%B6%E5%92%8Cfail-safe%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">fail-fast机制和fail-safe机制的区别？</span></a></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/breeze/1d13ce0d.html" title="WYDG-产品目录列表-20200506"><img src="/img/photo-1653549892896-dde02867edee.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="WYDG-产品目录列表-20200506"></a><div class="content"><a class="title" href="/breeze/1d13ce0d.html" title="WYDG-产品目录列表-20200506">WYDG-产品目录列表-20200506</a><time datetime="2025-04-13T05:43:05.000Z" title="发表于 2025-04-13 13:43:05">2025-04-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/breeze/6f268337.html" title="雨雀文件下载"><img src="/img/premium_photo-1695185954894-e9382c6f4da8.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="雨雀文件下载"></a><div class="content"><a class="title" href="/breeze/6f268337.html" title="雨雀文件下载">雨雀文件下载</a><time datetime="2024-05-22T12:25:08.000Z" title="发表于 2024-05-22 20:25:08">2024-05-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/breeze/7832219d.html" title="十万字面试总结"><img src="/img/photo-1692708632140-ee01624d558d.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="十万字面试总结"></a><div class="content"><a class="title" href="/breeze/7832219d.html" title="十万字面试总结">十万字面试总结</a><time datetime="2024-02-29T02:50:00.000Z" title="发表于 2024-02-29 10:50:00">2024-02-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/breeze/7ae0ca37.html" title="Redis_30道经典面试题"><img src="/img/photo-1653549892896-dde02867edee.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Redis_30道经典面试题"></a><div class="content"><a class="title" href="/breeze/7ae0ca37.html" title="Redis_30道经典面试题">Redis_30道经典面试题</a><time datetime="2024-02-29T02:45:00.000Z" title="发表于 2024-02-29 10:45:00">2024-02-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/breeze/2a548e97.html" title="面试实战"><img src="/img/photo-1653549892896-dde02867edee.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="面试实战"></a><div class="content"><a class="title" href="/breeze/2a548e97.html" title="面试实战">面试实战</a><time datetime="2024-02-29T02:43:59.000Z" title="发表于 2024-02-29 10:43:59">2024-02-29</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/img/photo-1653549892896-dde02867edee.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 <i id="heartbeat" class="fa fas fa-heartbeat"></i> 清风</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></head></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script src="/js/timing.js"></script><script id="canvas_nest" defer color="255,0,255" opacity="0.7" zindex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!0,document.body.addEventListener("input",POWERMODE)</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="天枢,天璇,天玑,天权,玉衡,开阳,瑶光" data-fontsize="15px" data-random="true" async></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>