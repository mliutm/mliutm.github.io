<!DOCTYPE html><html class="hide-aside" lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>java8新特性 | 清风</title><meta name="author" content="清风"><meta name="copyright" content="清风"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java8新特性知识大纲 Java8新特性介绍【了解】 接口中方法（抽象、default、static）【掌握】 函数式接口【掌握】 Lambda表达式【重点】 Lambda表达式的作用域【了解】 方法引用（lambda的使用）【掌握】 Stream流【重点】 流式编程 Optional类【了解】 时间日期API【了解】  1 Java8新特性介绍Java 8 (又称为 jdk 1.8) 是 Ja"><meta property="og:type" content="article"><meta property="og:title" content="java8新特性"><meta property="og:url" content="https://mliutm.github.io/breeze/f41870e2.html"><meta property="og:site_name" content="清风"><meta property="og:description" content="Java8新特性知识大纲 Java8新特性介绍【了解】 接口中方法（抽象、default、static）【掌握】 函数式接口【掌握】 Lambda表达式【重点】 Lambda表达式的作用域【了解】 方法引用（lambda的使用）【掌握】 Stream流【重点】 流式编程 Optional类【了解】 时间日期API【了解】  1 Java8新特性介绍Java 8 (又称为 jdk 1.8) 是 Ja"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://mliutm.github.io/img/photo-1692708632140-ee01624d558d.jpg"><meta property="article:published_time" content="2023-10-15T15:56:12.000Z"><meta property="article:modified_time" content="2024-01-13T01:15:18.265Z"><meta property="article:author" content="清风"><meta property="article:tag" content="java8新特性"><meta property="article:tag" content="strean流"><meta property="article:tag" content="Lambda"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://mliutm.github.io/img/photo-1692708632140-ee01624d558d.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://mliutm.github.io/breeze/f41870e2.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,top_n_per_article:1,unescape:!1,languages:{hits_empty:"找不到您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!1,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"java8新特性",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-01-13 09:15:18"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,a){0!==a&&(a=864e5*a,t={value:t,expiry:(new Date).getTime()+a},localStorage.setItem(e,JSON.stringify(t)))},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!((new Date).getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=o=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.getCSS=(o,n=!1)=>new Promise((t,e)=>{const a=document.createElement("link");a.rel="stylesheet",a.href=o,n&&(a.id=n),a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">169</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">82</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/img/photo-1692708632140-ee01624d558d.jpg)"><nav id="nav"><span id="blog-info"><a href="/" title="清风"><span class="site-name">清风</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java8新特性</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-15T15:56:12.000Z" title="发表于 2023-10-15 23:56:12">2023-10-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-13T01:15:18.265Z" title="更新于 2024-01-13 09:15:18">2024-01-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/javaSE/">javaSE</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="java8新特性"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Java8新特性"><a href="#Java8新特性" class="headerlink" title="Java8新特性"></a>Java8新特性</h2><h3 id="知识大纲"><a href="#知识大纲" class="headerlink" title="知识大纲"></a>知识大纲</h3><ul><li>Java8新特性介绍【了解】</li><li>接口中方法（抽象、default、static）【掌握】</li><li>函数式接口【掌握】</li><li><strong>Lambda表达式【重点】</strong></li><li><strong>Lambda表达式的作用域【了解】</strong></li><li><strong>方法引用（lambda的使用）【掌握】</strong></li><li><strong>Stream流【重点】</strong> 流式编程</li><li>Optional类【了解】</li><li>时间日期API【了解】</li></ul><h3 id="1-Java8新特性介绍"><a href="#1-Java8新特性介绍" class="headerlink" title="1 Java8新特性介绍"></a>1 Java8新特性介绍</h3><p>Java 8 (又称为 jdk 1.8) 是 Java 语言开发的一个<strong>主要版本</strong>。 Oracle 公司于 2014 年 3 月 18 日发布 Java 8 ，它支持函数式编程，新的 JavaScript 引擎，新的日期 API，新的Stream API 等。</p><h4 id="1-1-主要新特性"><a href="#1-1-主要新特性" class="headerlink" title="1.1 主要新特性"></a>1.1 主要新特性</h4><ol><li><p>Lambda 表达式 − Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中）。</p></li><li><p>方法引用 − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</p></li><li><p>默认方法 − 默认方法就是一个在接口里面有了一个实现的方法。</p></li><li><p>Nashorn, JavaScr新工具 − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。</p></li><li><p>Stream API −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。</p></li><li><p>Date Time API − 加强对日期与时间的处理。</p></li><li><p>Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</p></li><li><p>ipt 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。</p></li></ol><h3 id="2-接口的默认方法"><a href="#2-接口的默认方法" class="headerlink" title="2 接口的默认方法"></a>2 接口的默认方法</h3><p>接口中的默认方法主要就是接口这种语法结构本身的语法特点，所以大家根据特点和提示熟悉就好，在以后的应用中慢慢去感受它的好处。</p><h4 id="2-1-传统的方法（之前的）"><a href="#2-1-传统的方法（之前的）" class="headerlink" title="2.1 传统的方法（之前的）"></a>2.1 传统的方法（之前的）</h4><p>在Java8之前Java中接口里面的方法默认都是public abstract 修饰的抽象方法并且没有方法体；</p><h4 id="2-2-static方法"><a href="#2-2-static方法" class="headerlink" title="2.2 static方法"></a>2.2 static方法</h4><p>1、使用static修饰接口中的方法并且必须有方法体；</p><p>2、接口的static方法只能够被接口本身调用；接口名.方法名（…）；</p><p>3、接口的static方法不能够被子接口继承；</p><p>4、接口的static方法不能够被实现类覆写及直接调用；</p><h4 id="2-3-default方法"><a href="#2-3-default方法" class="headerlink" title="2.3 default方法"></a>2.3 default方法</h4><p>在接口中可定义一个使用<strong>default修饰有方法体的方法，</strong>接口中可以对这个方法提供默认的一种实现。</p><ol><li><p>使用default修饰接口中的方法并且必须<strong>有方法体；</strong></p></li><li><p>接口的default方法不能够被<strong>接口本身调用，需要接口的实例（实现类对象）来调用；</strong></p></li><li><p>接口的default方法可以被子<strong>接口继承、覆写或者直接调用；</strong></p></li><li><p>接口的default方法<strong>可以被实现类覆写及直接调用；</strong></p></li><li><p>在接口中,经过static或者default修饰的方法必须有方法体;</p></li><li><p>static修饰的方法调用方式为接口名.方法名</p></li><li><p>default修饰的方法必须是<strong>实现类的对象调用</strong></p></li><li><p><strong>static修饰的方法不能被子接口继承,default修饰的方法可以被子接口继承，并复写方法,就可以创建子接口实现类对象进行调用</strong></p></li></ol><h3 id="3-函数式接口"><a href="#3-函数式接口" class="headerlink" title="3 函数式接口"></a>3 函数式接口</h3><h4 id="3-1-什么是函数式接口"><a href="#3-1-什么是函数式接口" class="headerlink" title="3.1 什么是函数式接口"></a>3.1 什么是函数式接口</h4><p>函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。函数式接口可以被隐式转换为lambda表达式。</p><p>可以使用注解@FunctionalInterface标记该接口为函数式接口</p><h4 id="3-2-函数式接口API"><a href="#3-2-函数式接口API" class="headerlink" title="3.2 函数式接口API"></a>3.2 函数式接口API</h4><p>JDK 1.8之前已有的函数式接口:</p><p>java.lang.Runnable</p><p>java.util.concurrent.Callable</p><p>java.security.PrivilegedAction</p><p>java.util.Comparator</p><p>java.io.FileFilter</p><p>java.nio.file.PathMatcher</p><p>java.lang.reflect.InvocationHandler</p><p>java.beans.PropertyChangeListener</p><p>java.awt.event.ActionListener</p><p>javax.swing.event.ChangeListener</p><p>JDK 1.8 新增加的函数接口：</p><p>java.util.function 此包中包含了很多类，用来支持 Java的 函数式编程</p><h4 id="3-3-函数式接口注解"><a href="#3-3-函数式接口注解" class="headerlink" title="3.3 函数式接口注解"></a>3.3 函数式接口注解</h4><p>@FunctionalInterface</p><p>我们在函数式接口上面加上此注解后，里面就只能够有一个抽象方法了，当然不加此注解且只有一个抽象方法的接口也是函数式接口，只是没有限定提示而已。</p><h3 id="4-Lambda表达式"><a href="#4-Lambda表达式" class="headerlink" title="4 Lambda表达式"></a>4 Lambda表达式</h3><h4 id="4-1什么是Lambda表达式"><a href="#4-1什么是Lambda表达式" class="headerlink" title="4.1什么是Lambda表达式"></a>4.1什么是Lambda表达式</h4><p>简单来说：可以看成是对匿名内部类的简写，使用Lambda表达式时，<strong>接口必须是函数式接口</strong>。</p><h4 id="4-2-Lambda表达式的语法"><a href="#4-2-Lambda表达式的语法" class="headerlink" title="4.2 Lambda表达式的语法"></a>4.2 Lambda表达式的语法</h4><p><strong>基本语法：</strong></p><p>​	&lt;函数式接口&gt; &lt;变量名&gt; &#x3D; (参数1，参数2…) -&gt; {</p><p>​ &#x2F;&#x2F;方法体</p><p>}</p><p><strong>特点说明：</strong></p><p>(参数1，参数2…)表示参数列表；-&gt;表示连接符；{}内部是方法体<br>1、&#x3D;右边的类型会根据左边的函数式接口类型自动推断；<br>2、如果形参列表为空，只需保留()；<br>3、如<strong>果形参只有1个，()可以省略，只需要参数的名称即可；</strong><br>4、<strong>如果执行语句只有1句，且无返回值，{}可以省略，若有返回值，则若想省去{}，则必须同时省略return，且执行语句也保证只有1句；</strong><br>5、形参列表的数据类型会自动推断；<br>6、lambda不会生成一个单独的内部类文件；<br>7、lambda表达式若访问了局部变量，则局部变量必须是final的，若是局部变量没有加final关键字，系统会自动添加，此后再修改该局部变量，会报错；</p><h4 id="4-3-学习过程（一个案例学会Lambda）"><a href="#4-3-学习过程（一个案例学会Lambda）" class="headerlink" title="4.3 学习过程（一个案例学会Lambda）"></a>4.3 学习过程（一个案例学会Lambda）</h4><h5 id="4-3-1-一个类实现一个接口基本写法"><a href="#4-3-1-一个类实现一个接口基本写法" class="headerlink" title="4.3.1 一个类实现一个接口基本写法"></a>4.3.1 一个类实现一个接口基本写法</h5><p>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2)</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterfaceImpl</span> <span class="keyword">implements</span> <span class="title class_">MyInterface</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> num1+num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyInterfaceImpl</span> <span class="variable">mf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInterfaceImpl</span>();</span><br><span class="line">    System.out.println(mf.sum(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-3-2-匿名内部类的写法"><a href="#4-3-2-匿名内部类的写法" class="headerlink" title="4.3.2 匿名内部类的写法"></a>4.3.2 匿名内部类的写法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyInterface</span> <span class="variable">mf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInterface</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> num1+num2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(mf.sum(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-2-3-使用Lambda写法一：常规写法"><a href="#4-2-3-使用Lambda写法一：常规写法" class="headerlink" title="4.2.3 使用Lambda写法一：常规写法"></a>4.2.3 使用Lambda写法一：常规写法</h5><p>我们可以看成是把函数式接口中唯一的实现方法的核心： 方法列表和方法体抽取出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//砖石符号-&gt;左边是参数  右边是实现</span></span><br><span class="line"><span class="type">MyInterface</span> <span class="variable">mf</span> <span class="operator">=</span> (<span class="type">int</span> num1,<span class="type">int</span> num2)-&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="4-3-4-使用Lambda写法二：两个参数有返回值的简写"><a href="#4-3-4-使用Lambda写法二：两个参数有返回值的简写" class="headerlink" title="4.3.4 使用Lambda写法二：两个参数有返回值的简写"></a>4.3.4 使用Lambda写法二：两个参数有返回值的简写</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.方法体只有一句可以省略&#123;&#125;</span></span><br><span class="line"><span class="comment">* 2.如果有返回值  可以省略return</span></span><br><span class="line"><span class="comment">* 3.参数列表类型可以省略掉</span></span><br><span class="line"><span class="comment">* 4.如果参数只有一个左边()小括号可以省略</span></span><br><span class="line"><span class="comment">* /</span></span><br><span class="line"><span class="comment">MyInterface mf = (num1,num2)-&gt;num1+num2;</span></span><br><span class="line"><span class="comment">System.out.println(mf.sum(10, 12));</span></span><br></pre></td></tr></table></figure><h5 id="4-3-5-使用Lambda写法三：一个参数没有返回值的简写"><a href="#4-3-5-使用Lambda写法三：一个参数没有返回值的简写" class="headerlink" title="4.3.5 使用Lambda写法三：一个参数没有返回值的简写"></a>4.3.5 使用Lambda写法三：一个参数没有返回值的简写</h5><p>测试如果只有一个参数的简写</p><p>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Lambda常规写法*/</span></span><br><span class="line"><span class="type">MyInterface</span> <span class="variable">mi</span> <span class="operator">=</span> (String str)-&gt;&#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*Lambda简写*/</span></span><br><span class="line"><span class="type">MyInterface</span> <span class="variable">mi2</span> <span class="operator">=</span> str-&gt;System.out.println(str);</span><br><span class="line">mi2.print(<span class="string">&quot;Hello Lambda&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="4-3-6-使用Lambda写法四：没有参数的简写"><a href="#4-3-6-使用Lambda写法四：没有参数的简写" class="headerlink" title="4.3.6 使用Lambda写法四：没有参数的简写"></a>4.3.6 使用Lambda写法四：没有参数的简写</h5><p>测试如果函数式接口中的方法没有参数</p><p>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Lambda常规写法</span></span><br><span class="line"><span class="type">MyInterface</span> <span class="variable">mi</span> <span class="operator">=</span> ()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//简写[大括号不写代码没有什么意义]</span></span><br><span class="line"><span class="type">MyInterface</span> <span class="variable">mi2</span> <span class="operator">=</span> ()-&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-Lambda-作用域"><a href="#5-Lambda-作用域" class="headerlink" title="5 Lambda 作用域"></a>5 Lambda 作用域</h3><p>在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。但如果访问局部变量，要求局部变量必须是final修饰的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">9</span>;<span class="comment">//要求此次需要时final修饰</span></span><br><span class="line">        <span class="type">MyInterface</span> <span class="variable">mf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInterface</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                <span class="keyword">return</span> num1+num2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：上面代码中一旦匿名内部类中使用了i,则第3行的i会自动被编辑为final的</p><p>下面我们可以看到使用Lambda表达式和上面一样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">        <span class="type">MyInterface</span> <span class="variable">mf</span> <span class="operator">=</span> (num1,num2)-&gt;&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            <span class="keyword">return</span> num1+num2;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>lambda：【重点】</strong></p><blockquote><p>概念：就是对函数式接口匿名内部类的简写</p><p>作用：简化代码【简化为方法形参和方法体】</p><p>使用：<br>语法：<br>函数式接口 变量名 &#x3D; (参数1，参数2…) -&gt; {<br>&#x2F;&#x2F;方法体<br>}<br>(参数1，参数2…)表示参数列表；<br>-&gt;表示连接符；连接符号后是方法体<br>{}内部是方法体<br>特点说明：</p><ol><li>&#x3D;右边的类型会根据左边的函数式接口类型自动推断；</li><li>如果形参列表为空，只需保留()；</li><li>如果形参只有1个，()可以省略，只需要参数的名称即可；</li><li>如果执行语句只有1句，且无返回值，{}可以省略，</li><li>若有返回值，则若想省去{}，则必须同时省略return，且执行语句也保证只有1句；</li><li>形参列表的数据类型会自动推断；</li><li>lambda不会生成一个单独的内部类文件；</li><li>lambda表达式若访问了局部变量，则局部变量必须是final的，</li><li>若是局部变量没有加final关键字，系统会自动添加，此后在修改该局部变量，会报错；</li></ol><p>lambda中方法引用：【掌握】</p><p>4.1. 静态方法引用【掌握】<br>语法 ： 类名::静态方法名<br>注意事项：<br>被引用的静态方法参数列表和函数式接口中抽象方法的参数一致！！<br>接口的抽象方法没有返回值，引用的静态方法可以有返回值也可以没有<br>接口的抽象方法有返回值，引用的静态方法必须有相同类型的返回值！！<br>由于满足抽象参数列表与引用参数列表相同，所以可以写成静态方法引用的格式</p><p>4.2. 实例方法引用【掌握】<br>语法 ： 对象名::非静态方法名<br>注意事项：<br>被引用的实例方法参数列表和函数式接口中抽象方法的参数一致！！<br>接口的抽象方法没有返回值，引用的实例方法可以有返回值也可以没有<br>接口的抽象方法有返回值，引用的实例方法必须有相同类型的返回值！！</p><p>4.3. 构造方法引用【掌握】<br>语法 ：类名::new<br>注意事项：<br>被构造方法与函数式接口的抽象方法参数列表一致</p></blockquote><h3 id="6-方法引用"><a href="#6-方法引用" class="headerlink" title="6 方法引用"></a>6 方法引用</h3><h4 id="6-1-构造方法引用"><a href="#6-1-构造方法引用" class="headerlink" title="6.1 构造方法引用"></a>6.1 构造方法引用</h4><p>1、准备一个一个Person类，提供一个两个参数的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student [id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、准备一个创建Person对象的工厂函数式接口，提供一个获得Person对象的抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PersonFactory</span>&#123;</span><br><span class="line">    Person <span class="title function_">creatPerson</span><span class="params">(<span class="type">int</span> id,String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、使用匿名内部类的方式创建一个工厂的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">PersonFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonFactory</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Person <span class="title function_">creatPerson</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">11</span>,<span class="string">&quot;小猪佩奇&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、使用Lambda表达式简写一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PersonFactory</span> <span class="variable">factory</span> <span class="operator">=</span> (id,name)-&gt;<span class="keyword">new</span> <span class="title class_">Person</span>(id,name);</span><br></pre></td></tr></table></figure><p>5、使用Lambda表达式简写二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PersonFactory</span> <span class="variable">factory</span> <span class="operator">=</span> Person::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure><h4 id="6-2-静态方法引用"><a href="#6-2-静态方法引用" class="headerlink" title="6.2 静态方法引用"></a>6.2 静态方法引用</h4><ol><li>准备一个函数式接口，提供一个解析字符串为int的方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PersonFactory</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">parse</span><span class="params">(String str)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匿名内部类的写法</span></span><br><span class="line"><span class="type">PersonFactory</span> <span class="variable">pf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonFactory</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">parse</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Lambda常规写法</span></span><br><span class="line"><span class="type">PersonFactory</span> <span class="variable">factory</span> <span class="operator">=</span> str-&gt;Integer.parseInt(str);</span><br><span class="line"><span class="comment">//Lambda静态方法引用</span></span><br><span class="line"><span class="type">PersonFactory</span> <span class="variable">fp</span> <span class="operator">=</span> Integer::parseInt;</span><br></pre></td></tr></table></figure><h4 id="6-3-实例方法引用"><a href="#6-3-实例方法引用" class="headerlink" title="6.3 实例方法引用"></a>6.3 实例方法引用</h4><p>1、了解Java1.8提供了一个断言型函数式接口Function，接受两个参数【判断及为断言】</p><p>2、匿名内部类方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello.mliutm&quot;</span>;</span><br><span class="line">    <span class="comment">//匿名内部类的方式</span></span><br><span class="line">    Function&lt;String,Boolean&gt; func1 = <span class="keyword">new</span> <span class="title class_">Function</span>&lt;String, Boolean&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Boolean <span class="title function_">apply</span><span class="params">(String t)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> t.endsWith(<span class="string">&quot;mliutm&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">test</span> <span class="operator">=</span> test(func1,str);</span><br><span class="line">    System.out.println(test);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Function&lt;String,Boolean&gt; f,String str)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f.apply(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、Lambda表达式常规写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello.mliutm&quot;</span>;</span><br><span class="line">    <span class="comment">//匿名内部类的方式</span></span><br><span class="line">    Function&lt;String,Boolean&gt; func1 = t-&gt;str.endsWith(<span class="string">&quot;mliutm&quot;</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">test</span> <span class="operator">=</span> test(func1,str);</span><br><span class="line">    System.out.println(test);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Function&lt;String,Boolean&gt; f,String str)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f.apply(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、Lambda表达式简写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello.mliutm&quot;</span>;</span><br><span class="line">    <span class="comment">//匿名内部类的方式</span></span><br><span class="line">    Function&lt;String,Boolean&gt; func1 = str::endsWith;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">test</span> <span class="operator">=</span> test(func1,str);</span><br><span class="line">    System.out.println(test);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Function&lt;String,Boolean&gt; f,String str)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f.apply(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-Stream流"><a href="#7-Stream流" class="headerlink" title="7 Stream流"></a>7 Stream流</h3><p>在Java8之前，通常用 fori、for each 或者 Iterator 迭代来重排序合并数据，或者通过重新定义 Collections.sorts的 Comparator 方法来实现，这两种方式对 大数量系统来说，效率不理想。</p><p>​</p><p>Java8 中添加了一个新的接口类 Stream，相当于高级版的 <strong>Iterator</strong>，通过Lambda 表达式对集合进行各种非常便利、高效的聚合操作（Aggregate Operation），或者大批量数据操作 (Bulk Data Operation）。Stream不仅可以通过串行的方式实现数据操作，还可以通过并行的方式处理大批量数据，提高数据的处理效率。</p><p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。</p><ol><li><p>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。</p><p>select * from user where age &gt;30</p><p>流水线：</p><p>空瓶子–》灌水—》盖盖子–》贴标签 —&gt;一瓶农夫三拳</p></li><li><p>Stream API可以极大提高Java程序员的生产力，<strong>让程序员写出高效率、干净、简洁的代码。</strong></p></li><li><p>这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。</p></li><li><p>元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。</p></li></ol><h4 id="7-1-什么是-Stream？"><a href="#7-1-什么是-Stream？" class="headerlink" title="7.1 什么是 Stream？"></a>7.1 什么是 Stream？</h4><blockquote><p>在 Java 8 中，Stream 流是一种流式处理数据的技术。它可以让你以一种更加简洁、高效的方式来操作集合（Collection），例如对列表进行过滤、分组、排序、映射等操作。</p><p>Stream 流可以看做是一种高级的 Iterator，它提供了一种流式操作数据的方式。使用 Stream 流可以充分利用现代多核 CPU 的优势，将大规模数据集进行并行处理。</p><p>Stream 流的操作可以分为中间操作和终端操作两种类型。中间操作包括 filter、map、distinct、limit、sorted 等方法，可以作为 Stream 流的链式调用；而终端操作包括 forEach、toArray、reduce、collect 等方法，会触发 Stream 流的计算。</p><p>通过使用 Stream 流，我们可以写出更加简洁易读的代码，提高代码的可读性和可维护性。</p></blockquote><p>Stream（流）是一个来自数据源的元素队列并支持聚合操作</p><ol><li><p>&lt;strong元素队列&lt; strong&#x3D;””&gt;元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。&lt;&#x2F;strong元素队列&lt;&gt;</p></li><li><p>数据源 流的来源。 可以是集合，数组，I&#x2F;O channel（nio new IO非阻塞式IO）， 产生器generator 等。</p></li><li><p>聚合操作 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。</p><p>和以前的Collection操作不同， Stream操作还有两个基础的特征：</p></li><li><p>Pipelining: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</p></li><li><p>内部迭代： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。</p></li></ol><h4 id="7-2-生成流"><a href="#7-2-生成流" class="headerlink" title="7.2 生成流"></a>7.2 生成流</h4><p>在 Java 8 中, 集合接口有两个方法来生成流：</p><p><strong>stream()</strong> − 为集合创建串行流。</p><p><strong>parallelStream()</strong> − 为集合创建并行流。</p><h4 id="7-3-常用方法"><a href="#7-3-常用方法" class="headerlink" title="7.3 常用方法"></a>7.3 常用方法</h4><h5 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h5><p>Stream 提供了新的方法 ‘forEach’ 来迭代流中的每个数据。以下代码片段使用 forEach 输出了10个随机数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>); </span><br><span class="line">list.stream().forEach(System.out::println);</span><br></pre></td></tr></table></figure><h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><p>map 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>); </span><br><span class="line"><span class="comment">// 获取对应的平方数 </span></span><br><span class="line">numbers.stream().map( i -&gt; i*i).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h5 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h5><p>filter 方法用于通过设置的条件过滤出元素。以下代码片段使用 filter 方法过滤出空字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;efg&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>); </span><br><span class="line"><span class="comment">//过滤取出每一个不为空的元素</span></span><br><span class="line">strings.stream().filter(string -&gt; !string.isEmpty()).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h5 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h5><p>limit 方法用于获取指定数量的流。 以下代码片段使用 limit 方法打印出 10 条数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="comment">//从随机流中获取十个随机数：并输出结果</span></span><br><span class="line">random.ints().limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h5 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h5><p>sorted 方法用于对流进行排序。以下代码片段使用 sorted 方法对输出的 10 个随机数进行排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(); </span><br><span class="line"><span class="comment">//获取十个随机数，并排序</span></span><br><span class="line">random.ints().limit(<span class="number">10</span>).sorted().forEach(System.out::println);</span><br></pre></td></tr></table></figure><h5 id="并行（parallel）流及串行流的区别-了解"><a href="#并行（parallel）流及串行流的区别-了解" class="headerlink" title="并行（parallel）流及串行流的区别-了解"></a>并行（parallel）流及串行流的区别-了解</h5><p>parallelStream 是流并行处理程序的代替方法。以下实例我们使用 parallelStream 来输出空字符串的数量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;f&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;efg&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>); </span><br><span class="line"><span class="comment">// 获取空字符串的数量 </span></span><br><span class="line">strings.parallelStream().limit(<span class="number">5</span>).forEach(System.out::println);<span class="comment">//并行流随机获取【效率高】</span></span><br><span class="line">strings.stream().limit(<span class="number">5</span>).forEach(System.out::println);<span class="comment">//串行流：有序获取</span></span><br></pre></td></tr></table></figure><p>我们可以很容易的在顺序运行和并行直接切换。</p><hr><h5 id="Collectors"><a href="#Collectors" class="headerlink" title="Collectors"></a>Collectors</h5><p>Collectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors 可用于返回列表或字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;efg&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>); </span><br><span class="line"><span class="comment">//归约操作：操作元素之后返回新的集合</span></span><br><span class="line">List&lt;String&gt; filtered = strings.stream().filter(string-&gt; !string.isEmpty()).collect(Collectors.toList()); </span><br><span class="line">System.out.println(<span class="string">&quot;筛选列表: &quot;</span> + filtered); </span><br><span class="line"><span class="comment">//归约操作：操作元素之后元素之间用,号分割。合并了一个字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">mergedString</span> <span class="operator">=</span> strings.stream().filter(string-&gt; !string.isEmpty()).collect(Collectors.joining(<span class="string">&quot;, &quot;</span>)); </span><br><span class="line">System.out.println(<span class="string">&quot;合并字符串: &quot;</span> + mergedString);</span><br><span class="line"><span class="comment">//归约操作：统计获取空字符串的数量 </span></span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> strings.stream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure><blockquote><p><strong>stream操作集合得到了一个新的集合，原集合的数据会发生改变吗？</strong></p><p>在Java中，Stream操作并不会直接修改原始集合的数据。Stream操作是基于函数式编程的概念，其主要作用是对集合进行转换、过滤和聚合等操作，而不会修改原始集合的内容。</p><p>当你对一个集合应用Stream操作时，它会返回一个新的Stream对象，其中包含根据操作逻辑产生的新元素。原始集合的数据仍然保持不变。</p><p>如果你需要修改原始集合的数据，可以使用其他方法，例如使用普通的for循环或forEach方法来遍历集合并修改元素。但请注意，在多线程环境下修改集合可能会导致并发问题，请谨慎处理。</p></blockquote><h3 id="8-Optional-类"><a href="#8-Optional-类" class="headerlink" title="8 Optional 类"></a>8 Optional 类</h3><p>Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p><p>Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p><p>Optional 类的引入很好的解决空指针异常</p><p>善用Optional可以使我们代码中很多繁琐、丑陋的设计变得十分优雅。</p><h4 id="8-1-声明"><a href="#8-1-声明" class="headerlink" title="8.1 声明"></a>8.1 声明</h4><p>以下是一个 java.util.Optional<t>类的声明：public final class Optional<t>extends Object</t></t></p><p>Optional容器类常用方法：</p><p><strong>Optional.of(T t):创建要给Optional实例</strong></p><p><strong>Optional.empty():创建一个空的Optional实例</strong></p><p><strong>Optional.ofNullable(T t):若t不为null,创建Optional实例，否则创建空的实例</strong></p><p>isPresent():判断是否包含值</p><p>orElse(T t)：如果调用对象包含值，返回该值，否则返回t</p><p>orElseGet(Supplier s):如果调用对象包含值，返回该值，否则返回s获取的值</p><p>map(function f):如果有值对其处理，并发挥处理后的Optional ,否则返回Optional.empty()</p><p>flatMap(Function mapper):与map类似，要求返回值必须是Optional</p><h4 id="8-2-Optional-实例"><a href="#8-2-Optional-实例" class="headerlink" title="8.2 Optional 实例"></a>8.2 Optional 实例</h4><p>我们可以通过以下实例来更好的了解 Optional 类的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以往的判断方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mytest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> getPwd(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getPwd</span><span class="params">(User u)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;unknow&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> u.getPassword();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引入Optional错误的判断方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getPwd</span><span class="params">(User u)</span>&#123;</span><br><span class="line">    Optional&lt;User&gt; optional = Optional.ofNullable(u);</span><br><span class="line">    <span class="keyword">if</span>(!optional.isPresent())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;unknow&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> optional.get().getPassword();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的判断方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getPwd</span><span class="params">(User u)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(u)</span><br><span class="line">        .map(user-&gt;user.getPassword())</span><br><span class="line">        .orElse(<span class="string">&quot;unknow&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-日期时间-API-了解"><a href="#9-日期时间-API-了解" class="headerlink" title="9 日期时间 API-了解"></a>9 日期时间 API-了解</h3><p><em><strong>*Java 8通过发布新的 API (JSR 310)来进一步加强对日期与时间的处理。在旧版的 Java 中，日期时间 API 存在诸多问题，其中有：*</strong></em></p><ol><li><p>非线程安全 − java.util.Date 是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一。</p></li><li><p>设计很差 − Java的日期&#x2F;时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义。java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身就是一个非常糟糕的设计。</p></li><li><p>时区处理麻烦 − 日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有的问题。</p></li><li><p>Java 8 在 java.time 包下提供了很多新的 API。以下为两个比较重要的 API：</p></li><li><p>Local(本地) − 简化了日期时间的处理，没有时区的问题。</p></li><li><p>Zoned(时区) − 通过制定的时区处理日期时间。</p></li><li><p>新的java.time包涵盖了所有处理日期，时间，日期&#x2F;时间，时区，时刻（instants），过程（during）与时钟（clock）的操作</p></li></ol><h4 id="9-1-本地化日期时间-API"><a href="#9-1-本地化日期时间-API" class="headerlink" title="9.1 本地化日期时间 API"></a>9.1 本地化日期时间 API</h4><p>LocalDate&#x2F;LocalTime 和 LocalDateTime 类可以在处理时区不是必须的情况。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前的日期时间</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">currentTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">System.out.println(<span class="string">&quot;当前时间: &quot;</span> + currentTime); </span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">date1</span> <span class="operator">=</span> currentTime.toLocalDate(); </span><br><span class="line">System.out.println(<span class="string">&quot;date1: &quot;</span> + date1); </span><br><span class="line"><span class="type">Month</span> <span class="variable">month</span> <span class="operator">=</span> currentTime.getMonth();</span><br><span class="line"><span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> currentTime.getDayOfMonth();</span><br><span class="line"><span class="type">int</span> <span class="variable">seconds</span> <span class="operator">=</span> currentTime.getSecond();</span><br><span class="line">System.out.println(<span class="string">&quot;月: &quot;</span> + month +<span class="string">&quot;, 日: &quot;</span> + day +<span class="string">&quot;, 秒: &quot;</span> + seconds);</span><br></pre></td></tr></table></figure><h4 id="9-2-使用时区的日期时间API"><a href="#9-2-使用时区的日期时间API" class="headerlink" title="9.2 使用时区的日期时间API"></a>9.2 使用时区的日期时间API</h4><p>如果我们需要考虑到时区，就可以使用时区的日期时间API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前时间日期</span></span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">date1</span> <span class="operator">=</span>ZonedDateTime.parse(<span class="string">&quot;2015-12-03T10:15:30+05:30[Asia/Shanghai]&quot;</span>); 			</span><br><span class="line">System.out.println(<span class="string">&quot;date1: &quot;</span> + date1);</span><br><span class="line"><span class="type">ZoneId</span> <span class="variable">id</span> <span class="operator">=</span> ZoneId.of(<span class="string">&quot;Europe/Paris&quot;</span>); </span><br><span class="line">System.out.println(<span class="string">&quot;ZoneId: &quot;</span> + id);</span><br><span class="line"><span class="type">ZoneId</span> <span class="variable">currentZone</span> <span class="operator">=</span> ZoneId.systemDefault(); </span><br><span class="line">System.out.println(<span class="string">&quot;当期时区: &quot;</span> + currentZone);</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------</span></span><br><span class="line"><span class="comment">//打印巴黎的时间</span></span><br><span class="line"><span class="type">ZoneId</span> <span class="variable">id</span> <span class="operator">=</span> ZoneId.of(<span class="string">&quot;Europe/Paris&quot;</span>); <span class="comment">//巴黎时区</span></span><br><span class="line"><span class="comment">//当前时区  </span></span><br><span class="line"><span class="type">ZoneId</span> <span class="variable">currentZone</span> <span class="operator">=</span> ZoneId.systemDefault(); <span class="comment">//Asia/Shanghai 中国时区东八区</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();<span class="comment">//当前时间</span></span><br><span class="line"><span class="comment">//将当前时区的时间转化为指定时区的时间</span></span><br><span class="line">LocalDateTimelocalDateTime=now.atZone(currentZone).withZoneSameInstant(id).toLocalDateTime();</span><br><span class="line">System.out.println(localDateTime);</span><br></pre></td></tr></table></figure><h3 id="10-总结重点"><a href="#10-总结重点" class="headerlink" title="10 总结重点"></a>10 总结重点</h3><p>Jdk1.8的新特性 lambda表达式 方法引用 函数式接口 stream</p><p>多线程 线程的创建方式 生命周期 锁机制 synconized与lock区别 threadlocal原理</p><p>线程池 线程池原理 常见4种线程池</p><p>线程池中最大线程数的设置</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://mliutm.github.io">清风</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://mliutm.github.io/breeze/f41870e2.html">https://mliutm.github.io/breeze/f41870e2.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://mliutm.github.io" target="_blank">清风</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java8%E6%96%B0%E7%89%B9%E6%80%A7/">java8新特性</a><a class="post-meta__tags" href="/tags/strean%E6%B5%81/">strean流</a><a class="post-meta__tags" href="/tags/Lambda/">Lambda</a></div><div class="post_share"><div class="social-share" data-image="/img/photo-1692708632140-ee01624d558d.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/breeze/8e09ad1c.html" title="html入门"><img class="cover" src="/img/premium_photo-1695185954894-e9382c6f4da8.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">html入门</div></div></a></div><div class="next-post pull-right"><a href="/breeze/66dacca8.html" title="多线程-线程安全"><img class="cover" src="/img/photo-1653549892896-dde02867edee.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">多线程-线程安全</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">清风</div><div class="author-info__description">清风洒六合，邈然不可攀</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">169</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">82</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:huangpan0805@163.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div><timing></timing></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java8%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">Java8新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E5%A4%A7%E7%BA%B2"><span class="toc-text">知识大纲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%BB%8B%E7%BB%8D"><span class="toc-text">1 Java8新特性介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E4%B8%BB%E8%A6%81%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">1.1 主要新特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="toc-text">2 接口的默认方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E4%BC%A0%E7%BB%9F%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E4%B9%8B%E5%89%8D%E7%9A%84%EF%BC%89"><span class="toc-text">2.1 传统的方法（之前的）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-static%E6%96%B9%E6%B3%95"><span class="toc-text">2.2 static方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-default%E6%96%B9%E6%B3%95"><span class="toc-text">2.3 default方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-text">3 函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-text">3.1 什么是函数式接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3API"><span class="toc-text">3.2 函数式接口API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E6%B3%A8%E8%A7%A3"><span class="toc-text">3.3 函数式接口注解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">4 Lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1%E4%BB%80%E4%B9%88%E6%98%AFLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">4.1什么是Lambda表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-text">4.2 Lambda表达式的语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%80%E4%B8%AA%E6%A1%88%E4%BE%8B%E5%AD%A6%E4%BC%9ALambda%EF%BC%89"><span class="toc-text">4.3 学习过程（一个案例学会Lambda）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-1-%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E5%86%99%E6%B3%95"><span class="toc-text">4.3.1 一个类实现一个接口基本写法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-2-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%86%99%E6%B3%95"><span class="toc-text">4.3.2 匿名内部类的写法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-3-%E4%BD%BF%E7%94%A8Lambda%E5%86%99%E6%B3%95%E4%B8%80%EF%BC%9A%E5%B8%B8%E8%A7%84%E5%86%99%E6%B3%95"><span class="toc-text">4.2.3 使用Lambda写法一：常规写法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-4-%E4%BD%BF%E7%94%A8Lambda%E5%86%99%E6%B3%95%E4%BA%8C%EF%BC%9A%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E7%AE%80%E5%86%99"><span class="toc-text">4.3.4 使用Lambda写法二：两个参数有返回值的简写</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-5-%E4%BD%BF%E7%94%A8Lambda%E5%86%99%E6%B3%95%E4%B8%89%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E6%B2%A1%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E7%AE%80%E5%86%99"><span class="toc-text">4.3.5 使用Lambda写法三：一个参数没有返回值的简写</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-6-%E4%BD%BF%E7%94%A8Lambda%E5%86%99%E6%B3%95%E5%9B%9B%EF%BC%9A%E6%B2%A1%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E7%AE%80%E5%86%99"><span class="toc-text">4.3.6 使用Lambda写法四：没有参数的简写</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Lambda-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">5 Lambda 作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-text">6 方法引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-text">6.1 构造方法引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-text">6.2 静态方法引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-text">6.3 实例方法引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Stream%E6%B5%81"><span class="toc-text">7 Stream流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-%E4%BB%80%E4%B9%88%E6%98%AF-Stream%EF%BC%9F"><span class="toc-text">7.1 什么是 Stream？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-%E7%94%9F%E6%88%90%E6%B5%81"><span class="toc-text">7.2 生成流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">7.3 常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#forEach"><span class="toc-text">forEach</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#map"><span class="toc-text">map</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#filter"><span class="toc-text">filter</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#limit"><span class="toc-text">limit</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sorted"><span class="toc-text">sorted</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%EF%BC%88parallel%EF%BC%89%E6%B5%81%E5%8F%8A%E4%B8%B2%E8%A1%8C%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB-%E4%BA%86%E8%A7%A3"><span class="toc-text">并行（parallel）流及串行流的区别-了解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Collectors"><span class="toc-text">Collectors</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Optional-%E7%B1%BB"><span class="toc-text">8 Optional 类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-%E5%A3%B0%E6%98%8E"><span class="toc-text">8.1 声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-Optional-%E5%AE%9E%E4%BE%8B"><span class="toc-text">8.2 Optional 实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4-API-%E4%BA%86%E8%A7%A3"><span class="toc-text">9 日期时间 API-了解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-%E6%9C%AC%E5%9C%B0%E5%8C%96%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4-API"><span class="toc-text">9.1 本地化日期时间 API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-%E4%BD%BF%E7%94%A8%E6%97%B6%E5%8C%BA%E7%9A%84%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4API"><span class="toc-text">9.2 使用时区的日期时间API</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E6%80%BB%E7%BB%93%E9%87%8D%E7%82%B9"><span class="toc-text">10 总结重点</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/breeze/1d13ce0d.html" title="WYDG-产品目录列表-20200506"><img src="/img/premium_photo-1695185954894-e9382c6f4da8.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="WYDG-产品目录列表-20200506"></a><div class="content"><a class="title" href="/breeze/1d13ce0d.html" title="WYDG-产品目录列表-20200506">WYDG-产品目录列表-20200506</a><time datetime="2025-04-13T05:43:05.000Z" title="发表于 2025-04-13 13:43:05">2025-04-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/breeze/6f268337.html" title="雨雀文件下载"><img src="/img/premium_photo-1695185954894-e9382c6f4da8.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="雨雀文件下载"></a><div class="content"><a class="title" href="/breeze/6f268337.html" title="雨雀文件下载">雨雀文件下载</a><time datetime="2024-05-22T12:25:08.000Z" title="发表于 2024-05-22 20:25:08">2024-05-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/breeze/7832219d.html" title="十万字面试总结"><img src="/img/photo-1688475747590-d0db5e2412cb.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="十万字面试总结"></a><div class="content"><a class="title" href="/breeze/7832219d.html" title="十万字面试总结">十万字面试总结</a><time datetime="2024-02-29T02:50:00.000Z" title="发表于 2024-02-29 10:50:00">2024-02-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/breeze/7ae0ca37.html" title="Redis_30道经典面试题"><img src="/img/premium_photo-1695185954894-e9382c6f4da8.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Redis_30道经典面试题"></a><div class="content"><a class="title" href="/breeze/7ae0ca37.html" title="Redis_30道经典面试题">Redis_30道经典面试题</a><time datetime="2024-02-29T02:45:00.000Z" title="发表于 2024-02-29 10:45:00">2024-02-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/breeze/2a548e97.html" title="面试实战"><img src="/img/photo-1688475747590-d0db5e2412cb.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="面试实战"></a><div class="content"><a class="title" href="/breeze/2a548e97.html" title="面试实战">面试实战</a><time datetime="2024-02-29T02:43:59.000Z" title="发表于 2024-02-29 10:43:59">2024-02-29</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/img/photo-1692708632140-ee01624d558d.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 <i id="heartbeat" class="fa fas fa-heartbeat"></i> 清风</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></head></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script src="/js/timing.js"></script><script id="canvas_nest" defer color="255,0,255" opacity="0.7" zindex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!0,document.body.addEventListener("input",POWERMODE)</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="天枢,天璇,天玑,天权,玉衡,开阳,瑶光" data-fontsize="15px" data-random="true" async></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>