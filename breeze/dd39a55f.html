<!DOCTYPE html><html class="hide-aside" lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>基础源码分析与Linux优化 | 清风</title><meta name="author" content="清风"><meta name="copyright" content="清风"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基础源码分析&amp;Linux优化一 简介 基础源码分析-字符串  基础源码分析-集合体系(Collection,Map)  服务器优化概述 硬件—&gt;linux—-&gt;Jvm—–&gt;相关组件(mysql,redis,es,mq)—&gt;常见框架的源码(Spring,springboot,springcloud)   Linux优化   二 基础源码分析-字符串(多个字符,串成串)"><meta property="og:type" content="article"><meta property="og:title" content="基础源码分析与Linux优化"><meta property="og:url" content="https://mliutm.github.io/breeze/dd39a55f.html"><meta property="og:site_name" content="清风"><meta property="og:description" content="基础源码分析&amp;Linux优化一 简介 基础源码分析-字符串  基础源码分析-集合体系(Collection,Map)  服务器优化概述 硬件—&gt;linux—-&gt;Jvm—–&gt;相关组件(mysql,redis,es,mq)—&gt;常见框架的源码(Spring,springboot,springcloud)   Linux优化   二 基础源码分析-字符串(多个字符,串成串)"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://mliutm.github.io/img/photo-1692708632140-ee01624d558d.jpg"><meta property="article:published_time" content="2024-01-14T13:43:10.000Z"><meta property="article:modified_time" content="2024-01-14T14:43:35.034Z"><meta property="article:author" content="清风"><meta property="article:tag" content="Linux"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://mliutm.github.io/img/photo-1692708632140-ee01624d558d.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://mliutm.github.io/breeze/dd39a55f.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,top_n_per_article:1,unescape:!1,languages:{hits_empty:"找不到您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!1,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"基础源码分析与Linux优化",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-01-14 22:43:35"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,a){0!==a&&(a=864e5*a,t={value:t,expiry:(new Date).getTime()+a},localStorage.setItem(e,JSON.stringify(t)))},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!((new Date).getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=o=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.getCSS=(o,n=!1)=>new Promise((t,e)=>{const a=document.createElement("link");a.rel="stylesheet",a.href=o,n&&(a.id=n),a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">169</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">82</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/img/photo-1692708632140-ee01624d558d.jpg)"><nav id="nav"><span id="blog-info"><a href="/" title="清风"><span class="site-name">清风</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">基础源码分析与Linux优化</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-14T13:43:10.000Z" title="发表于 2024-01-14 21:43:10">2024-01-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-14T14:43:35.034Z" title="更新于 2024-01-14 22:43:35">2024-01-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E8%83%BD%E6%8F%90%E5%8D%87/">技能提升</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>39分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="基础源码分析与Linux优化"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="基础源码分析-Linux优化"><a href="#基础源码分析-Linux优化" class="headerlink" title="基础源码分析&amp;Linux优化"></a>基础源码分析&amp;Linux优化</h1><h2 id="一-简介"><a href="#一-简介" class="headerlink" title="一 简介"></a>一 简介</h2><ul><li><p>基础源码分析-字符串</p></li><li><p>基础源码分析-集合体系(Collection,Map)</p></li><li><p>服务器优化概述 硬件—&gt;linux—-&gt;Jvm—–&gt;相关组件(mysql,redis,es,mq)—&gt;常见框架的源码(Spring,springboot,springcloud)</p><p><img src="/breeze/dd39a55f/1689903571056.png" alt="1689903571056"></p></li><li><p>Linux优化</p></li></ul><h2 id="二-基础源码分析-字符串-多个字符-串成串"><a href="#二-基础源码分析-字符串-多个字符-串成串" class="headerlink" title="二 基础源码分析-字符串(多个字符,串成串)"></a>二 基础源码分析-字符串(多个字符,串成串)</h2><p>java中处理字符串的类有String ,Stringbuider,StringBuffer</p><h3 id="1-String"><a href="#1-String" class="headerlink" title="1 String"></a>1 String</h3><p>​ <strong>内容不可变</strong>的字符串！底层是final char value[];一旦赋值,不能再重新赋值,不能像StringBuilder与StringBuffer通过追加的方式改变里面的内容。因为追加时,如果空间不够了,需要新建一个新的更大容量赋值给它. 但是由于加了final不能重新赋值. <strong>一般用来定义变量或者常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[]; <span class="comment">//final修饰属性的时候一旦赋值就不可以再重新赋值</span></span><br></pre></td></tr></table></figure><p>字符串拼接面试题： <strong>String a &#x3D; “zs”; String b&#x3D; “ls” String c &#x3D; a+b; String d &#x3D; “zs”+”ls”;</strong> false</p><p>​ <a target="_blank" rel="noopener" href="https://manor.blog.csdn.net/article/details/115504197?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-115504197-blog-7743296.pc_relevant_recovery_v2&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-115504197-blog-7743296.pc_relevant_recovery_v2&utm_relevant_index=1">https://manor.blog.csdn.net/article/details/115504197?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-115504197-blog-7743296.pc_relevant_recovery_v2&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-115504197-blog-7743296.pc_relevant_recovery_v2&amp;utm_relevant_index=1</a></p><p><img src="/breeze/dd39a55f/1676255810710.png" alt="1676255810710"></p><p>String a &#x3D; “A” 和 String a &#x3D; new String(“A”) 创建字符串的区别 &#x3D;&#x3D;(false)</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">实际上，在Java中使用字符串字面量和使用<span class="keyword">new</span><span class="type"></span>关键字创建<span class="keyword">String</span>对象的区别主要在于对象的存储位置而不是可变性。</span><br><span class="line"></span><br><span class="line">当使用字符串字面量创建字符串时，Java会首先检查字符串常量池中是否存在相同内容的字符串对象。如果存在，则直接返回该对象的引用；如果不存在，则创建一个新的字符串对象，并将其放入字符串常量池中。</span><br><span class="line"></span><br><span class="line">而使用<span class="keyword">new</span><span class="type"></span>关键字创建<span class="keyword">String</span>对象时，无论字符串常量池中是否已经存在相同内容的字符串对象，都会在堆内存中创建一个新的字符串对象。</span><br><span class="line"></span><br><span class="line">因此，使用字符串字面量创建的字符串对象在内存中是共享的，而使用<span class="keyword">new</span><span class="type"></span>关键字创建的字符串对象则是独立的。这也意味着，对于使用字符串字面量创建的字符串，在多个变量引用同一个字符串字面量时，它们实际上引用的是同一个对象；而使用<span class="keyword">new</span><span class="type"></span>关键字创建的字符串对象，每次都会创建一个新的对象。</span><br><span class="line"></span><br><span class="line">请注意，不论是使用字符串字面量还是使用<span class="keyword">new</span><span class="type"></span>关键字创建的<span class="keyword">String</span>对象都是不可变的（immutable）。这意味着一旦创建了字符串对象，就无法修改其值。任何看似修改字符串的操作实际上都会创建一个新的字符串对象。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/breeze/dd39a55f/1689904680323.png" alt="1689904680323"></p><p>+和append谁效率高</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">在 Java 中，对于字符串的连接操作，如果只涉及到少量的字符串拼接，例如 str1 + str2，其性能可能是可以接受的。</span><br><span class="line"></span><br><span class="line">然而，当需要进行大量的字符串拼接操作时，使用 StringBuilder 的 <span class="keyword">append</span>() 方法通常比直接使用 + 运算符更高效。这是因为 + 运算符在每次字符串连接时都会创建一个新的字符串对象，而 StringBuilder 使用可变的字符序列来进行拼接操作，避免了频繁的对象创建和内存拷贝。</span><br><span class="line"></span><br><span class="line">因此，当需要进行多次字符串拼接操作时，建议使用 StringBuilder 来提高性能。示例代码如下：</span><br><span class="line"></span><br><span class="line">java</span><br><span class="line">StringBuilder sb = new StringBuilder();</span><br><span class="line">sb.<span class="keyword">append</span>(str1);</span><br><span class="line">sb.<span class="keyword">append</span>(str2);</span><br><span class="line">String result = sb.<span class="keyword">toString</span>();</span><br><span class="line">上述代码中，StringBuilder 类的 <span class="keyword">append</span>() 方法对字符串进行连接操作，最后通过 <span class="keyword">toString</span>() 方法将结果转换为一个新的字符串对象。</span><br><span class="line"></span><br><span class="line">总而言之，对于少量的字符串拼接操作，str1 + str2 可能是可以接受的。但是，对于大量的字符串拼接操作，使用 StringBuilder 的 <span class="keyword">append</span>() 方法更加高效。</span><br></pre></td></tr></table></figure><p><img src="/breeze/dd39a55f/1689906154020.png" alt="1689906154020"></p><h3 id="2-StringBuilder"><a href="#2-StringBuilder" class="headerlink" title="2 StringBuilder"></a>2 StringBuilder</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The value is used for character storage.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="type">char</span>[] value;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minimumCapacity)</span> &#123;</span><br><span class="line">     <span class="comment">// overflow-conscious code</span></span><br><span class="line">     <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         value = Arrays.copyOf(value,</span><br><span class="line">                 newCapacity(minimumCapacity));</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>内容可变</strong>的字符串！底层是char value[];赋值还能再重新赋值,可以通过追加的方式改变里面的内容。因为追加时,如果空间不够了,需要新建一个新的更大容量赋值给它 一<strong>般用来拼接字符,不考虑线程安全.</strong></p><h3 id="3-StringBuffer"><a href="#3-StringBuffer" class="headerlink" title="3 StringBuffer"></a>3 StringBuffer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value is used for character storage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">char</span>[] value;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minimumCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            value = Arrays.copyOf(value,</span><br><span class="line">                    newCapacity(minimumCapacity));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">synchronized</span> StringBuffer <span class="title function_">append</span><span class="params">(AbstractStringBuilder asb)</span> &#123;</span><br><span class="line">        toStringCache = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">super</span>.append(asb);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>StringBuffer&amp;StringBuilder都是可变字符串，没有fInal修饰char[] value,在拼接时发现空间不够了，要创建一个大的数组容器赋值给他。</strong></p><p>面试题:</p><p>1 说一下string的底层原理 底层是final char value[];一旦赋值,不能再重新赋值,不能通过追加的方式改里面内容。追加如果空间不够了,需要搞一个新的更大容量赋值给它,但是由于final修饰不行!</p><p>2 简单说一下string</p><p>​ <strong>内容不可变</strong>的字符串！是final char value[];一旦赋值,不能再重新赋值,不能通过追加的方式改里面内容。追加如果空间不够了,需要搞一个新的更大容量赋值给它. 但是不能.</p><p>3 说一下String与Stringbuider的联系与区别</p><p>联系: 都是处理字符串,底层都是char value[];</p><p>区别: String <strong>内容不可变</strong>的字符串.final char value[]; 一般用来定义变量或者常量</p><p>Stringbuider是内容可变且线程不安全字符串,底层是char value[];它有追加方法,当容量不够的时候一般就搞一个<strong>2倍+2原来的数组容量大数组</strong>,重新赋值给它. 一般用来做字符串拼接</p><p>4 说一下Stirngbuilder与StringBuffer的联系与区别</p><p>​ 联系:都是内容可变字符串,底层都是没有final修饰char[]</p><p>​ 区别:Stringbuffer是线程安全,方法有synchronized修饰,效率低,而Stirngbuilder</p><p>没有sys修饰效率高.线程不安全</p><p>5 我想在想要拼接字符串用哪个类???</p><p>6 +和append</p><h4 id="7-和-equals-的区别是什么"><a href="#7-和-equals-的区别是什么" class="headerlink" title="7 &#x3D;&#x3D; 和 equals 的区别是什么"></a>7 &#x3D;&#x3D; 和 equals 的区别是什么</h4><p><code>==</code>如果基本数据类型,比较值.如果是引用类型比较的是内存地址,就是看他们是不是同一个对象.</p><p>equals不能用于基本数据类型.只能用于对象.是Object的的一个方法,任何对象都直接或间接继承Object,如果</p><p>该类没有重写equals比较的还是地址.</p><p>​ 对于包装类比如：Integer都是复写过equals方法，比较的是int 值,是重写equals其实就是比较数值,String也是重写了,比较里面的内容.但是StringBuiler与StringBuffer没有重写equals所以还是比较的地址.</p><p>String a &#x3D; new String(“a”);</p><p>String b &#x3D; new String(“a”);</p><p>a&#x3D;&#x3D;b false</p><p>a.equals(b) &#x2F;&#x2F;true</p><p>StringBuilder a &#x3D; new StringBuilder (“a”);</p><p>StringBuilder b &#x3D; new StringBuilder (“a”);</p><p>a&#x3D;&#x3D;b false</p><p>a.equals(b) &#x2F;&#x2F;false</p><p>​ 初始容量,如果无参创建(16),传入容量的创建(传入的容量) 传入字符串创建(字符串长度+16)</p><p>​ 扩容:<strong>2倍+2原来的数组容量大数组</strong></p><h2 id="三-集合体系"><a href="#三-集合体系" class="headerlink" title="三 集合体系"></a>三 集合体系</h2><p>说一下java中集合??? 分为Collection(List,set)和Map,collection是存放一个一个的值,map放的是键值对.</p><h3 id="1-Collection体系回顾-一个一个的值"><a href="#1-Collection体系回顾-一个一个的值" class="headerlink" title="1.Collection体系回顾-一个一个的值"></a>1.Collection体系回顾-一个一个的值</h3><p>Java中集合类是Java编程中使用最频繁、最方便的类。集合类作为容器类可以存储任何类型的数据，当然也可以结合泛型存储指定的类型（不过泛型仅仅在编译期有效，运行时是会被擦除的）。<strong>集合类中存储的仅仅是对象的引用，并不存储对象本身</strong>。集合类的容量可以在运行期间进行动态扩展，并且还提供很多很方便的方法，如求集合的并集、交集等。</p><p>Java中的集合包含多种数据结构，如链表、队列、哈希表等。从类的继承结构来说，可以分为两大类，一类是继承自Collection接口，这类集合包含<strong>List、Set和Queue</strong>等集合类。另一类是继承自Map接口，这主要包含了哈希表相关的集合类。</p><p><img src="/breeze/dd39a55f/1639821114943.png" alt="1639821114943"></p><h4 id="1-1-List体系"><a href="#1-1-List体系" class="headerlink" title="1.1.List体系"></a>1.1.List体系</h4><p>我们用的比较多List包括ArrayList和LinkedList，这两者的区别也很明显，从其名称上就可以看出。ArrayList的底层的通过数组实现，所以其随机访问的速度比较快，但是对于需要频繁的增删的情况，效率就比较低了。而对于LinkedList，底层通过链表来实现，所以增删操作比较容易完成，但是对于随机访问的效率比较低。至于<strong>Vector</strong>，它是ArrayList的线程安全版本。</p><h4 id="1-2-Queue-实现栈和队列"><a href="#1-2-Queue-实现栈和队列" class="headerlink" title="1.2.Queue-实现栈和队列"></a>1.2.Queue-实现栈和队列</h4><p>一般可以直接使用LinkedList完成，从上述类图也可以看出，LinkedList继承自Deque，所以LinkedList具有双端队列的功能。PriorityQueue的特点是为每个元素提供一个优先级，优先级高的元素会优先出队列(默认排序是自然排序，队头元素是最小元素,可以通过comparator比较器修改排序的比较方式)。</p><h4 id="1-3-Set"><a href="#1-3-Set" class="headerlink" title="1.3.Set"></a>1.3.Set</h4><p>Set与List的主要区别是Set是不允许元素重复的，而List则可以允许元素重复的。判断元素的重复需要根据对象的hash方法和equals方法来决定。这也是我们通常要为集合中的元素类重写hashCode方法和equals方法的原因。</p><p>对于集合中元素，hashCode值不同的元素一定不相等，但是不相等的元素，hashCode值可能相同。HashSet和LinkedHashSet的区别在于后者可以保证元素插入集合的元素顺序与输出顺序保持一致。而TreeSet的区别在于其排序是按照Comparator来进行排序的，默认情况下按照字符的自然顺序进行升序排列。</p><h4 id="1-4-常见集合比较"><a href="#1-4-常见集合比较" class="headerlink" title="1.4.常见集合比较"></a>1.4.常见集合比较</h4><table><thead><tr><th>集合</th><th>特点</th><th>说明</th></tr></thead><tbody><tr><td>List</td><td>1. 有序,可重复2. 可以通过索引访问（下标）</td><td>数组(ArrayList)或者链表(LinkedList)存储</td></tr><tr><td>Set</td><td>1. 无序，不重复</td><td>使用Map存储(HashSet - HashMap)</td></tr><tr><td>ArrayList</td><td>1. 有序2. 随机访问快(下标)3. 插入，删除慢(移位)</td><td>底层基于动态数组，内存连续，查询速度快，删除添加要移动数据，性能低下</td></tr><tr><td>LinkedList</td><td>1. 有序2. 查询慢3. 插入，删除快</td><td>双向链表，内存可以不连续，删除，添加快，查询慢</td></tr><tr><td>Vector</td><td>1. 有序2.线程安全(synchronized)ArrayList的前任</td><td>数组 ， 同步锁保证安全性，性能低，不推荐用</td></tr><tr><td>PriorityQueue</td><td>1. 优先队列2. 默认最小的在前面，按照自然顺序排序</td><td>二叉小顶堆(二叉树)</td></tr><tr><td>TreeSet</td><td>1. 可以保证元素排序(默认自然顺序，可定制)2. 是线程不安全3. 元素不重复(compareTo判断)4. 插入的元素必须实现Comparable接口5. 不允许放入null值</td><td>基于TreeMap的KeySet存储数据，使用红黑树实现需要排序时使用TreeSet</td></tr><tr><td>HashSet</td><td>1. 线程不安全2. 元素不重复(通过hashCode和equals方法判断)3. 元素是无序的4. 只能放入一个null</td><td>基于 HashMap 的KeySet储存数据，使用Hash表实现 性能高于TreeSet,优先使用它</td></tr><tr><td>LinkedHasHSet extends HashSet</td><td>1. 线程不安全2. 元素不重复3. 可以保证元素插入的顺序4. 迭代性能高于HashSet</td><td>基于LinkHashMap存储数据，哈希表和双向链表</td></tr><tr><td>HashMap</td><td>1. 非线程安全 2. 基于哈希表实现3. 通过hashcode实现元素快速查找4. 元素无序5. 可以出现一个null键，多个null值</td><td>基于哈希表实现适用于在Map中插入、删除和定位元素</td></tr><tr><td>TreeMap</td><td>1. 非线程安全2. 基于红黑树实现</td><td>基于红黑树实现适用于按自然顺序或自定义顺序遍历键(key)</td></tr><tr><td>HashTable</td><td>1. 线程安全的2. 性能低下3. 不能有null键和null值</td><td>哈希表实现，线程安全，性能低，已经不用了，多线程使用concurrentHashMap</td></tr></tbody></table><h3 id="2-Map体系回顾-键值对"><a href="#2-Map体系回顾-键值对" class="headerlink" title="2.Map体系回顾-键值对"></a>2.Map体系回顾-键值对</h3><p>下面是map继承体系图</p><p><img src="/breeze/dd39a55f/u=1026818333,1794475047&fm=253&fmt=auto&app=138&f=PNG.png" alt="img"></p><p>Map的遍历方式有哪些?</p><p>​	1.keySet –拿到里面所有的Key—再根据key去取值</p><p>​	2.entrySet–&gt;获取到map底层用来去存储数据的对象</p><p>如果现在要获取一个线程安全的Map怎么做?</p><p>​	1.HashTable—效率的比较低,创建的map容器在同一时刻只能有一个线程访问</p><p>​	2.Collections—把Map转换为一个线程安全的Map–&gt;SynchronizedMap—-&gt;本质和HashTable</p><p>​	3.CurrentHashMap</p><p>图中的绿色的虚线代表实现，绿色实线代表接口之间的继承，蓝色实线代表类之间的继承。</p><p>Map类型的集合最大的优点在于其查找效率比较高，用的是散列存储这种物理数据结构,理想情况下可以实现O(1)的时间复杂度。Map中最常用的是HashMap，LinkedHashMap与HashMap的区别在于前者能够保证插入集合的元素顺序与输出顺序一致。这两者与TreeMap的区别在于TreeMap是根据键值进行排序的，当然其底层的实现也有本质的区别，如HashMap底层是一个哈希表，而TreeMap的底层数据结构是一棵树。</p><p>HashMap与TreeMap的区别，与之前提到的HashSet与TreeSet的区别是一致的， HashSet和TreeSet本质上分别是通过HashMap和TreeMap来实现的，所以它们的区别自然也是相同的。HashTable现在已经很少使用了，与HashMap的主要区别是HashTable是线程安全的，不过由于其效率比较低，所以通常使用HashMap，在多线程环境下，通常用CurrentHashMap来代替。</p><p>要想存一个key-value值并且保证线程安全？推荐那种</p><p>1 HashTable</p><p>​ <img src="/breeze/dd39a55f/1666857133750.png" alt="1666857133750"></p><p>2 Collections.synchronizedMap—&gt;SynchronizedMap</p><p>​ 线程不安全的map转换为线程安全Map</p><p><img src="/breeze/dd39a55f/1666857310005.png" alt="1666857310005"></p><p>3 <strong>ConcurrentHashMap</strong></p><p>jdk1.7 分段锁</p><p><img src="/breeze/dd39a55f/1666857482535.png" alt="1666857482535"></p><p>jdk.1.8 节点锁</p><p><img src="/breeze/dd39a55f/1666857802063.png" alt="1666857802063"></p><p>锁的粒度越来越细，效率就提升</p><h4 id="2-1-HashMap底层原理分析"><a href="#2-1-HashMap底层原理分析" class="headerlink" title="2.1. HashMap底层原理分析"></a>2.1. HashMap底层原理分析</h4><p>HashMap也是我们使用非常多的Map，它是基于哈希表的 Map 接口的实现，以key-value的形式存在。在HashMap中，key-value总是会当做一个整体来处理，系统会根据hash算法来来计算key-value的存储位置，我们总是可以通过key快速地存、取value。</p><p>jdk1.7及以前：数据+链表</p><p><img src="/breeze/dd39a55f/1666857976228.png" alt="1666857976228"></p><p>jdk1.8及其以后：数组+链表+红黑树</p><p><img src="/breeze/dd39a55f/3801213fb80e7becc2f5933286b2223e9a506b5d.jfif" alt="img"></p><h4 id="2-2-HashMap定义"><a href="#2-2-HashMap定义" class="headerlink" title="2.2.HashMap定义"></a>2.2.HashMap定义</h4><p>HashMap实现了Map接口，继承AbstractMap。其中Map接口定义了键映射到值的规则，而AbstractMap类提供 Map 接口的骨干实现，以最大限度地减少实现此接口所需的工作，其实AbstractMap类已经实现了Map。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">    <span class="comment">// 序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">362498820763181265L</span>;    </span><br><span class="line">    <span class="comment">// 默认的初始容量是16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;   </span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>; </span><br><span class="line">    <span class="comment">// 默认的负载因子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>; (jdk1<span class="number">.8</span>以后才有)</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 桶中结构转化为红黑树对应的table的最小大小</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 存储元素的数组，总是2的幂次倍</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;k,v&gt;[] table; </span><br><span class="line">    <span class="comment">// 存放具体元素的集</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class="line">    <span class="comment">// 存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> modCount;   </span><br><span class="line">    <span class="comment">// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span></span><br><span class="line">    <span class="type">int</span> threshold;</span><br><span class="line">    <span class="comment">// 负载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：transient：java语言的关键字，<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8F%98%E9%87%8F/3956968">变量</a><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BF%AE%E9%A5%B0%E7%AC%A6/4088564">修饰符</a>，如果用transient声明一个<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F/3386159">实例变量</a>，当对象存储时，它的值不需要维持。换句话来说就是，用transient关键字标记的成员变量不参与序列化过程。</p><h4 id="2-3-HashMap底层结构示意图"><a href="#2-3-HashMap底层结构示意图" class="headerlink" title="2.3.HashMap底层结构示意图"></a>2.3.HashMap底层结构示意图</h4><p>Jdk1.8中，HashMap底层基于数组、链表、红黑树实现。示意图如下：</p><p><img src="/breeze/dd39a55f/1676257047019.png" alt="1676257047019"></p><h4 id="3-4-HashMap底层代码解析"><a href="#3-4-HashMap底层代码解析" class="headerlink" title="3.4.HashMap底层代码解析"></a>3.4.HashMap底层代码解析</h4><p>HashMap提供了4个构造函数：</p><p>HashMap()：构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空 HashMap。</p><p>HashMap(int initialCapacity)：构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap。</p><p>HashMap(int initialCapacity, float loadFactor)：构造一个带指定初始容量和加载因子的空 HashMap。</p><p>HashMap(Map&lt;? extends K, ? extends V&gt; m)：传入一个map以构造一个新的map，使用默认加载因子（0.75）。</p><p>在这里提到了两个参数：初始容量，加载因子。这两个参数是影响HashMap性能的重要参数，其中容量表示哈希表中桶的数量，初始容量是创建哈希表时的容量，加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，它衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链表法的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。系统默认负载因子为0.75，一般情况下我们是无需修改的。</p><p><strong>存值put(K key, V value)</strong></p><p><img src="/breeze/dd39a55f/1676257105588.png" alt="1676257105588"></p><p>① 判断当前桶是否为空，空的就需要初始化数组（resize（） 中会判断是否进行初始化）。</p><p>② 根据当前 key 的 hashcode 定位到具体的桶中并判断是否为空，为空表明没有 Hash 冲突就直接在当前位置创建一个新桶即可。</p><p>③ 如果当前桶有值（ Hash 冲突），那么就要比较当前桶中的 key、key 的 hashcode 与写入的 key 是否相等，相等就赋值给 e,在第 8 步的时候会统一进行赋值及返回。</p><p>④ 如果当前桶为红黑树，那就要按照红黑树的方式写入数据。</p><p>⑤ 如果是个链表，就需要将当前的 key、value 封装成一个新节点写入到当前桶的后面（形成链表）。</p><p>⑥ 接着判断当前链表的大小是否大于预设的阈值，大于时就要转换为红黑树。</p><p>⑦ 如果在遍历过程中找到 key 相同时直接退出遍历。</p><p>⑧ 如果 e !&#x3D; null 就相当于存在相同的 key,那就需要将值覆盖。</p><p>⑨ 最后判断是否需要进行扩容。</p><p><strong>取值get(Object key)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="comment">//如果table不为空，则再进行查询操作</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//先检查第一个元素是否key相同</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果为红黑树结构，则走红黑树的查询逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;<span class="comment">//否则遍历链表</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Get 方法看起来就要简单许多了。</p><ol><li>首先将 key hash 之后取得所定位的桶。</li><li>如果桶为空则直接返回 null 。</li><li>否则判断桶的第一个位置(有可能是链表、红黑树)的 key 是否为查询的 key，是就直接返回 value。</li><li>如果第一个不匹配，则判断它的下一个是红黑树还是链表。</li><li>红黑树就按照树的查找方式返回值。</li><li>不然就按照链表的方式遍历匹配返回值。</li></ol><p>从这两个核心方法（get&#x2F;put）可以看出 1.8 中对大链表做了优化，修改为红黑树之后查询效率直接提高到了 O(logn)。</p><h4 id="3-5-遍历方式"><a href="#3-5-遍历方式" class="headerlink" title="3.5.遍历方式"></a>3.5.遍历方式</h4><p>HashMap 的遍历方式，通常有以下几种：</p><p><img src="/breeze/dd39a55f/1676257126157.png" alt="1676257126157"></p><p>强烈建议使用第一种 EntrySet 进行遍历。第一种可以把 key value 同时取出，第二种还得需要通过 key 取一次 value，效率较低。</p><p>面试题:</p><p>​ 1 说一下java中的集合</p><p>​ 分为Collection和Map,Collection存一个一个的值,Map是存key,value值.</p><p>Collection常用的有List和Set,Map常用有hashtable,hashmap,concurenthashmap等等</p><p>2 说一下list与set的联系和区别</p><p>​ 联系: list和Set都是Collection的子接口,都是放一个一个的值的</p><p>​ 区别:list是有序可重复的,set<strong>一般</strong>来说是无序不可重复的. linkedhashset</p><p>3 说一下ArrayList和LinkedList的联系和区别</p><p>​ 联系:ArrayList与LinkedList都是List实现,都是放有序可重复的一个一个的值.</p><p>​ 区别:ArrayList底层是数组,LinkedList底层是链表. ArrayList查询速度快,但是插入和删除效率低,数组是连续的控空间,如果想插入和删除需要移动位置. LinkedList查询特定位置的数据慢,只能从头开始找,,但是插入和删除效率搞,只需要变换指针不需要移动位置</p><p>​ <strong>ArrayList扩容扩1.5倍</strong></p><p>4 想存不重复(set)且有序的一个一个的值用哪个集合??? <strong>linkedhashset</strong></p><p>​ HashSet:无序不可重复的. <strong>重复: hashCode,equals</strong></p><p>​ linkedhashset:有序不可重复</p><p>​ treeSet:排序不可重复</p><p>5 集合怎么排序</p><p>​ Collections.sort()</p><p>6 想存且<strong>有序</strong>的key-value的值用哪个集合 <strong>linkedHashMap</strong></p><p>​ hashMap:无序Map</p><p>​ linkedHashMap:有序Map</p><p>​ TreeMap: 排序Map</p><p>7 说一下hashtable与hashmap的联系与区别</p><p>​ 联系:hashtable与hashmap:都是map</p><p>​ 区别:</p><p>​ 1)值能不能为Null hashmap可以多个null,hashtable不能为null</p><p>​ 2)key是否允许为null hashtable不能为null,hashmap允许一个null</p><p>​ &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p><strong>hashtable key和value都不能为null,而hashmap允许一个null key,多个null值.</strong></p><p>​ <strong>3)线程安全</strong></p><p>​ <strong>hashtable是线程安全,方法上面都加了sys,效率低,hashmap是线程不安全,效率高</strong></p><p>8 说一下hashmap的底层原理</p><p>hash的底层数据结构是数组+链表+红黑树</p><p>​ <strong>存值: hash(key)—&gt;table索引—&gt;如果没有直接放入</strong></p><p>​ <strong>如果有,判断那个节点的key是否是自己key,如果是直接替换,—&gt;否则按照树或者链表判断是否有key,有key就替换,如果没有就新增</strong></p><p><strong>取值: hash(key)—&gt;table索引–&gt;如果第一个节点(equas)是我们想要的直接返回就ok,否则按照树或者链表来获取就行</strong>**</p><p>找到要存放元素位置–hash函数<br>tab[i &#x3D; (n - 1) &amp; hash(key)]<br>static final int hash(Object key) {<br>int h;<br>return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16); 0111111^ 011001<br>}</p><p>9 说一下concurrenthashmap</p><p>​ 降低锁的粒度: hashtable锁全部数组的全部元素,意味着同一个hashtable对象,在读的时候,另外的线程不能读也不能写,在写的时候也一样,另外的线程不能读也不能写,在写的时候也一样.</p><p>​ concurrenthashmap:</p><p>1.7 区间锁,锁几个元素,效率也挺高的.</p><p>1.8 锁全部数组的<strong>当前元素</strong>,读写当前元素,其他元素是可以被其他线程操作,效率高.</p><p><img src="/breeze/dd39a55f/1676260280991.png" alt="1676260280991"></p><p>Stringbuider: 默认容量16(无参构造) 2n+2<br>ArrayList: 默认容量(0) 1.5N<br>HashMap: 触发扩容,原来容器<em>0.75 (负载因子) 新容量&#x3D;老容量</em>2</p><p>​ 初始容量:</p><p>​ <strong>如果没有指定就是16</strong>,如果指定了就是比它大或者等于2的次方的数字 2–&gt;4 10—&gt;16 56—&gt;64</p><p>扩容和负载因子有什么关系?????</p><p>​ 真实容量&gt;&#x3D;容X0.75(默认负载因子) 触发扩容 扩原来容量*2</p><p>new HashMap(5); 容量是多少?</p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><h2 id="四-服务器优化概述"><a href="#四-服务器优化概述" class="headerlink" title="四 服务器优化概述"></a>四 服务器优化概述</h2><p>硬件—操作系统（系统软件）–应用程序</p><h3 id="1-影响服务器性能因素"><a href="#1-影响服务器性能因素" class="headerlink" title="1 影响服务器性能因素"></a>1 影响服务器性能因素</h3><h4 id="1-1-硬件相关"><a href="#1-1-硬件相关" class="headerlink" title="1.1 硬件相关"></a>1.1 硬件相关</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>CPU</span><br><span class="line"><span class="number">2.</span>内存</span><br><span class="line"><span class="number">3.</span>磁盘I/O  </span><br><span class="line"><span class="number">4.</span>网络I/O带宽 -- 其中的一种共计手段 dos攻击</span><br></pre></td></tr></table></figure><h4 id="1-2-软件相关"><a href="#1-2-软件相关" class="headerlink" title="1.2 软件相关"></a>1.2 软件相关</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="selector-class">.linux</span></span><br><span class="line"><span class="number">2</span><span class="selector-class">.jvm</span></span><br><span class="line"><span class="number">3</span>java程序</span><br><span class="line"><span class="number">4</span><span class="selector-class">.Tomcat</span></span><br><span class="line"><span class="number">5</span><span class="selector-class">.Nginx</span></span><br><span class="line"><span class="number">6</span><span class="selector-class">.Mysql</span></span><br><span class="line"><span class="number">7</span>.等等</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-服务器优化"><a href="#2-服务器优化" class="headerlink" title="2 服务器优化"></a>2 服务器优化</h3><h4 id="2-1-硬件优化"><a href="#2-1-硬件优化" class="headerlink" title="2.1 硬件优化"></a>2.1 硬件优化</h4><p>1 CPU<br>2.内存<br>3.磁盘I&#x2F;O<br>4.网络I&#x2F;O带宽</p><h4 id="2-2-软件优化"><a href="#2-2-软件优化" class="headerlink" title="2.2 软件优化"></a>2.2 软件优化</h4><p>1.linux(运维….)<br>2.jvm<br>3java程序<br>4.Tomcat<br>5.Nginx<br>6.Mysql<br>7.等等</p><h2 id="五-操作系统-linux优化"><a href="#五-操作系统-linux优化" class="headerlink" title="五 操作系统-linux优化"></a>五 操作系统-linux优化</h2><p>性能出问题了才优化,就要有<strong>性能评估标准?</strong> 查询指标<strong>如果超过标准..</strong></p><h3 id="1-系统性能评估标准"><a href="#1-系统性能评估标准" class="headerlink" title="1 系统性能评估标准"></a>1 系统性能评估标准</h3><p>%user：表示CPU处在用户模式下的时间百分比。<br>%sys：表示CPU处在系统模式下的时间百分比。<br>%iowait：表示CPU等待输入输出完成时间的百分比。<br>swap in：即si，表示虚拟内存的页导入，即从SWAP DISK交换到RAM<br>swap out：即so，表示虚拟内存的页导出，即从RAM交换到SWAP DISK。</p><p>整体性能</p><p><img src="/breeze/dd39a55f/1679640286500.png" alt="1679640286500"></p><p>网络</p><h3 id="2-系统优化一些工具-查询指标判断是否符合标准"><a href="#2-系统优化一些工具-查询指标判断是否符合标准" class="headerlink" title="2 系统优化一些工具  查询指标判断是否符合标准"></a>2 系统优化一些工具 查询指标判断是否符合标准</h3><p>​	vmstat、sar、iostat、netstat、free、ps、top、iftop</p><p>​ <strong>top</strong>、uptime 检查系统整体的负载、承受能力；<br>​ sar、<strong>iostat</strong>	、<strong>top</strong> 检测是否是CPU瓶颈；<br>​ free、<strong>vmstat</strong> <strong>top</strong> 检测是否是内存瓶颈；<br>​ <strong>iostat</strong>、iotop	<strong>top</strong> 检测是否是磁盘I&#x2F;O瓶颈；<br>​ <strong>netstat</strong>、<strong>iftop</strong> 检测是否是网络带宽瓶颈。</p><h3 id="3-linux-性能评估与优化"><a href="#3-linux-性能评估与优化" class="headerlink" title="3 linux 性能评估与优化"></a>3 linux 性能评估与优化</h3><h4 id="3-1-系统整体性能评估"><a href="#3-1-系统整体性能评估" class="headerlink" title="3.1 系统整体性能评估"></a>3.1 系统整体性能评估</h4><p>uptime:</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># uptime</span></span><br><span class="line"> <span class="number">04</span>:<span class="number">15</span>:<span class="number">24</span> up <span class="number">2</span> days, <span class="number">13</span>:<span class="number">05</span>,  <span class="number">1</span> <span class="keyword">user</span>,  <span class="built_in">load</span> average: <span class="number">0.01</span>, <span class="number">0.02</span>, <span class="number">0.05</span></span><br><span class="line">[root@localhost ~]<span class="comment"># </span></span><br><span class="line">现在时间、系统已经运行了多长时间、目前有多少登录用户、<span class="built_in">load</span> average:系统在过去的<span class="number">1</span>分钟、<span class="number">5</span>分钟和<span class="number">15</span>分钟内的平均负载。</span><br><span class="line"><span class="built_in">load</span> average:这三个值的大小一般不能大于系统CPU的核数*<span class="number">3</span>，例如，本输出中系统有<span class="number">8</span>个CPU,如果<span class="built_in">load</span> average的三个值长期大于<span class="number">8</span>时，说明CPU很繁忙，负载很高，可能会影响系统性能，但是偶尔大于<span class="number">8</span>时，倒不用担心，一般不会影响系统性能。</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># uptime -p   #以漂亮的格式显示机器正常运行的时间          </span></span><br><span class="line">up <span class="number">2</span> days, <span class="number">13</span> hours, <span class="number">9</span> minutes          </span><br><span class="line">[root@localhost ~]<span class="comment"># uptime -s   #系统自开始运行时间 年-月-日 小时-分钟-秒</span></span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">08</span> <span class="number">15</span>:<span class="number">09</span>:<span class="number">34</span></span><br><span class="line">[root@localhost ~]<span class="comment"># uptime -h   #显示帮助信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">服务器<span class="number">1</span>： <span class="built_in">load</span> average: <span class="number">0.15</span>, <span class="number">0.08</span>, <span class="number">0.01</span> <span class="number">1</span>核</span><br><span class="line">服务器<span class="number">2</span>： <span class="built_in">load</span> average: <span class="number">4.15</span>, <span class="number">6.08</span>, <span class="number">6.01</span> <span class="number">1</span>核</span><br><span class="line">服务器<span class="number">3</span>： <span class="built_in">load</span> average: <span class="number">10.15</span>, <span class="number">10.08</span>,<span class="number">10.01</span> <span class="number">4</span>核</span><br><span class="line">答案：服务器<span class="number">2</span></span><br><span class="line">如果服务器的CPU为<span class="number">1</span>核心，则<span class="built_in">load</span> average中的数字 &gt;=<span class="number">3</span> 负载过高，如果服务器的CPU为<span class="number">4</span>核心，则<span class="built_in">load</span></span><br><span class="line">average中的数字 &gt;=<span class="number">12</span> 负载过高。</span><br><span class="line">经验：单核心，<span class="number">1</span>分钟的系统平均负载不要超过<span class="number">3</span>，就可以，这是个经验值</span><br></pre></td></tr></table></figure><p><strong>top的第一行就是上面uptime</strong></p><h4 id="3-2-CPU性能评估"><a href="#3-2-CPU性能评估" class="headerlink" title="3.2 CPU性能评估"></a>3.2 CPU性能评估</h4><p>1.vmstat 命令(监控系统CPU)</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vmstat </span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -<span class="built_in">system</span>-- ------cpu-----</span><br><span class="line"> r  <span class="keyword">b</span>   swpd   free   buff  cache   si   <span class="keyword">so</span>    bi    <span class="keyword">bo</span>   in   <span class="keyword">cs</span> us <span class="keyword">sy</span> id <span class="keyword">wa</span> <span class="keyword">st</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">0</span>      <span class="number">0</span> <span class="number">3059368</span>   <span class="number">2104</span> <span class="number">230268</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>   <span class="number">28</span>   <span class="number">26</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">100</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">r列表示运行和等待cpu时间片的进程数，这个值如果长期大于系统CPU的个数，说明CPU不足，需要增加CPU。</span><br><span class="line"></span><br><span class="line"><span class="keyword">b</span>列表示在等待资源的进程数，比如正在等待I/O、或者内存交换等。</span><br><span class="line"></span><br><span class="line">us列显示了用户进程消耗的CPU 时间百分比。us的值比较高时，说明用户进程消耗的cpu时间多，但是如果长期大于<span class="number">50</span>%，就需要考虑优化程序或算法。</span><br><span class="line"></span><br><span class="line"><span class="keyword">sy</span>列显示了内核进程消耗的CPU时间百分比。Sy的值较高时，说明内核消耗的CPU资源很多。</span><br><span class="line">根据经验，us+<span class="keyword">sy</span>的参考值为<span class="number">70</span>%，如果us+<span class="keyword">sy</span>大于 <span class="number">70</span>%说明可能存在CPU资源不足。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.top命令(实时监控系统CPU)</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># top</span></span><br><span class="line">top - 04:50:43 up<span class="number"> 2 </span>days, 13:41, <span class="number"> 1 </span>user,  load average: 0.10, 0.06, 0.06</span><br><span class="line">Tasks:<span class="number"> 102 </span>total,  <span class="number"> 1 </span>running,<span class="number"> 101 </span>sleeping,  <span class="number"> 0 </span>stopped,  <span class="number"> 0 </span>zombie</span><br><span class="line">%Cpu(s):  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem : <span class="number"> 3865308 </span>total, <span class="number"> 2912528 </span>free,  <span class="number"> 573852 </span>used,  <span class="number"> 378928 </span>buff/cache</span><br><span class="line">KiB Swap:  <span class="number"> 524284 </span>total,  <span class="number"> 524284 </span>free,       <span class="number"> 0 </span>used. <span class="number"> 3028580 </span>avail Mem </span><br><span class="line"></span><br><span class="line">   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND            </span><br><span class="line"><span class="number"> 38151 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.3  0.0   0:01.93 kworker/0:0        </span><br><span class="line">    <span class="number"> 1 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span><span class="number"> 125332 </span> <span class="number"> 3828 </span> <span class="number"> 2496 </span>S   0.0  0.1   0:04.48 systemd            </span><br><span class="line">    <span class="number"> 2 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>     <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>S   0.0  0.0   0:00.33 kthreadd</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"> top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，常用于服务端性能分析。</span><br><span class="line"></span><br><span class="line">第一行数据相当于uptime命令输出。11:00:54是当前时间，up<span class="number"> 54 </span>days,23:55 是系统已经运行的时间，6 users表示当前有6个用户在登录，load average：16.32，18.75，21.04分别表示系统一分钟平均负载，5分钟平均负载，15分钟平均负载。</span><br><span class="line"></span><br><span class="line">平均负载</span><br><span class="line">平均负载表示的平均活跃进程数，包括正在running的进程数，准备running（就绪态）的进程数，和处于不可中断睡眠状态的进程数。如果平均负载数刚好等于CPU核数，那证明每个核都能得到很好的利用，如果平均负载数大于核数证明系统处于过载的状态，通常认为是超过核数的70%认为是严重过载，需要关注。还需结合1分钟平均负载，5分钟平均负载，15分钟平均负载看负载的趋势，如果1分钟负载比较高，5分钟和15分钟的平均负载都比较低，则说明是瞬间升高，需要观察。如果三个值都很高则需要关注下是否某个进程在疯狂消耗CPU或者有频繁的IO操作，也有可能是系统运行的进程太多，频繁的进程切换导致。比如说上面的演示环境是一台8核的centos机器，证明系统是长期处于过载状态在运行。</span><br><span class="line"></span><br><span class="line">第二行的Tasks信息展示的系统运行的整体进程数量和状态信息。102 total 表示系统现在一共有102个用户进程，1 running 1个进程正在处于running状态，101 sleeping 表示101 个进程正处于sleeping状态，0 stopped 表示<span class="number"> 0 </span>个进程正处于stopped状态，0 zombie表示 有0个僵尸进程。</span><br><span class="line"></span><br><span class="line">第3行的%Cpu(s)表示的是总体CPU使用情况。</span><br><span class="line">us user 表示用户态的CPU时间比例</span><br><span class="line">sy system 表示内核态的CPU时间比例</span><br><span class="line">ni nice 表示运行低优先级进程的CPU时间比例</span><br><span class="line">id idle 表示空闲CPU时间比例</span><br><span class="line">wa iowait 表示处于IO等待的CPU时间比例</span><br><span class="line">hi hard interrupt 表示处理硬中断的CPU时间比例</span><br><span class="line">si soft interrupt 表示处理软中断的CPU时间比例</span><br><span class="line">st steal 表示当前系统运行在虚拟机中的时候，被其他虚拟机占用的CPU时间比例。</span><br><span class="line"></span><br><span class="line">第4，5行显示的是系统内存使用情况。单位是KiB。totol 表示总内存，free 表示没使用过的内容，used是已经使用的内存。buff表示用于读写磁盘缓存的内存，cache表示用于读写文件缓存的内存。avail表示可用的应用内存。</span><br><span class="line"></span><br><span class="line">第6行开始往后表示的是具体的每个进程状态：</span><br><span class="line"></span><br><span class="line">PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND </span><br><span class="line">PID 进程ID</span><br><span class="line">USER 进程所有者的用户名，例如root</span><br><span class="line">PR 进程调度优先级</span><br><span class="line">NI 进程nice值（优先级），越小的值代表越高的优先级</span><br><span class="line">VIRT 进程使用的虚拟内存</span><br><span class="line">RES 进程使用的物理内存（不包括共享内存）</span><br><span class="line">SHR 进程使用的共享内存</span><br><span class="line">CPU 进程使用的CPU占比</span><br><span class="line">MEM 进程使用的内存占比</span><br><span class="line">TIME 进程启动后到现在所用的全部CPU时间</span><br><span class="line">COMMAND 进程的启动命令（默认只显示二进制，top -c能够显示命令行和启动参数）</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-3-内存性能评估"><a href="#3-3-内存性能评估" class="headerlink" title="3.3 内存性能评估"></a>3.3 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>性能评估</h4><p><em><strong>free指令监控内存</strong></em></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># free -m</span></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:          <span class="number"> 3774 </span>       <span class="number"> 560 </span>      <span class="number"> 2844 </span>         <span class="number"> 8 </span>       <span class="number"> 370 </span>       2957</span><br><span class="line">Swap:          <span class="number"> 511 </span>         <span class="number"> 0 </span>        511</span><br><span class="line">[root@localhost ~]<span class="comment"># </span></span><br><span class="line">一般有这样一个经验公式：应用程序可用内存/系统物理内存&gt;70%时，表示系统内存资源非常充足，不影响系统性能，应用程序可用内存/系统物理内存&lt;20%时，表示系统内存资源紧缺，需要增加系统内存</span><br><span class="line">20%&lt;应用程序可用内存/系统物理内存&lt;70%时，表示系统内存资源基本能满足应用需求，暂时不影响系统性能。</span><br></pre></td></tr></table></figure><h4 id="3-4-磁盘I-O性能评估"><a href="#3-4-磁盘I-O性能评估" class="headerlink" title="3.4 磁盘I&#x2F;O性能评估"></a>3.4 磁盘I&#x2F;O性能评估</h4><p><em><strong>iostat命令</strong></em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">iostat被用于监视系统输入输出设备和CPU的使用情况。它的特点是汇报磁盘活动统计情况，同时也会汇报出CPU使用情况。</span><br><span class="line">[root@localhost ~]<span class="comment"># iostat</span></span><br><span class="line">-bash: iostat: <span class="built_in">command</span> not found</span><br><span class="line">[root@localhost ~]<span class="comment"># yum -y install sysstat</span></span><br><span class="line">[root@localhost ~]<span class="comment"># iostat -d 1 10              #没隔1秒，持续10次</span></span><br><span class="line">Linux 3.10.0-693.el7.x86_64 (localhost.localdomain)     06/11/2021      _x86_64_        (2 CPU)</span><br><span class="line"></span><br><span class="line">Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn</span><br><span class="line">sda               0.08         1.36         0.66     304530     146757</span><br><span class="line">scd0              0.00         0.00         0.00       1028          0</span><br><span class="line">dm-0              0.00         0.01         0.00       2228          0</span><br><span class="line"></span><br><span class="line">对上面每项的输出解释如下：</span><br><span class="line">kB_read/s表示每秒读取的数据块数。</span><br><span class="line">kB_wrtn/s表示每秒写入的数据块数。</span><br><span class="line">kB_read表示读取的所有块数。</span><br><span class="line">kB_wrtn表示写入的所有块数。</span><br><span class="line">可以通过kB_read/s和kB_wrtn/s的值对磁盘的读写性能有一个基本的了解，如果kB_wrtn/s值很大，表示磁盘的写操作很频繁，可以考虑优化磁盘或者优化程序，如果kB_read/s值很大，表示磁盘直接读取操作很多，可以将读取的数据放入内存中进行操作。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em><strong>sar 命令系统运行状态统计</strong></em></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">通过<span class="variable">sar</span> <span class="operator">-</span><span class="variable">d</span>组合，可以对系统的磁盘<span class="variable">IO</span>做一个基本的统计，请看下面的一个输出</span><br><span class="line"></span><br><span class="line"><span class="punctuation">[</span><span class="variable">root</span><span class="operator">@</span><span class="variable">localhost</span> <span class="operator">~</span><span class="punctuation">]</span><span class="type">#</span> <span class="variable">sar</span> <span class="operator">-</span><span class="variable">d</span> <span class="number">2</span> <span class="number">6</span></span><br><span class="line"><span class="variable">Linux</span> <span class="number">3.10</span><span class="number">.0</span><span class="operator">-</span><span class="number">693.</span><span class="variable">el7</span><span class="operator">.</span><span class="type">x86_</span><span class="number">64</span> <span class="punctuation">(</span><span class="variable">localhost</span><span class="operator">.</span><span class="variable">localdomain</span><span class="punctuation">)</span>     <span class="number">06</span><span class="operator">/</span><span class="number">11</span><span class="operator">/</span><span class="number">2021</span>      <span class="type">_x86</span><span class="type">_</span><span class="number">64</span><span class="type">_</span>        <span class="punctuation">(</span><span class="number">2</span> <span class="variable">CPU</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="number">05</span><span class="operator">:</span><span class="number">46</span><span class="operator">:</span><span class="number">58</span> <span class="variable">AM</span>       <span class="variable">DEV</span>       <span class="variable">tps</span>  <span class="type">rd_sec</span><span class="operator">/</span><span class="variable">s</span>  <span class="type">wr_sec</span><span class="operator">/</span><span class="variable">s</span>  <span class="variable">avgrq</span><span class="operator">-</span><span class="variable">sz</span>  <span class="variable">avgqu</span><span class="operator">-</span><span class="variable">sz</span>     <span class="variable">await</span>     <span class="variable">svctm</span>     <span class="operator">%</span><span class="variable">util</span></span><br><span class="line"><span class="number">05</span><span class="operator">:</span><span class="number">47</span><span class="operator">:</span><span class="number">00</span> <span class="variable">AM</span>    <span class="variable">dev8</span><span class="operator">-</span><span class="number">0</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br><span class="line"><span class="number">05</span><span class="operator">:</span><span class="number">47</span><span class="operator">:</span><span class="number">00</span> <span class="variable">AM</span>   <span class="variable">dev11</span><span class="operator">-</span><span class="number">0</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br><span class="line"><span class="number">05</span><span class="operator">:</span><span class="number">47</span><span class="operator">:</span><span class="number">00</span> <span class="variable">AM</span>  <span class="variable">dev253</span><span class="operator">-</span><span class="number">0</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">需要关注的几个参数含义：</span><br><span class="line"><span class="variable">await</span>表示平均每次设备<span class="built_in">I</span><span class="operator">/</span><span class="built_in">O</span>操作的等待时间（以毫秒为单位）。</span><br><span class="line"><span class="variable">svctm</span>表示平均每次设备<span class="built_in">I</span><span class="operator">/</span><span class="built_in">O</span>操作的服务时间（以毫秒为单位）。</span><br><span class="line"><span class="operator">%</span><span class="variable">util</span>表示一秒中有百分之几的时间用于<span class="built_in">I</span><span class="operator">/</span><span class="built_in">O</span>操作。</span><br><span class="line">对以磁盘<span class="variable">IO</span>性能，一般有如下评判标准：</span><br><span class="line">正常情况下<span class="variable">svctm</span>应该是小于<span class="variable">await</span>值的，而<span class="variable">svctm</span>的大小和磁盘性能有关，<span class="variable">CPU</span>、内存的负荷也会对<span class="variable">svctm</span>值造成影响，过多的请求也会间接的导致<span class="variable">svctm</span>值的增加。</span><br><span class="line"><span class="variable">await</span>值的大小一般取决与<span class="variable">svctm</span>的值和<span class="built_in">I</span><span class="operator">/</span><span class="built_in">O</span>队列长度以及<span class="built_in">I</span><span class="operator">/</span><span class="built_in">O</span>请求模式，如果<span class="variable">svctm</span>的值与<span class="variable">await</span>很接近，表示几乎没有<span class="built_in">I</span><span class="operator">/</span><span class="built_in">O</span>等待，磁盘性能很好，如果<span class="variable">await</span>的值远高于<span class="variable">svctm</span>的值，则表示<span class="built_in">I</span><span class="operator">/</span><span class="built_in">O</span>队列等待太长，系统上运行的应用程序将变慢，此时可以通过更换更快的硬盘来解决问题。</span><br><span class="line"><span class="operator">%</span><span class="variable">util</span>项的值也是衡量磁盘<span class="built_in">I</span><span class="operator">/</span><span class="built_in">O</span>的一个重要指标，如果<span class="operator">%</span><span class="variable">util</span>接近<span class="number">100</span><span class="operator">%</span>，表示磁盘产生的<span class="built_in">I</span><span class="operator">/</span><span class="built_in">O</span>请求太多，<span class="built_in">I</span><span class="operator">/</span><span class="built_in">O</span>系统已经满负荷的在工作，该磁盘可能存在瓶颈。长期下去，势必影响系统的性能，可以通过优化程序或者通过更换更高、更快的磁盘来解决此问题。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-5-网络性能评估"><a href="#3-5-网络性能评估" class="headerlink" title="3.5 网络性能评估"></a>3.5 网络性能评估</h4><p>常用命令</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">通过ping命令 检测网络的连通性；</span><br><span class="line">通过netstat –<span class="selector-tag">i</span> 组合检测网络接口状况；</span><br><span class="line">通过netstat –r组合 检测系统的路由表信息；</span><br><span class="line"></span><br><span class="line">通过sar -n组合 显示系统的网络运行状态；</span><br><span class="line">ifconfig查看网卡</span><br><span class="line">通过iftop -<span class="selector-tag">i</span> eth0 查看网卡流量；</span><br><span class="line">fping 检测主机是否存在</span><br></pre></td></tr></table></figure><p><strong>iftop</strong></p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iftop是一款实时流量监控工具,监控TCP/IP连接等,缺点就是无报表功能。必须以root身份才能运行</span><br><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># yum -y install iftop</span></span><br><span class="line"></span><br><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># iftop           #默认监控第一块网卡的流量</span></span><br><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># iftop -i ens33  #指定监控ens33网卡流量</span></span><br><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># iftop -n        #直接显示IP, 不进行DNS反解析</span></span><br><span class="line"></span><br><span class="line">tx(发送) rx(接受) total(总) cum(监控到现在总) peek(峰值) rates </span><br></pre></td></tr></table></figure><p>fping</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">检测<span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span>到<span class="number">192.168</span><span class="number">.1</span><span class="number">.10</span>之间的主机是否存在：</span><br><span class="line"></span><br><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># fping -a -g 192.168.1.1 192.168.1.10</span></span><br><span class="line">检测<span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span>/<span class="number">24</span>的主机是否存在：</span><br><span class="line"></span><br><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># fping -a -g 192.168.1.1/24  </span></span><br><span class="line">将IP列表放在一个文件里面，通过读取文件来检测列表里的主机是否存在：</span><br><span class="line"></span><br><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># fping -a -f ip.txt </span></span><br><span class="line">检测www.baidu.com是否存在：</span><br><span class="line"></span><br><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta">#  fping www.baidu.com</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-系统优化实战"><a href="#4-系统优化实战" class="headerlink" title="4 系统优化实战"></a>4 系统优化实战</h3><h4 id="4-1找出系统中使用CPU最多的进程"><a href="#4-1找出系统中使用CPU最多的进程" class="headerlink" title="4.1找出系统中使用CPU最多的进程"></a>4.1找出系统中使用CPU最多的进程</h4><p>​ ps -aux –sort -pcpu | more</p><h4 id="4-2找出系统中使用内存最多的进程"><a href="#4-2找出系统中使用内存最多的进程" class="headerlink" title="4.2找出系统中使用内存最多的进程"></a>4.2找出系统中使用内存最多的进程</h4><p>​ ps -aux –sort -rss | more</p><h4 id="4-3-找出系统中对磁盘读写最多的进程"><a href="#4-3-找出系统中对磁盘读写最多的进程" class="headerlink" title="4.3 找出系统中对磁盘读写最多的进程"></a>4.3 找出系统中对磁盘读写最多的进程</h4><p>​ iotop</p><h4 id="4-4-找出系统中使用网络最多的进程"><a href="#4-4-找出系统中使用网络最多的进程" class="headerlink" title="4.4 找出系统中使用网络最多的进程"></a>4.4 找出系统中使用网络最多的进程</h4><p>​ <em><strong>nload 监控总体带宽使用情况</strong></em></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">root@localhost</span> <span class="string">~</span>]<span class="comment"># yum install nload -y     #安装nload工具</span></span><br><span class="line"></span><br><span class="line">[<span class="string">root@localhost</span> <span class="string">~</span>]<span class="comment"># nload                    #开启监控</span></span><br><span class="line"></span><br><span class="line"><span class="string">另外重新打开一个终端，然后产生一些测试数据</span></span><br><span class="line">[<span class="string">root@localhost</span> <span class="string">~</span>]<span class="comment"># ab -n 1000 -c 2 http://www.baidu.com/index.html </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">测试结果</span></span><br><span class="line">[<span class="string">root@localhost</span> <span class="string">~</span>]<span class="comment"># nload</span></span><br><span class="line"><span class="string">Device</span> <span class="string">ens33</span> [<span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span>] <span class="string">(1/2):</span></span><br><span class="line"><span class="string">=========================================================================================</span></span><br><span class="line"><span class="attr">Incoming:</span></span><br><span class="line">                                                          <span class="comment">#</span></span><br><span class="line">                                                          <span class="comment">#</span></span><br><span class="line">                                                          <span class="comment">#</span></span><br><span class="line">                                                          <span class="comment">#  Curr: 28.07 MBit/s</span></span><br><span class="line">                                                          <span class="comment">#  Avg: 28.07 MBit/s</span></span><br><span class="line">                                                          <span class="comment">#  Min: 28.07 MBit/s</span></span><br><span class="line">                                                          <span class="comment">#  Max: 28.07 MBit/s</span></span><br><span class="line">                                                          <span class="comment">#  Ttl: 145.24 MByte</span></span><br><span class="line"><span class="attr">Outgoing:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                                             <span class="attr">Curr:</span> <span class="number">350.62</span> <span class="string">kBit/s</span></span><br><span class="line">                                                             <span class="attr">Avg:</span> <span class="number">350.62</span> <span class="string">kBit/s</span></span><br><span class="line">                                                             <span class="attr">Min:</span> <span class="number">350.62</span> <span class="string">kBit/s</span></span><br><span class="line">                                                             <span class="attr">Max:</span> <span class="number">350.62</span> <span class="string">kBit/s</span></span><br><span class="line">                                                          <span class="string">.</span>  <span class="attr">Ttl:</span> <span class="number">4.76</span> <span class="string">MByte</span></span><br><span class="line"><span class="string">Device</span> <span class="string">ens33</span> [<span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span>] <span class="string">(1/2):</span></span><br><span class="line"><span class="string">=========================================================================================</span></span><br><span class="line"><span class="attr">Incoming:</span></span><br><span class="line">                                                         <span class="comment">##</span></span><br><span class="line">                                                         <span class="comment">##</span></span><br><span class="line">                                                         <span class="comment">##</span></span><br><span class="line">                                                         <span class="comment">##  Curr: 28.48 MBit/s</span></span><br><span class="line">                                                         <span class="comment">##  Avg: 28.48 MBit/s</span></span><br><span class="line">                                                         <span class="comment">##  Min: 28.07 MBit/s</span></span><br><span class="line">                                                         <span class="comment">##  Max: 28.48 MBit/s</span></span><br><span class="line">                                                         <span class="comment">##  Ttl: 147.06 MByte</span></span><br><span class="line"><span class="attr">Outgoing:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                                             <span class="attr">Curr:</span> <span class="number">353.68</span> <span class="string">kBit/s</span></span><br><span class="line">                                                             <span class="attr">Avg:</span> <span class="number">353.68</span> <span class="string">kBit/s</span></span><br><span class="line">                                                             <span class="attr">Min:</span> <span class="number">350.62</span> <span class="string">kBit/s</span></span><br><span class="line">                                                             <span class="attr">Max:</span> <span class="number">353.68</span> <span class="string">kBit/s</span></span><br><span class="line">                                                         <span class="string">..</span>  <span class="attr">Ttl:</span> <span class="number">4.79</span> <span class="string">MByte</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em><strong>nethogs 使用带宽最多的进程</strong></em></p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># yum -y install nethogs  #安装nethogs工具</span></span><br><span class="line"></span><br><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># nethogs                 #开启监控</span></span><br><span class="line"></span><br><span class="line">在另外开一个终端下载 wget东西</span><br><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># wget https://downloads.mysql.com/archives/get/p/23/file/mysql-5.6.20.tar.gz</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">监控测试显示结果</span><br><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># nethogs</span></span><br><span class="line">Ethernet link detected</span><br><span class="line">                      Waiting <span class="keyword">for</span> first packet <span class="keyword">to</span> arrive (see sourceforge.net bug <span class="number">1019381</span>)</span><br><span class="line">NetHogs version <span class="number">0.8</span><span class="number">.5</span></span><br><span class="line"></span><br><span class="line">    PID USER     PROGRAM                             DEV        SENT      RECEIVED       </span><br><span class="line">  <span class="number">39738</span> root     wget                                ens33      <span class="number">21.877</span>    <span class="number">4158.442</span> KB/sec</span><br><span class="line">  <span class="number">38492</span> root     sshd: root<span class="symbol">@pts</span>/<span class="number">0</span>                    ens33       <span class="number">0.870</span>       <span class="number">0.211</span> KB/sec</span><br><span class="line">      ? root     unknown TCP                                     <span class="number">0.000</span>       <span class="number">0.000</span> KB/sec</span><br><span class="line"></span><br><span class="line">  TOTAL                                                         <span class="number">22.747</span>    <span class="number">4158.653</span> KB/sec</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-5-优化linux文件打开最大数"><a href="#4-5-优化linux文件打开最大数" class="headerlink" title="4.5 优化linux文件打开最大数"></a>4.5 优化linux文件打开最大数</h4><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在生产环境中，由于某些软件、应用程序发挥最大的性能，使用Linux内核默认资源显然不够的，要对Linux内核资源进行重新修改和调整，对Linux内核资源进行优化</span><br><span class="line"></span><br><span class="line">默认Linux内核对每个用户设置了打开文件最大数为<span class="number">1024</span>，对于高并发网站，是远远不够的，需要将默认值调整到更大</span><br><span class="line"></span><br><span class="line">inux每个用户打开文件最大数永久设置方法，将如下代码加入内核限制文件/etc/security/limits.conf的末尾：</span><br><span class="line"><span class="comment">* 	soft 	noproc			65535</span></span><br><span class="line"><span class="comment">* 	hard 	noproc			65535</span></span><br><span class="line"><span class="comment">* 	soft 	nofile			65535</span></span><br><span class="line"><span class="comment">* 	hard 	nofile			65535</span></span><br><span class="line">如上设置为对每个用户分别设置nofile、noproc最大数，如果需要对Linux整个系统设置文件最大数限制，需要修改/proc/sys/fs/<span class="keyword">file</span>-<span class="built_in">max</span>中的值，该值为Linux总文件打开数，</span><br><span class="line">例如设置为：echo <span class="number">3865161233</span> &gt;/proc/sys/fs/<span class="keyword">file</span>-<span class="built_in">max</span>。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-6-内核参数优化"><a href="#4-6-内核参数优化" class="headerlink" title="4.6 内核参数优化"></a>4.6 内核参数优化</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysctl<span class="selector-class">.conf</span></span><br><span class="line">net<span class="selector-class">.ipv4</span><span class="selector-class">.tcp_max_tw_buckets</span> = <span class="number">6000</span></span><br><span class="line">timewait的数量，默认是<span class="number">180000</span>。</span><br><span class="line">net<span class="selector-class">.ipv4</span><span class="selector-class">.ip_local_port_range</span> = <span class="number">1024</span>    <span class="number">65000</span></span><br><span class="line">允许系统打开的端口范围。</span><br><span class="line">net<span class="selector-class">.ipv4</span><span class="selector-class">.tcp_tw_recycle</span> = <span class="number">1</span></span><br><span class="line">启用timewait快速回收。</span><br><span class="line">net<span class="selector-class">.ipv4</span><span class="selector-class">.tcp_tw_reuse</span> = <span class="number">1</span></span><br><span class="line">开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接。</span><br><span class="line">net<span class="selector-class">.ipv4</span><span class="selector-class">.tcp_syncookies</span> = <span class="number">1</span></span><br><span class="line">开启SYN Cookies，当出现SYN等待队列溢出时，启用cookies来处理。</span><br><span class="line">net<span class="selector-class">.core</span><span class="selector-class">.somaxconn</span> = <span class="number">262144</span></span><br><span class="line">web应用中listen函数的backlog默认会给我们内核参数的net<span class="selector-class">.core</span>.somaxconn限制到<span class="number">128</span>，而nginx定义的NGX_LISTEN_BACKLOG默认为<span class="number">511</span>，所以有必要调整这个值。</span><br><span class="line">net<span class="selector-class">.core</span><span class="selector-class">.netdev_max_backlog</span> = <span class="number">262144</span></span><br><span class="line">每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。</span><br><span class="line">net<span class="selector-class">.ipv4</span><span class="selector-class">.tcp_max_orphans</span> = <span class="number">262144</span></span><br><span class="line">系统中最多有多少个TCP套接字不被关联到任何一个用户文件句柄上。如果超过这个数字，孤儿连接将即刻被复位并打印出警告信息。这个限制仅仅是为了防止简单的DoS攻击，不能过分依靠它或者人为地减小这个值，更应该增加这个值(如果增加了内存之后)。</span><br><span class="line">net<span class="selector-class">.ipv4</span><span class="selector-class">.tcp_max_syn_backlog</span> = <span class="number">262144</span></span><br><span class="line">记录的那些尚未收到客户端确认信息的连接请求的最大值。对于有<span class="number">128</span>M内存的系统而言，缺省值是<span class="number">1024</span>，小内存的系统则是<span class="number">128</span>。</span><br><span class="line">net<span class="selector-class">.ipv4</span><span class="selector-class">.tcp_timestamps</span> = <span class="number">0</span></span><br><span class="line">时间戳可以避免序列号的卷绕。一个<span class="number">1</span>Gbps的链路肯定会遇到以前用过的序列号。时间戳能够让内核接受这种“异常”的数据包。这里需要将其关掉。</span><br><span class="line">net<span class="selector-class">.ipv4</span><span class="selector-class">.tcp_synack_retries</span> = <span class="number">1</span></span><br><span class="line">为了打开对端的连接，内核需要发送一个SYN并附带一个回应前面一个SYN的ACK。也就是所谓三次握手中的第二次握手。这个设置决定了内核放弃连接之前发送SYN+ACK包的数量。</span><br><span class="line">net<span class="selector-class">.ipv4</span><span class="selector-class">.tcp_syn_retries</span> = <span class="number">1</span></span><br><span class="line">在内核放弃建立连接之前发送SYN包的数量。</span><br><span class="line">net<span class="selector-class">.ipv4</span><span class="selector-class">.tcp_fin_timeout</span> = <span class="number">1</span></span><br><span class="line">如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-<span class="number">2</span>状态的时间。对端可以出错并永远不关闭连接，甚至意外当机。缺省值是<span class="number">60</span>秒。<span class="number">2.2</span> 内核的通常值是<span class="number">180</span>秒，你可以按这个设置，但要记住的是，即使你的机器是一个轻载的WEB服务器，也有因为大量的死套接字而内存溢出的风险，FIN- WAIT-<span class="number">2</span>的危险性比FIN-WAIT-<span class="number">1</span>要小，因为它最多只能吃掉<span class="number">1.5</span>K内存，但是它们的生存期长些。</span><br><span class="line">net<span class="selector-class">.ipv4</span><span class="selector-class">.tcp_keepalive_time</span> = <span class="number">30</span></span><br><span class="line">当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是<span class="number">2</span>小时。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>top: cpu,内存,io</p><p>iftop:网络</p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>查看最大</p><p>ps -aux –sort -pcpu | more</p><p>ps -aux –sort -rss | more</p><p>iotop</p><p>nethogos</p><p>nload</p><p>有没有做过linux系统优化?? 简单做过</p><p>1 程序部署到服务器如果出问题? 查看cpu,内存,io,网络指标</p><p>2 如果某个超标</p><p>​ 有事没事就top</p><p>3 查找使用多程序 ,分析程序是否正常占用,如果正常!可能硬件不行更换硬件就ok,否则就改代码.</p><p>​ ps cpu</p><p>​ ps 内存</p><p>​ io Iotop</p><p>网络 nethgos</p><p>​ 递归查询无限极树?? 磁盘</p><p>要执行命令?? 人为触发!! 监控平台,超标了还会发邮件或者短信</p><p><img src="/breeze/dd39a55f/1698313376596.png" alt="1698313376596"></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://mliutm.github.io">清风</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://mliutm.github.io/breeze/dd39a55f.html">https://mliutm.github.io/breeze/dd39a55f.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://mliutm.github.io" target="_blank">清风</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post_share"><div class="social-share" data-image="/img/photo-1692708632140-ee01624d558d.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/breeze/4b0178e0.html" title="数据结构与算法"><img class="cover" src="/img/photo-1645943020355-305df166473d.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据结构与算法</div></div></a></div><div class="next-post pull-right"><a href="/breeze/613abb62.html" title="基础设计模式与框架源码"><img class="cover" src="/img/photo-1645943020355-305df166473d.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">基础设计模式与框架源码</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/breeze/ad9d3fb.html" title="Linux进阶"><img class="cover" src="/img/premium_photo-1695185954894-e9382c6f4da8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-22</div><div class="title">Linux进阶</div></div></a></div><div><a href="/breeze/30b5ce3c.html" title="Linux入门"><img class="cover" src="/img/photo-1645943020355-305df166473d.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-22</div><div class="title">Linux入门</div></div></a></div><div><a href="/breeze/2c15b1bd.html" title="Linux面试题"><img class="cover" src="/img/photo-1688475747590-d0db5e2412cb.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-22</div><div class="title">Linux面试题</div></div></a></div><div><a href="/breeze/e82f7a4d.html" title="Multipass轻量化虚拟机管理系统"><img class="cover" src="/img/premium_photo-1695185954894-e9382c6f4da8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-22</div><div class="title">Multipass轻量化虚拟机管理系统</div></div></a></div><div><a href="/breeze/cdb50f96.html" title="Linux项目部署-RH"><img class="cover" src="/img/photo-1688475747590-d0db5e2412cb.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-22</div><div class="title">Linux项目部署-RH</div></div></a></div><div><a href="/breeze/eec933b0.html" title="centos系统"><img class="cover" src="/img/photo-1653549892896-dde02867edee.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-22</div><div class="title">centos系统</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">清风</div><div class="author-info__description">清风洒六合，邈然不可攀</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">169</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">82</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:huangpan0805@163.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div><timing></timing></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Linux%E4%BC%98%E5%8C%96"><span class="toc-text">基础源码分析&amp;Linux优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E7%AE%80%E4%BB%8B"><span class="toc-text">一 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%9F%BA%E7%A1%80%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%A4%9A%E4%B8%AA%E5%AD%97%E7%AC%A6-%E4%B8%B2%E6%88%90%E4%B8%B2"><span class="toc-text">二 基础源码分析-字符串(多个字符,串成串)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-String"><span class="toc-text">1 String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-StringBuilder"><span class="toc-text">2 StringBuilder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-StringBuffer"><span class="toc-text">3 StringBuffer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%92%8C-equals-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">7 &#x3D;&#x3D; 和 equals 的区别是什么</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB"><span class="toc-text">三 集合体系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Collection%E4%BD%93%E7%B3%BB%E5%9B%9E%E9%A1%BE-%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E7%9A%84%E5%80%BC"><span class="toc-text">1.Collection体系回顾-一个一个的值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-List%E4%BD%93%E7%B3%BB"><span class="toc-text">1.1.List体系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-Queue-%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-text">1.2.Queue-实现栈和队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-Set"><span class="toc-text">1.3.Set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E5%B8%B8%E8%A7%81%E9%9B%86%E5%90%88%E6%AF%94%E8%BE%83"><span class="toc-text">1.4.常见集合比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Map%E4%BD%93%E7%B3%BB%E5%9B%9E%E9%A1%BE-%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="toc-text">2.Map体系回顾-键值对</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-HashMap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-text">2.1. HashMap底层原理分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-HashMap%E5%AE%9A%E4%B9%89"><span class="toc-text">2.2.HashMap定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-HashMap%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-text">2.3.HashMap底层结构示意图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-HashMap%E5%BA%95%E5%B1%82%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-text">3.4.HashMap底层代码解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-text">3.5.遍历方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%98%E5%8C%96%E6%A6%82%E8%BF%B0"><span class="toc-text">四 服务器优化概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BD%B1%E5%93%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E5%9B%A0%E7%B4%A0"><span class="toc-text">1 影响服务器性能因素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E7%A1%AC%E4%BB%B6%E7%9B%B8%E5%85%B3"><span class="toc-text">1.1 硬件相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3"><span class="toc-text">1.2 软件相关</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%98%E5%8C%96"><span class="toc-text">2 服务器优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E7%A1%AC%E4%BB%B6%E4%BC%98%E5%8C%96"><span class="toc-text">2.1 硬件优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E8%BD%AF%E4%BB%B6%E4%BC%98%E5%8C%96"><span class="toc-text">2.2 软件优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-linux%E4%BC%98%E5%8C%96"><span class="toc-text">五 操作系统-linux优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E6%A0%87%E5%87%86"><span class="toc-text">1 系统性能评估标准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%E4%B8%80%E4%BA%9B%E5%B7%A5%E5%85%B7-%E6%9F%A5%E8%AF%A2%E6%8C%87%E6%A0%87%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E7%AC%A6%E5%90%88%E6%A0%87%E5%87%86"><span class="toc-text">2 系统优化一些工具 查询指标判断是否符合标准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-linux-%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="toc-text">3 linux 性能评估与优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E7%B3%BB%E7%BB%9F%E6%95%B4%E4%BD%93%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0"><span class="toc-text">3.1 系统整体性能评估</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-CPU%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0"><span class="toc-text">3.2 CPU性能评估</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E5%86%85%E5%AD%98%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0"><span class="toc-text">3.3 内存性能评估</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E7%A3%81%E7%9B%98I-O%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0"><span class="toc-text">3.4 磁盘I&#x2F;O性能评估</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0"><span class="toc-text">3.5 网络性能评估</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98"><span class="toc-text">4 系统优化实战</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1%E6%89%BE%E5%87%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E4%BD%BF%E7%94%A8CPU%E6%9C%80%E5%A4%9A%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-text">4.1找出系统中使用CPU最多的进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2%E6%89%BE%E5%87%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98%E6%9C%80%E5%A4%9A%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-text">4.2找出系统中使用内存最多的进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E6%89%BE%E5%87%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%AF%B9%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99%E6%9C%80%E5%A4%9A%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-text">4.3 找出系统中对磁盘读写最多的进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-%E6%89%BE%E5%87%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E6%9C%80%E5%A4%9A%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-text">4.4 找出系统中使用网络最多的进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-%E4%BC%98%E5%8C%96linux%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E6%9C%80%E5%A4%A7%E6%95%B0"><span class="toc-text">4.5 优化linux文件打开最大数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96"><span class="toc-text">4.6 内核参数优化</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/breeze/1d13ce0d.html" title="WYDG-产品目录列表-20200506"><img src="/img/photo-1645943020355-305df166473d.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="WYDG-产品目录列表-20200506"></a><div class="content"><a class="title" href="/breeze/1d13ce0d.html" title="WYDG-产品目录列表-20200506">WYDG-产品目录列表-20200506</a><time datetime="2025-04-13T05:43:05.000Z" title="发表于 2025-04-13 13:43:05">2025-04-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/breeze/6f268337.html" title="雨雀文件下载"><img src="/img/premium_photo-1695185954894-e9382c6f4da8.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="雨雀文件下载"></a><div class="content"><a class="title" href="/breeze/6f268337.html" title="雨雀文件下载">雨雀文件下载</a><time datetime="2024-05-22T12:25:08.000Z" title="发表于 2024-05-22 20:25:08">2024-05-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/breeze/7832219d.html" title="十万字面试总结"><img src="/img/premium_photo-1695185954894-e9382c6f4da8.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="十万字面试总结"></a><div class="content"><a class="title" href="/breeze/7832219d.html" title="十万字面试总结">十万字面试总结</a><time datetime="2024-02-29T02:50:00.000Z" title="发表于 2024-02-29 10:50:00">2024-02-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/breeze/7ae0ca37.html" title="Redis_30道经典面试题"><img src="/img/photo-1688475747590-d0db5e2412cb.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Redis_30道经典面试题"></a><div class="content"><a class="title" href="/breeze/7ae0ca37.html" title="Redis_30道经典面试题">Redis_30道经典面试题</a><time datetime="2024-02-29T02:45:00.000Z" title="发表于 2024-02-29 10:45:00">2024-02-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/breeze/2a548e97.html" title="面试实战"><img src="/img/photo-1645943020355-305df166473d.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="面试实战"></a><div class="content"><a class="title" href="/breeze/2a548e97.html" title="面试实战">面试实战</a><time datetime="2024-02-29T02:43:59.000Z" title="发表于 2024-02-29 10:43:59">2024-02-29</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/img/photo-1692708632140-ee01624d558d.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 <i id="heartbeat" class="fa fas fa-heartbeat"></i> 清风</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></head></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script src="/js/timing.js"></script><script id="canvas_nest" defer color="255,0,255" opacity="0.7" zindex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!0,document.body.addEventListener("input",POWERMODE)</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="天枢,天璇,天玑,天权,玉衡,开阳,瑶光" data-fontsize="15px" data-random="true" async></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>