<!DOCTYPE html><html class="hide-aside" lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>基础设计模式与框架源码 | 清风</title><meta name="author" content="清风"><meta name="copyright" content="清风"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="常用设计模式&amp;Spring源码分析课程内容 常用设计模式 Spring源码分析 SpringBoot源码分析 nacos源码  一.常用设计模式1.设计模式概述1.1.什么是设计模式​       设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，"><meta property="og:type" content="article"><meta property="og:title" content="基础设计模式与框架源码"><meta property="og:url" content="https://mliutm.github.io/breeze/613abb62.html"><meta property="og:site_name" content="清风"><meta property="og:description" content="常用设计模式&amp;Spring源码分析课程内容 常用设计模式 Spring源码分析 SpringBoot源码分析 nacos源码  一.常用设计模式1.设计模式概述1.1.什么是设计模式​       设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://mliutm.github.io/img/photo-1692708632140-ee01624d558d.jpg"><meta property="article:published_time" content="2024-01-14T13:43:09.000Z"><meta property="article:modified_time" content="2024-01-14T14:43:35.037Z"><meta property="article:author" content="清风"><meta property="article:tag" content="设计模式"><meta property="article:tag" content="框架源码"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://mliutm.github.io/img/photo-1692708632140-ee01624d558d.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://mliutm.github.io/breeze/613abb62.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,top_n_per_article:1,unescape:!1,languages:{hits_empty:"找不到您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!1,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"基础设计模式与框架源码",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-01-14 22:43:35"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,a){0!==a&&(a=864e5*a,t={value:t,expiry:(new Date).getTime()+a},localStorage.setItem(e,JSON.stringify(t)))},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!((new Date).getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=o=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.getCSS=(o,n=!1)=>new Promise((t,e)=>{const a=document.createElement("link");a.rel="stylesheet",a.href=o,n&&(a.id=n),a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">162</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/img/photo-1692708632140-ee01624d558d.jpg)"><nav id="nav"><span id="blog-info"><a href="/" title="清风"><span class="site-name">清风</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">基础设计模式与框架源码</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-14T13:43:09.000Z" title="发表于 2024-01-14 21:43:09">2024-01-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-14T14:43:35.037Z" title="更新于 2024-01-14 22:43:35">2024-01-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E8%83%BD%E6%8F%90%E5%8D%87/">技能提升</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>45分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="基础设计模式与框架源码"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="常用设计模式-Spring源码分析"><a href="#常用设计模式-Spring源码分析" class="headerlink" title="常用设计模式&amp;Spring源码分析"></a>常用设计模式&amp;Spring源码分析</h1><h3 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h3><ul><li>常用设计模式</li><li>Spring源码分析</li><li>SpringBoot源码分析</li><li>nacos源码</li></ul><h2 id="一-常用设计模式"><a href="#一-常用设计模式" class="headerlink" title="一.常用设计模式"></a>一.常用设计模式</h2><h3 id="1-设计模式概述"><a href="#1-设计模式概述" class="headerlink" title="1.设计模式概述"></a>1.设计模式概述</h3><h4 id="1-1-什么是设计模式"><a href="#1-1-什么是设计模式" class="headerlink" title="1.1.什么是设计模式"></a>1.1.什么是设计模式</h4><p>​ 设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。</p><p><strong>设计模式就是前人写代码的有些优秀经验模式，总结下来了。我们把它拿到我们项目中使用，让我们的代码更加优美，高效，可读性高。</strong></p><h4 id="1-2-设计模式分类"><a href="#1-2-设计模式分类" class="headerlink" title="1.2.设计模式分类"></a>1.2.设计模式分类</h4><p>总体来说设计模式分为三大类： 23</p><ul><li><p>创建型模式</p><p>共五种：<code>工厂</code>(简单工厂，工厂方法模式、抽象工厂模式)、<code>单例模式</code>、<code>建造者模式</code>、原型模式。</p></li><li><p>结构型模式</p><p>共七种：<code>适配器模式(adapter)</code>、<code>装饰器模式</code>、<code>代理模式</code>、外观模式、桥接模式、组合模式、<strong>享元模式</strong>(带缓存 共享)。</p></li><li><p>行为型模式</p><p>共十一种：<code>策略模式</code><strong>、<code>模板方法模式</code>、</strong><code>观察者模式（监听器）</code>、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p></li></ul><p>下面是场景的一些使用到涉及模式的类</p><ul><li><p>工厂：以Factory结尾的都是工厂，如：BeanFactory ， SqlSessionFactory</p></li><li><p>单例：工具类通常使用单例模式</p></li><li><p>建造者：一Builder结尾的 ，如 ：**NativeSearchQueryBuilder **</p></li><li><p>适配器模式：以Adapter结尾的，如：WebMvcConfigurationAdapter，HandlerInterceptorAdapter</p></li><li><p>装饰器：Decorator结尾的，如：AbstractListDecorator，AbstractMapDecorator , Spring中的 BeanDefinitionDecorator</p></li></ul><h3 id="2-常见的设计模式"><a href="#2-常见的设计模式" class="headerlink" title="2.常见的设计模式"></a>2.常见的设计模式</h3><h4 id="2-0-享元模式"><a href="#2-0-享元模式" class="headerlink" title="2.0 享元模式"></a>2.0 享元模式</h4><p>​	享元模式是一种设计模式<strong>，用于减少对象数量并降低内存消耗</strong>，<strong>通过缓存获取对象来实现</strong>。它适用于可以共享状态的对象，即多个对象具有相同的状态，而这些状态可以在内部类中共享。外部类作为享元模式的上下文，负责创建和返回内部类的实例，并将这些实例存储在一个共享的外部数据结构中。享元模式可以提高内存效率和对象重复使用率，但也可能增加系统复杂性和线程同步问题。因此，在使用享元模式时需要谨慎考虑其适用性和潜在问题。</p><p>​ byte(1个) short(2个字节) int(4个字节) long float double char(2个字节) boolean</p><p>对应缓存范围 Byte(-128-127) Short(-128-127) Integer(-128-127) Long(-128-127) Float(没有) Double(没有) Character(0-127) Boolean(true,false)</p><p>​ 装箱: 把基础类型包装为对应的包装类.</p><p>​ 自动装箱 :用包装类型直接引用基础类型 Integer i &#x3D; 1; 就相当于手动实现下面的装箱</p><p>​ 手动装箱: Integer i &#x3D; Integer.valueof(1);</p><p>​ 拆箱: 把包装类型包装为对应的基础类型.</p><p>​ 自动拆箱: Integer i &#x3D; 1; int j &#x3D; i;</p><p>​ 手动拆箱: Integer i &#x3D; 1; i.intValue();</p><p>1 有了基础数据类型,为什么还要包装类型??</p><p>​ 包装类型是类,里面就可以封装属性和方法,比如Integer它除了有value值,还有一些最大值,最小值的属性,并且</p><p>​ 提供了一个方法能够实现.</p><p>​ 包装类型的默认值是null,基础数据类型是0等,基础数据类型无法判断是赋值为0还是默认值. 也就是不能区分是否赋值. Long id; 所以一般我们在domain中使用的都是包装类型</p><p>2 共享对象(带缓存)—享元模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">           <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​ Integer i &#x3D; 1;</p><p>​ Integer j &#x3D; 1;</p><p>​ sout(i&#x3D;&#x3D;j); true</p><p>​ Integer i &#x3D; 128;</p><p>​ Integer j &#x3D; 128;</p><p>​ sout(i&#x3D;&#x3D;j); false</p><p>​ Integer i &#x3D; 1; &#x2F;&#x2F;装箱才带缓存</p><p>​ Integer j &#x3D; new Integer(1); &#x2F;&#x2F;直接new不带缓存</p><p>​ sout(i&#x3D;&#x3D;j); false</p><h4 id="2-1-单例"><a href="#2-1-单例" class="headerlink" title="2.1.单例"></a>2.1.单例</h4><p>什么是单例？<strong>一个类只有一个实例</strong>，比如：工具类(JdbcUtil)，Spring中对象默认都是单例。如何让类的实例只有一个？<strong>关键就在于不能让外界随意new 对象 ，这一点可以通过私有化构造器来实现</strong>。私有了构造器那该如何创建对象？<strong>可以在类中提供一个静态方法来创建该类的实例，要注意的是这个方法多次被调用也只会返回同一个实例。</strong> 而单例模式又分为饿汉式和懒汉式</p><h5 id="1-饿汉式"><a href="#1-饿汉式" class="headerlink" title="1.饿汉式"></a>1.饿汉式</h5><p>见名知意，饿汉是很饥饿的，意味着迫切，即一开始就需要创建好类的实例(类加载时就创建一个实例)，那么这种模式我们可以在类中定义一个私有的成员变量类型就是该类本身，然后直接new一个实例作为该变量的初始值，具体步骤如下：</p><ul><li><p>构造方法私有化</p></li><li><p>定义成员变量new一个实例作为初始值(饿)</p></li><li><p>提供获取实例的静态方法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单利模式 饿汉 ：工具类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JDBCUtil</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.定义成员变量，new实例作为初始值 ，饿汉：一来就创建实例，赋初始值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">JDBCUtil</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JDBCUtil</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.私有构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">JDBCUtil</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.提供获取实例方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JDBCUtil <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(JDBCUtil.getInstance());</span><br></pre></td></tr></table></figure><h5 id="2-懒汉式-volatile"><a href="#2-懒汉式-volatile" class="headerlink" title="2.懒汉式(***volatile)"></a>2.懒汉式(***volatile)</h5><p>它和饿汉式相反，懒汉是很懒惰的，一开始不会创建类的实例，而是在使用到类的实例的时候才会去创建，我们也可以为该类定义一个私有的成员变量，只不过不需要为它赋初始值，而是在需要用到该类的实例的时候再创建实例赋值，它的具体步骤如下：</p><ul><li><p>构造方法私有化</p></li><li><p>定义成员变量不赋初始值(懒)</p></li><li><p>提供获取实例的静态方法(保证单实例)</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单利模式 懒汉 ：工具类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JDBCUtil</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.定义成员变量，不赋初始值(懒)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">JDBCUtil</span> <span class="variable">instance</span>  <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.私有构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">JDBCUtil</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.提供获取实例方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JDBCUtil <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//第一次调用时创建对象</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">JDBCUtil</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(JDBCUtil.getInstance());</span><br></pre></td></tr></table></figure><p>上面的getInstance有一个小问题就是高并发时多个线程同时调用该方法可能会出现安全问题创建多个实例，可以通过同步锁来解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单利模式 懒汉 ：工具类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JDBCUtil</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.定义成员变量，不赋初始值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">JDBCUtil</span> <span class="variable">instance</span>  <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.私有构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">JDBCUtil</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.提供获取实例方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  JDBCUtil <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//第一次调用时创建对象</span></span><br><span class="line">            <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//同步代码块，保证创建实例的代码的原子性，只会创建一个实例</span></span><br><span class="line">                <span class="keyword">synchronized</span> (JDBCUtil.class)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">JDBCUtil</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(JDBCUtil.getInstance());</span><br></pre></td></tr></table></figure><p>注意：为了效率，同步锁不应该加载方法上，且是insance &#x3D;&#x3D; null 的情况下才会尝试获取锁，然后创建对象的实例，但是上面代码还是有一个小问题，就是如果多个线程都执行到了<strong>synchronized</strong> 代码块，但是只有一个线程能获取锁，并创建实例然后释放锁，这个时候第二个线程获取到锁依然会创建一次实例，就导致创建了多次实例。所以需要在同步代码块中再加一个判断，即：双重判断加同步代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">instance = <span class="keyword">new</span> <span class="title class_">JDBCUtil</span>(); -- 翻译为汇编指令</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/breeze/613abb62/1666862328335.png" alt="1666862328335"></p><p>​ cpu重排序优化有可能下下面也要执行</p><p><img src="/breeze/613abb62/1685931152932.png" alt="1685931152932"></p><p>给 instance实例加上volatile，禁止在创建对象是进行重排序了，也就是限初始化了才赋值。就不会出现没初始化的对象给别人用了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单利模式 懒汉 ：工具类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JDBCUtil</span>&#123;</span><br><span class="line">    <span class="comment">//1.定义成员变量，不赋初始值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">JDBCUtil</span> <span class="variable">instance</span>  <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//1.私有构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">JDBCUtil</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//2.提供获取实例方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  JDBCUtil <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="comment">//第一次调用时创建对象</span></span><br><span class="line">            <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//同步代码块，保证创建实例的代码的原子性，只会创建一个实例</span></span><br><span class="line">                <span class="keyword">synchronized</span> (JDBCUtil.class)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                        instance = <span class="keyword">new</span> <span class="title class_">JDBCUtil</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(JDBCUtil.getInstance());</span><br></pre></td></tr></table></figure><h5 id="3-枚举-自己实现单例建议用它"><a href="#3-枚举-自己实现单例建议用它" class="headerlink" title="3.枚举-自己实现单例建议用它"></a>3.枚举-自己实现单例建议用它</h5><p>还有一种常用的单利实现方式 - 枚举 ，枚举的构造器默认私有化的，为枚举类定义一个实例就是单利，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单利：枚举</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">JDBCUtil</span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(JDBCUtil.INSTANCE);</span><br></pre></td></tr></table></figure><h5 id="4-Map-spring"><a href="#4-Map-spring" class="headerlink" title="4 Map-spring"></a>4 Map-spring</h5><p>​ 第一次创建存,后面直接获取</p><h4 id="2-2-工厂"><a href="#2-2-工厂" class="headerlink" title="2.2.工厂"></a>2.2.工厂</h4><p>​ 工厂模式抽象于生活中的工厂，工厂的作用就是生产某种多种产品，工厂隐藏了(封装了)产品的复杂创建过程，以及可以实现生产功能复用的效果，让产品的生产更加方便和高效，而在Java语言中的工厂模式就是用来生成对象的。工厂分为三种：简单工厂，工厂方法，抽象工厂。该模式用于封装和管理对象的创建，是一种创建型模式。本文从一个具体的例子逐步深入分析，来体会三种工厂模式的应用场景和利弊。</p><h5 id="1-简单工厂"><a href="#1-简单工厂" class="headerlink" title="1.简单工厂"></a>1.简单工厂</h5><p>该模式对对象创建管理方式最为简单，因为其仅仅简单的对不同类对象的创建进行了一层薄薄的封装。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。其UML类图如下：</p><p><img src="/breeze/613abb62/1635664961056.png" alt="1635664961056"></p><p>代码举例：有2款手机，小米手机(“mi”) , 华为手机(“huawei”) ,两款手机都有打电话功能，所以定义如下代码</p><p>简单工厂的优缺点</p><ul><li><p>优点：简单工厂模式能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。明确区分了各自的职责和权力，有利于整个软件体系结构的优化。</p></li><li><p>缺点：很明显工厂类集中了所有实例的创建逻辑，容易违反GRASPR的高内聚的责任分配原则，所有的类型都用了同一个工厂去创建，试想一下如果我要增加一个手机类型，那么我的创建实例的工厂需要重新修改。</p></li></ul><h5 id="2-工厂方法"><a href="#2-工厂方法" class="headerlink" title="2.工厂方法"></a>2.工厂方法</h5><p>和简单工厂模式中工厂负责生产所有产品相比，工厂方法模式将生成具体产品的任务分发给具体的产品工厂，即：每个类型都搞一个工厂，然后为每个工厂在抽象一个工厂。</p><p>举例：一个工厂又要创建小米，又要创建华为，本身比较混乱了，如果又新加了一个产品苹果，如果我在已有的工厂继续增加生成苹果的的业务，那么会把我的生成线搞得更乱，那我打算把产品分类，为每一种产品都建一个工厂，每个工厂只需要创建特定的某个产品即可，生产线变得有条理性。其UML类图如下：</p><p><img src="/breeze/613abb62/1635665199008.png" alt="1635665199008"></p><h5 id="3-抽象工厂-绑定创建"><a href="#3-抽象工厂-绑定创建" class="headerlink" title="3.抽象工厂-绑定创建"></a>3.抽象工厂-绑定创建</h5><p>上面两种模式不管工厂怎么拆分抽象，都只是针对一类产品Phone（AbstractProduct），如果要生成另一种产品PC，应该怎么表示呢？</p><p>最简单的方式是把2中介绍的工厂方法模式完全复制一份，不过这次生产的是PC。但同时也就意味着我们要完全复制和修改Phone生产管理的所有代码，显然这是一个笨办法，并不利于扩展和维护。</p><p>抽象工厂模式通过在AbstarctFactory中增加创建产品的接口，并在具体子工厂中实现新加产品的创建，当然前提是子工厂支持生产该产品。否则继承的这个接口可以什么也不干。</p><p><img src="/breeze/613abb62/1635665229680.png" alt="1635665229680"></p><h5 id="4-手撕spring-Map缓存-单例-简单工厂-反射-重要"><a href="#4-手撕spring-Map缓存-单例-简单工厂-反射-重要" class="headerlink" title="4.手撕spring-Map缓存(单例)+简单工厂+反射-重要"></a>4.手撕spring-Map缓存(单例)+简单工厂+反射-重要</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ronghuanet._01df._02factory._03springmock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String configPath;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,BeanDefinition&gt; beanDefinitions = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>();;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; beans = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BeanFactory</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;applicationContext.properties&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BeanFactory</span><span class="params">(String configPath)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.configPath = configPath;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解析配置文件为BeanDefinition</span></span><br><span class="line">        parseBeanDefinitions();</span><br><span class="line">        <span class="comment">//初始化单例</span></span><br><span class="line">        initSingletonObjects();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initSingletonObjects</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Set&lt;Map.Entry&lt;String, BeanDefinition&gt;&gt; entries = beanDefinitions.entrySet();</span><br><span class="line">            Iterator&lt;Map.Entry&lt;String, BeanDefinition&gt;&gt; iterator = entries.iterator();</span><br><span class="line">            <span class="keyword">if</span> (iterator.hasNext())&#123;</span><br><span class="line">                Map.Entry&lt;String, BeanDefinition&gt; next = iterator.next();</span><br><span class="line">                <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> next.getKey();</span><br><span class="line">                <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> next.getValue();</span><br><span class="line">                <span class="comment">//判断是否是单例,如果是创建了放入map</span></span><br><span class="line">                <span class="keyword">if</span> (beanDefinition.getScope().equals(<span class="string">&quot;singleton&quot;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> beanDefinition.getClassName();</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> Class.forName(className).newInstance();</span><br><span class="line">                    beans.put(id,o);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//多例不用管了,以后每次获取的时候直接new一个给他</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析配置文件为BeanDefinition</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseBeanDefinitions</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            properties.load(Thread.currentThread()</span><br><span class="line">                    .getContextClassLoader()</span><br><span class="line">                    .getResourceAsStream(<span class="string">&quot;applicationContext.properties&quot;</span>));</span><br><span class="line"></span><br><span class="line">            Set&lt;String&gt; ids = properties.stringPropertyNames();</span><br><span class="line">            ids.forEach(id-&gt;&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> properties.getProperty(id);</span><br><span class="line">                <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinition</span>(id,className);</span><br><span class="line">                beanDefinitions.put(id,beanDefinition);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过id获取bean</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String id)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断是否是单例,如果是从map中获取返回,否则创建一个新的返回</span></span><br><span class="line">            <span class="comment">//1 获取beanDefinition才能获取到scope</span></span><br><span class="line">            <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> beanDefinitions.get(id);</span><br><span class="line">            <span class="keyword">if</span> (beanDefinition.getScope().equals(<span class="string">&quot;singleton&quot;</span>))</span><br><span class="line">                <span class="keyword">return</span> beans.get(id);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span>  Class.forName(beanDefinition.getClassName()).newInstance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过class获取bean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> cn.ronghuanet._01df._02factory._03springmock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanDefinition</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="string">&quot;singleton&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;BeanDefinition&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&#x27;&quot;</span> + id + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, className=&#x27;&quot;</span> + className + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, scope=&#x27;&quot;</span> + scope + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BeanDefinition</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BeanDefinition</span><span class="params">(String id, String className)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.className = className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getClassName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setClassName</span><span class="params">(String className)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.className = className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getScope</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScope</span><span class="params">(String scope)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.scope = scope;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanFactory</span>(<span class="string">&quot;applicationContext.properties&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date01</span> <span class="operator">=</span> (Date) beanFactory.getBean(<span class="string">&quot;myDate&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date02</span> <span class="operator">=</span> (Date) beanFactory.getBean(<span class="string">&quot;myDate&quot;</span>);</span><br><span class="line">        System.out.println(date01 == date02);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>享元模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">装箱： <span class="type">int</span>--&gt;integer</span><br><span class="line">   手动装箱:   <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Interger.valueOf(<span class="number">1</span>);</span><br><span class="line">     自动装箱:  <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">   =========</span><br><span class="line">          带享元模式: 缓存 -<span class="number">128</span>-<span class="number">127</span></span><br><span class="line">拆箱: Interger--&gt;inter</span><br><span class="line">   手动: <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>).parseInt</span><br><span class="line">   自动: <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">11</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">11</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span><span class="number">11</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i4</span> <span class="operator">=</span><span class="number">11</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i5</span> <span class="operator">=</span><span class="number">200</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i6</span> <span class="operator">=</span><span class="number">200</span>;</span><br><span class="line">sout(i1==i2); <span class="comment">//false</span></span><br><span class="line">sout(i3==i4); <span class="comment">//true</span></span><br><span class="line">sout(i5==i6); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">基础:</span><br><span class="line"> <span class="type">boolean</span>(<span class="literal">true</span>,<span class="literal">false</span>) <span class="type">char</span>(<span class="number">0</span>-<span class="number">127</span>) bype(-<span class="number">128</span>-&gt;<span class="number">127</span>) <span class="type">short</span>(-<span class="number">128</span>-&gt;<span class="number">127</span>) <span class="type">int</span> (-<span class="number">128</span>-<span class="number">127</span>) <span class="type">long</span>(-<span class="number">128</span>-<span class="number">127</span>) <span class="type">float</span>(NO) <span class="type">double</span>(NO)</span><br><span class="line"></span><br><span class="line">有了基础类型java为什么还要设计包装类型??</span><br><span class="line">   基础类型没办法判断是否设置了  <span class="type">int</span> i; <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>; Interter i1=<span class="number">0</span>;Interter i1;   <span class="keyword">private</span> Long id;</span><br><span class="line">   包装类型是个类,拥有面向对象封装特征,里面可以定义一些属性和方法</span><br><span class="line">       </span><br></pre></td></tr></table></figure><h4 id="2-3-策略模式-工厂模式"><a href="#2-3-策略模式-工厂模式" class="headerlink" title="2.3.策略模式+工厂模式"></a>2.3.策略模式+工厂模式</h4><p>​	策略设计模式（Strategy Design Pattern）是面向对象编程中的一种行为型设计模式，<strong>它定义了一系列算法，并将每个算法封装起来，使得它们可以互相替换。</strong>在策略模式中，不同算法之间相互独立，可以独立变化，从而让算法的变化不会影响到使用算法的客户端。</p><p>策略模式通常由三个角色组成：</p><ol><li>Context 上下文(使用策略地方)：上下文是一个包含某个业务逻辑的类，它持有一个<strong>策略接口的引用</strong>，上下文在需要使用某种算法时通过策略接口来调用具体的实现。</li><li>Strategy 策略接口：策略接口定义了多个算法的抽象方法，具体的策略类需要实现这些抽象方法，以提供特定的算法实现。</li><li>ConcreteStrategy 具体策略：具体策略是对策略接口的实现，它实现了策略接口中定义的算法，并负责执行具体的业务逻辑。</li></ol><p>策略模式的优点是增强了程序的<strong>扩展性和可维护性，将不同算法进行封装，增加了代码的复用性，同时也避免了大量的 if…else 嵌套，让代码更加简洁可读。</strong>策略模式适用于在一个类中存在多个具有相同行为的方法，或者需要根据不同条件选择不同的算法实现的情况。</p><p>应用策略模式时，需要将策略类的创建和使用分离开来，使得调用者不依赖于具体的策略类，而是通过调用策略接口来完成相应的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只是定义一个策略接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ShopCarKeyGroupStrategy</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; <span class="title function_">group</span><span class="params">(Set&lt;String&gt; keys)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据hash算法分成60</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShopCarKeyHashGroupStrategy</span> <span class="keyword">implements</span> <span class="title class_">ShopCarKeyGroupStrategy</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">group</span><span class="params">(Set&lt;String&gt; keys)</span> &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; groupResult = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">60</span>);<span class="comment">//外层放60个(组),里面放没一组数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">60</span>; i++) &#123;</span><br><span class="line">            groupResult.add(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一组 索引是0</span></span><br><span class="line">        <span class="comment">// 第二组 索引是1</span></span><br><span class="line">        keys.forEach(key-&gt;&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">groupIndex</span> <span class="operator">=</span> key.hashCode() % <span class="number">60</span>; <span class="comment">//0-59 算出自己属于那一组</span></span><br><span class="line">            List&lt;String&gt; strings = groupResult.get(groupIndex);</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtil.isNotEmpty(strings))  <span class="comment">//判断是否有其他成员</span></span><br><span class="line">                strings.add(key); <span class="comment">//如果有吧自己作为成员放进去就ok</span></span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">//新建一个组,吧自己放入这个组,</span></span><br><span class="line">                List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                list.add(key); <span class="comment">//成员放入</span></span><br><span class="line">                groupResult.add(groupIndex,list); <span class="comment">//添加组</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> groupResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; groupResult = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">60</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">60</span>; i++) &#123;</span><br><span class="line">            groupResult.add(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(groupResult.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以定义其他策略</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShopCarKeyGroupStrategyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ShopCarKeyGroupStrategy</span> <span class="variable">defalutShopCarKeyGroupStrategy</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ShopCarKeyHashGroupStrategy</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ShopCarKeyGroupStrategy <span class="title function_">createInstance</span></span><br><span class="line">            <span class="params">(String carGroupStrategy)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(carGroupStrategy))</span><br><span class="line">            <span class="keyword">return</span> defalutShopCarKeyGroupStrategy;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;? <span class="keyword">extends</span> <span class="title class_">ShopCarKeyGroupStrategy</span> &gt; clazz =</span><br><span class="line">                    (Class&lt;? <span class="keyword">extends</span> <span class="title class_">ShopCarKeyGroupStrategy</span>&gt;) Class.forName(carGroupStrategy);</span><br><span class="line">            <span class="keyword">return</span> clazz.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;invalid Strategy &#123;1&#125;,using defalut groupStrategy!&quot;</span>,carGroupStrategy);</span><br><span class="line">            <span class="keyword">return</span> defalutShopCarKeyGroupStrategy;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//context</span></span><br><span class="line"></span><br><span class="line">  <span class="type">ShopCarKeyGroupStrategy</span> <span class="variable">groupStrategy</span> <span class="operator">=</span> ShopCarKeyGroupStrategyFactory</span><br><span class="line">                        .createInstance(carGroupStrategy);</span><br><span class="line">                List&lt;List&lt;String&gt;&gt; groupResult = groupStrategy.group(keys);</span><br></pre></td></tr></table></figure><h4 id="2-4-状态设计模式"><a href="#2-4-状态设计模式" class="headerlink" title="2.4  状态设计模式"></a>2.4 状态设计模式</h4><p>状态设计模式（State Design Pattern）是一种行为型设计模式，它定义了在对象内部状态改变时，改变其行为的方式。该模式将对象的行为和状态分离，把不同状态对应的行为封装到不同的状态类中，使得状态间的转换更加灵活。</p><p>状态模式通常由以下几个角色组成：</p><ol><li>Context 上下文：上下文是一个包含某个业务逻辑的类，它持有一个状态接口的引用，上下文在需要改变状态时通过状态接口来调用具体的实现。</li><li>State 状态接口：状态接口定义了多个抽象方法，这些抽象方法是不同状态对应的行为，具体的状态类需要实现这些抽象方法，以提供特定的行为实现。</li><li>ConcreteState 具体状态：具体状态是对状态接口的实现，它实现了状态接口中定义的抽象方法，并负责执行具体的业务逻辑。</li></ol><p>使用状态模式，可以使得状态的变化对上下文的影响降至最小，同时也避免了大量的 if…else 嵌套，让代码更加清晰简洁。状态模式适用于处理一个对象在多种状态下的行为问题，使得在不同状态下修改对象行为时，只需要修改该状态对应的类即可，而不需要修改其他代码。</p><p>然而，状态模式的缺点是会增加系统的复杂性，因为每个状态都需要对应一个具体的状态类，如果状态较多，会导致类的数量激增。另外，状态切换过程中也可能会消耗额外的资源，需要在设计时合理地考虑这些问题。</p><p>参考蓉礼购,店铺入驻代码!!!!</p><h4 id="2-5-模板模式"><a href="#2-5-模板模式" class="headerlink" title="2.5 模板模式"></a>2.5 模板模式</h4><p>​	先定义一个操作中的算法骨架，而将算法的某一个或者某些步骤的具体实现延迟到了子类中来实现，使得子类可以在不修改当前算法的结构情况下，重新定义当前算法的某些特定步骤.</p><p>​ 泡茶</p><p>​	{</p><p>​ &#x2F;&#x2F;准备杯具</p><p>​ &#x2F;&#x2F;放入茶叶 龙井 碧螺春</p><p>​ &#x2F;&#x2F;倒入开水</p><p>​	}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mliutm._01df._04template;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CookTea</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">prepareCup</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;准备了一个茶杯!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">putTea</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">void</span> <span class="title function_">putWater</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;导入开水!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">cook</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//准备杯具--生成订单 生成支付单,创建定时任务--&gt;前置的逻辑</span></span><br><span class="line">        prepareCup();</span><br><span class="line">         <span class="comment">//放入茶叶</span></span><br><span class="line">        putTea();</span><br><span class="line">         <span class="comment">//倒入开水--后置逻辑 --支付成功 取消定时任务,更新状态</span></span><br><span class="line">        putWater();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">CookPuErTea</span> <span class="keyword">extends</span> <span class="title class_">CookTea</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>  <span class="keyword">void</span> <span class="title function_">putTea</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;放入少许普洱!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CookTea</span> <span class="variable">cookTea</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CookPuErTea</span>();</span><br><span class="line">        cookTea.cook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ redisTemplate es jdbc rabbitmq</p><p>​ XxxTemplate extends XxxOperations</p><h4 id="2-6-代理模式"><a href="#2-6-代理模式" class="headerlink" title="2.6.代理模式"></a>2.6.代理模式</h4><p>所谓代理模式是指客户端并不直接调用实际的对象，而是通过调用代理对象，来间接的调用实际的对象。这样我们可以在代理调用被代理对象之前，之后，报错加入自己的逻辑。举例：经纪人和明星 ，菜鸟驿站代收快递</p><p><img src="/breeze/613abb62/1635665339326.png" alt="1635665339326"></p><h5 id="1-静态代理"><a href="#1-静态代理" class="headerlink" title="1.静态代理"></a>1.静态代理</h5><p>代理分为动态代理与静态代理。我们先从简单的静态代理开始研究。</p><ul><li>实体接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主体</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">//访问</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>被代理真实对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**<span class="keyword">public</span> class** RealSubject **implements** Subject &#123;      **<span class="keyword">private</span>** String **name** = **<span class="string">&quot;****我是真实对象****&quot;</span>**;      <span class="meta">@Override</span>     **<span class="keyword">public</span> <span class="keyword">void</span>** visit() &#123;         *<span class="comment">//**真实对象执行**...*        System.**out**.println(**name**);     &#125; &#125;</span></span><br></pre></td></tr></table></figure><ul><li>代理类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxySubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//代理对象持有真实对象</span></span><br><span class="line">    <span class="keyword">private</span> Subject subject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造代理对象需要传入被代理的真实对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxySubject</span><span class="params">(Subject subject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.执行前</span></span><br><span class="line">        <span class="comment">//2.调用真实对象的方法</span></span><br><span class="line">        subject.visit();</span><br><span class="line">        <span class="comment">//3.执行后</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建代理对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建代理</span></span><br><span class="line">        <span class="type">ProxySubject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxySubject</span>(<span class="keyword">new</span> <span class="title class_">RealSubject</span>());</span><br><span class="line">        subject.visit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态代理的优缺点 ：每个类都要创建一个代理类，对于项目开发而言需要为很多类都创建代理类，使用静态代理无疑是一个很麻烦的工作，我们需要在代码运行的过程中动态生成代理类 - 动态代理</p><h5 id="2-JDK动态代理"><a href="#2-JDK动态代理" class="headerlink" title="2.JDK动态代理"></a>2.JDK动态代理</h5><p>动态代理有别于静态代理，是根据代理的对象，动态创建代理类。这样，就可以避免静态代理中代理类接口过多的问题。Java1.3就提供了动态代理，让咱们可以在代码运行期去实现一个接口的代理实例。这个功能在刚出来时，几乎没有太大实际用途，但是后来发现，它简直就是为实现<strong>AOP量身</strong>打造。</p><p>但是大家注意了，jdk的动态代理只允许完成有接口的代理，但是在我们开发的很多时候，可能还是会遇到去代理没有接口的类(创建的代理对象就是这个类的子类)，比如咱们学习的Hibernate中的延时加载就是使用的这种方式。那么Spring是怎么解决这个问题的呢？Spring使用两种方式来完成动态代理：</p><ul><li><p><strong>如果代理的类有接口，使用JDK的动态代理模式，</strong></p></li><li><p><strong>如果代理的类没有接口，使用CGLIB的动态代理模式。</strong></p></li></ul><p>所以，现在咱们要开始来学习一下怎么使用这两种模式来完成动态代理。</p><p>注：JDK动态代理只能代理有接口的类,下面是完成JDK代理的主要类：</p><p>java.lang.reflect.<strong>Proxy</strong> (可以到jdk文档中找到这个类)</p><p>java.lang.reflect.<strong>InvocationHandler</strong>:代理调用处理程序的接口</p><ul><li>创建JDKProxy类：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * InvocationHandler:是代理实例的调用处理程序 实现的接口。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>&#123;</span><br><span class="line">	<span class="comment">//定义真实主题角色：目标对象</span></span><br><span class="line">	<span class="keyword">private</span> Object targetObject;</span><br><span class="line">	<span class="comment">//传入事务管理器</span></span><br><span class="line">	<span class="keyword">private</span> TxManager txManager;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">JdkProxy</span><span class="params">(Object targetObject,TxManager txManager)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.targetObject = targetObject;</span><br><span class="line">		<span class="built_in">this</span>.txManager = txManager;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * proxy:经过jdk的代理对象(基本上没有作用)</span></span><br><span class="line"><span class="comment">	 * method：实际执行的方法</span></span><br><span class="line"><span class="comment">	 * args：方法中的参数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object targetObject, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//返回的结果</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			txManager.begin();</span><br><span class="line">			result = method.invoke(targetObject, args); <span class="comment">//执行直接对象的方法</span></span><br><span class="line">			txManager.commit();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			txManager.rollback();</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			txManager.close();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 创建一个代理对象</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">createProxy</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">				<span class="built_in">this</span>.getClass().getClassLoader(),  <span class="comment">//类加载器，只要拿到一个即可</span></span><br><span class="line">				targetObject.getClass().getInterfaces() , <span class="comment">//实现类的接口集合(因为一个类可以实现多个接口)</span></span><br><span class="line">				<span class="built_in">this</span> <span class="comment">//代理实例的调用处理程序(InvocationHandler的实现类)</span></span><br><span class="line">			);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试功能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testProxy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">	<span class="comment">//真实主题角色对象</span></span><br><span class="line">	<span class="type">IEmployeeService</span> <span class="variable">employeeService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmployeeServiceImpl</span>();</span><br><span class="line">	<span class="comment">//事务管理器</span></span><br><span class="line">	<span class="type">TxManager</span> <span class="variable">txManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TxManager</span>();</span><br><span class="line">	<span class="comment">//创建咱们自定义的一个处理代理功能类(这个类中我们加了一个方法可以直接创建代理对象)</span></span><br><span class="line">	<span class="type">JdkProxy</span> <span class="variable">jdkProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdkProxy</span>(employeeService,txManager);</span><br><span class="line">	<span class="comment">//获取代理对象</span></span><br><span class="line">	<span class="type">IEmployeeService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IEmployeeService)jdkProxy.createProxy();</span><br><span class="line">	proxy.save(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-CGLIB动态代理"><a href="#3-CGLIB动态代理" class="headerlink" title="3.CGLIB动态代理"></a>3.CGLIB动态代理</h5><p>Cglib类似于javassist-3.18.1-GA.jar功能字节码增强,原来Hibernate3.2之前就是使用cglib来进行字节码增强，下面是完成CGLIB的类：</p><ul><li><p>org.springframework.cglib.proxy.<strong>Enhancer</strong>; 增强器</p></li><li><p>org.springframework.cglib.proxy.<strong>MethodInterceptor</strong>; 方法切面(代理实例处理方法功能的接口)</p></li><li><p>org.springframework.cglib.proxy.<strong>MethodProxy</strong>;</p></li></ul><p>CGLIBProxy类代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxy</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义参数,接收真实的目标对象</span></span><br><span class="line">	<span class="keyword">private</span> Object targetObject;</span><br><span class="line">	<span class="comment">//事务对象</span></span><br><span class="line">	<span class="keyword">private</span> TxManager txManager;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">CglibProxy</span><span class="params">(Object targetObject,TxManager txManager)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.targetObject = targetObject;</span><br><span class="line">		<span class="built_in">this</span>.txManager = txManager;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * proxyObject:CGLIB代理后的对象,一般不用</span></span><br><span class="line"><span class="comment">	 * method：真实对象的方法</span></span><br><span class="line"><span class="comment">	 * args:方法的参数</span></span><br><span class="line"><span class="comment">	 * methodProxy：CGLIB代理后的方法，一般不用</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object proxyObject, Method method, Object[] args,MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//返回的结果</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			txManager.begin();</span><br><span class="line">			result = method.invoke(targetObject, args); <span class="comment">//执行直接对象的方法</span></span><br><span class="line">			txManager.commit();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			txManager.rollback();</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			txManager.close();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 创建一个代理对象</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">createProxy</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="comment">//创建增强器</span></span><br><span class="line">		<span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">		<span class="comment">//创建的代理就是咱们真实目标对象的子类</span></span><br><span class="line">		enhancer.setSuperclass(targetObject.getClass());</span><br><span class="line">		<span class="comment">//MethodInterceptor就是一个Callback回调</span></span><br><span class="line">		enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">		<span class="comment">//创建一个代理对象并返回</span></span><br><span class="line">		<span class="keyword">return</span> enhancer.create();</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testProxy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">		<span class="comment">//真实主题角色对象</span></span><br><span class="line">		<span class="type">EmployeeServiceImpl</span> <span class="variable">employeeService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmployeeServiceImpl</span>();</span><br><span class="line">		<span class="comment">//事务管理器</span></span><br><span class="line">		<span class="type">TxManager</span> <span class="variable">txManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TxManager</span>();</span><br><span class="line">		<span class="comment">//创建Cglib代理对象</span></span><br><span class="line">		<span class="type">CglibProxy</span> <span class="variable">cglibProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CglibProxy</span>(employeeService, txManager);</span><br><span class="line">		<span class="comment">//拿到代理对象</span></span><br><span class="line">		<span class="type">EmployeeServiceImpl</span> <span class="variable">proxy</span> <span class="operator">=</span> (EmployeeServiceImpl)cglibProxy.createProxy();</span><br><span class="line">		proxy.save(user);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p>面试：Spring的AOP原理？</p><p>SpringAop底层使用动态代理实现，Spring使用了Jdk动态代理和CGLIB动态代理两种方式</p><ul><li><p>JDK动态代理：</p><p>有接口的类使用JDK的动态代理(JDK动态代理不支持没有接口的类)，如果有n个接口,必然有n个实现,只用写1个代理类JDKProxy就可以对所有有接口进行处理</p></li><li><p>CGLIB动态代理：</p><p>没有接口的类使用CGLIB动态代理(类有没有接口都可以支持)，只用写1个代理类CglibProxy就可以对所有没有接口的<strong>不能是final类都进行处理</strong></p><p><strong>spring aop失效!!! 一个没有实现接口的类,被final!</strong></p></li></ul><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46620665/article/details/123926363">https://blog.csdn.net/weixin_46620665/article/details/123926363</a></p><h2 id="二-Spring源码分析"><a href="#二-Spring源码分析" class="headerlink" title="二.Spring源码分析"></a>二.Spring源码分析</h2><h3 id="1-IOC源码分析"><a href="#1-IOC源码分析" class="headerlink" title="1.IOC源码分析"></a>1.IOC源码分析</h3><h4 id="1-1-IOC-DI-的理解"><a href="#1-1-IOC-DI-的理解" class="headerlink" title="1.1.IOC&#x2F;DI 的理解"></a>1.1.IOC&#x2F;DI 的理解</h4><p>IOC控制反转，把对象的创建，属性设置，初始化，销毁等工作交给Spirng的IOC容器去管理，解放程序员的劳动力。对象被注册到Spring的IOC容器中，使用的时候从容器中获取即可，非常方便。这些注册到Spring容器中的对象称之为Bean。</p><p>IOC容器如何做到这一点：当 Spring启动，IOC容器就会尝试加载Spring的配置文件(XML配置或者注解配置) ，并解析XML中Bean的定义，然后会把这些Bean的相关定义信息封装成对象（BeanDefinition） , 通过Bean注册器 BeanDefinitionRegistry 注册IOC容器中，也就是一个 ConcurrentHashMap&lt;String,BeanDefinition&gt; 中,这时候的Bean并没有创建真正的实例,只是完成了Bean的信息的封装而已。</p><p>对于Bean是单利(scope&#x3D;sigletion) 或者多利(scope&#x3D;prototype)IOC的处理方式是不一样的。在IOC容器将所有到Bean都注册到容器中(ConcurrentHashMap)之后，然后会找出scope&#x3D;sigletion，且lazy&#x3D;false（Bean默认）的Bean，根据其 BeanDefinition 进行Bean的实例化。 然后会把实例化好的Bean缓存到一个ConcurrentHashMap，方便以后再次获取。</p><p>对于scope&#x3D;prototype，或者 lazy&#x3D;true 的Bean是会在使用到Bean的时候才会实例化，IOC启动的时候不会实例化这种Bean。</p><p>Bean是根据 BeanDefinition 进行实例化的，我们注册给Spring的对象通常都是需要创建代理的(需要事务管理)，Spring会根据原生类是否有接口来选择使用JDK动态代理或者CGLIB代理方式为对象生成代理类，当然底层会通过反射手段来创建实例。</p><p>对象和对象之间有依赖关系，既然Spring帮我们管理Bean，那么Spring也需要我们维护Bean的依赖关系，比如：Controller中需要注入一个Service,那么IOC容器会在创建Controller时会先创建Service的实例，或者从IOC容器中找到Service的实例，然后赋值给Contorller。</p><h4 id="1-2-IOC核心类"><a href="#1-2-IOC核心类" class="headerlink" title="1.2.IOC核心类"></a>1.2.IOC核心类</h4><p><img src="/breeze/613abb62/20210529225454284.png" alt="img"></p><ul><li><p><strong>BeanFactory</strong></p><p>IOC容器顶层接口，提供了Bean获取的基础方法</p></li><li><p>DefaultListableBeanFactory</p><p>是整个 bean 加载的核心部分，是 Spring 注册及加载Bean 的默认实现,DefaultListableBeanFactory继承了 AbstractAutowireCapableBeanFactory 并实现了 ConfigurableListableBeanFactory以及BeanDefinitionRegistry 接口</p></li><li><p><strong>ApplicationContext</strong></p><p>这个容器工厂也是继承了EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory,MessageSource，ApplicationEventPublisher, ResourcePatternResolver 接口，除了实现IOC基本功能外，还扩展了国际化支持，资源访问，事件发布等等。</p></li><li><p>BeanDefinitionRegistry</p><p>负责注册BeanDefinition ，并定义了对 BeanDefinition 的各种增删改操作，BeanDefinition 是对Ben的封装</p></li><li><p><strong>ClasspathXmlApplicationContext</strong></p><p>ClasspathXmlApplicationContext也是IOC容器工厂中的一员，默认 从classpath中获取XML配置，使用 XmlBeanDefinitionReader 进行解析配置，这是一个简单的、一站式便利的ApplicationContext。</p></li><li><p><strong>AnnotationConfigApplicationContext</strong></p><p>注解版本ApplicationContext</p></li><li><p>XmlBeanDefinitionReader</p><p>XmlBeanDefinitionReader 用于 XML 定义的 Bean 的读取。 将实际的 XML 文档读取委托给BeanDefinitionDocumentReader接口的实现</p></li><li><p>ResourceLoader</p><p>资源(XML配置文件)加载器，根据给定的配置文件地址，返回Resource对象</p></li><li><p>DocumentLoader</p><p>把资源文件转换成Document文档对象</p></li><li><p>BeanDefinitionDocumentReader</p><p>定义了读取Document并注册BeanDefinition的功能，默认实现是DefaultBeanDefinitionDocumentReader</p></li><li><p>BeanDefinitionParserDelegate</p><p>定义了解析XML元素的方法</p></li></ul><p>这里可以总结一下XML配置文件读取的流程：</p><ol><li>通过ResourceLoader 加载配置文件XML转为Resource</li><li>通过DocumentLoader 把Resource转换为 Document对象</li><li>通过 DefaultBeanDefinitionDocumentReader对Document进行解析，调用 BeanDefinitionParserDelegate解析XML元素。</li></ol><p>BeanFactory和ApplicationContext的联系和区别!!!</p><p>联系:ApplicationContext是一个BeanFactory</p><p>区别:</p><p>​ BeanFactory中bean都是使用的时候才创建的!</p><p>​ BeanFactory对于单例(非lazy),创建容器的时候就启动了!</p><h4 id="1-3-IOC入门案例"><a href="#1-3-IOC入门案例" class="headerlink" title="1.3.IOC入门案例"></a>1.3.IOC入门案例</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入springjar--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="1-3-1-xml版本"><a href="#1-3-1-xml版本" class="headerlink" title="1.3.1 xml版本"></a>1.3.1 xml版本</h5><p>定义xml配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.xxx.xxx.MyBean&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">scopt</span>=<span class="string">&quot;&quot;</span>  <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span>  <span class="attr">destory-mehod</span>=<span class="string">&quot;&quot;</span>&gt;</span> </span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>加载配置获取Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载Spring配置文件，拿到Spring容器</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;配置文件.xml&quot;</span>)</span><br><span class="line"><span class="comment">//从容器中拿到对象实例</span></span><br><span class="line"><span class="type">MyBean</span> <span class="variable">myBean</span> <span class="operator">=</span> context.getBean(MyBean.class);</span><br></pre></td></tr></table></figure><h5 id="1-3-2-javaconfig-重要"><a href="#1-3-2-javaconfig-重要" class="headerlink" title="1.3.2 javaconfig  重要  *****"></a>1.3.2 javaconfig 重要 *****</h5><p>​ 通过java的配置内，来初始化spring容器</p><p>@Configration</p><p>1)@Bean</p><p>2)@ComponentScan</p><p>3@Import</p><p>4@Condition</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AnnoSpringTestConfig.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> context.getBean(Date.class);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> context.getBean(Date.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(date1==date2);</span><br><span class="line">        System.out.println(<span class="string">&quot;============&quot;</span>);</span><br><span class="line">        <span class="type">MySerivce</span> <span class="variable">bean</span> <span class="operator">=</span> context.getBean(MySerivce.class);</span><br><span class="line">        bean.sayHello();</span><br><span class="line">        System.out.println(<span class="string">&quot;=======Import common========&quot;</span>);</span><br><span class="line">        <span class="type">OtherBean01</span> <span class="variable">bean01</span> <span class="operator">=</span> context.getBean(OtherBean01.class);</span><br><span class="line">        bean01.say();</span><br><span class="line">        System.out.println(<span class="string">&quot;=====ImportSelector==========&quot;</span>);</span><br><span class="line">        <span class="type">OtherBean02</span> <span class="variable">bean02</span> <span class="operator">=</span> context.getBean(OtherBean02.class);</span><br><span class="line">        bean02.say();</span><br><span class="line">        System.out.println(<span class="string">&quot;=====ImportBeanDefinitionRegistrar==========&quot;</span>);</span><br><span class="line">        <span class="type">OtherBean03</span> <span class="variable">bean03</span> <span class="operator">=</span> context.getBean(OtherBean03.class);</span><br><span class="line">        bean03.say();</span><br><span class="line">        System.out.println(<span class="string">&quot;=====conditional bean==========&quot;</span>);</span><br><span class="line">        List&lt;String&gt; list = context.getBean(List.class);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">//是一个配置类 类似于原来applicationContext.xml里面的内容都放到这个类中</span></span><br><span class="line"><span class="meta">@ComponentScan</span> <span class="comment">//扫描组件，里面可以指定包，如果没有指定就是当前包，也就是当前包下面或者子包加了注解的类都会被哪儿spring管理。</span></span><br><span class="line"><span class="meta">@Import(&#123;OtherBean01.class,</span></span><br><span class="line"><span class="meta">        MyBeanImportSelector.class,</span></span><br><span class="line"><span class="meta">        MyBeanImportBeanDefinitionRegistrar.class&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnoSpringTestConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相当于在xml中配置了一个bean</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Scope(&quot;singleton&quot;)</span> <span class="comment">//作用范围 singleton prototype</span></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">myDate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//满足条件才注册</span></span><br><span class="line">    <span class="meta">@Conditional(&#123;MyBeanCondition.class&#125;)</span> <span class="comment">//可以放在方法上面，本方法生效，也可以放到类上面，向所有的方法都有有效</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">myList</span><span class="params">()</span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; objects = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        objects.add(<span class="string">&quot;dsz&quot;</span>);</span><br><span class="line">        objects.add(<span class="string">&quot;lyy&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> objects;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bean导入选择器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cn.ronghuanet._01hello._02anno.beans.OtherBean02&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bean定义注册器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata,</span></span><br><span class="line"><span class="params">                                        BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericBeanDefinition</span>();</span><br><span class="line">        beanDefinition.setBeanClassName(OtherBean03.class.getName());</span><br><span class="line">        <span class="comment">//这里注册bean</span></span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;OtherBean03&quot;</span>, beanDefinition );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanCondition</span> <span class="keyword">implements</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> context.getClassLoader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; aClass = classLoader.loadClass(<span class="string">&quot;org.apache.commons.lang3.StringUtils&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (aClass!=<span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1-4-解析bean定义"><a href="#1-4-解析bean定义" class="headerlink" title="1.4.解析bean定义"></a>1.4.解析bean定义</h4><p><strong>Bean的注册</strong></p><p><img src="/breeze/613abb62/20210602195811229.png" alt="img"></p><p>Bean的注册流程如下</p><ol><li>创建容器工厂：DefaultListableBeanFactory</li><li>走加载Bean流程，使用 ResourceResolver 把配置资源 Resource</li><li>调用 XmlBeanDefinitionReader根据 Resource 注册Bean</li><li>在 XmlBeanDefinitionReader 中 调用 DefaultBeanDefinitionDocumentReader 把Resource解析成Document</li><li>在委派 BeanDefinitionParserDelegate 把Document 解析成 BeanDefinition</li><li>调用BeanDefinitionRegistry注册BeanDefinition到DefaultListableBeanFactory工厂中的一个 Map&lt;String, BeanDefinition&gt; beanDefinitionMap</li></ol><p>Bean的注册源码跟踪流程如下：</p><ol><li><p>IOC入口：ClassPathXmlApplicationContext(java.lang.String[], boolean, org.springframework.context.ApplicationContext)</p></li><li><p>容器刷新：org.springframework.context.support.AbstractApplicationContext#refresh</p></li><li><p>创建容器注册Bean : org.springframework.context.support.AbstractApplicationContext#obtainFreshBeanFactory</p></li><li><p>Bean的注册：org.springframework.context.support.AbstractXmlApplicationContext#loadBeanDefinitions</p><ol><li><p>把配置转成Resource ： org.springframework.core.io.support.PathMatchingResourcePatternResolver#getResource</p></li><li><p>Bean的注册XmlBeanDefinitionReader#loadBeanDefinitions(org.springframework.core.io.Resource)</p></li><li><p>把 Resource变成Document：org.springframework.beans.factory.xml.DefaultDocumentLoader#loadDocument</p></li><li><p>注册Bean:org.springframework.beans.factory.xml.XmlBeanDefinitionReader#registerBeanDefinitions</p><ol><li><p>注册Bean:org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#registerBeanDefinitions</p></li><li><p>解析Document: DefaultBeanDefinitionDocumentReader#parseDefaultElement</p></li><li><p>解析Bean ： BeanDefinitionParserDelegate#parseBeanDefinitionElement</p></li><li><p>封装BeanDefinition: org.springframework.beans.factory.support.BeanDefinitionReaderUtils#createBeanDefinition</p></li><li><p>注册BeanDefinition : DefaultBeanDefinitionDocumentReader#doRegisterBeanDefinitions</p><ol><li><p>注册BeanDefinaition: org.springframework.beans.factory.support.BeanDefinitionReaderUtils#registerBeanDefinition</p></li><li><p>把BeanDefinition缓存：org.springframework.beans.factory.support.DefaultListableBeanFactory#registerBeanDefinition</p><p>缓存到 DefaultListableBeanFactory 中的 Map&lt;String, BeanDefinition&gt; beanDefinitionMap 中</p></li></ol></li></ol></li></ol></li></ol><h4 id="1-5-单例Bean的初始化"><a href="#1-5-单例Bean的初始化" class="headerlink" title="1.5.单例Bean的初始化"></a>1.5.单例Bean的初始化</h4><p>Bean注册完成就会对单例Bean且 lazy&#x3D;false的Bean进行实例化。</p><p><img src="/breeze/613abb62/20210605131706445.png" alt="img"></p><p>单例Bean的实例化流程</p><ol><li>refresh方法中，注册完Bean之后会对单例bean进行实例化</li><li>走 DefaultListableBeanFactory工厂的preInstantiateSingletons方法创建单例Bean</li><li>最终走 AbstractAutowireCapableBeanFactory#createBean 方法，根据BeanDefinition创建Bean</li><li>最终是走SimpleInstantiationStrategy 策略类 的instantiate方法创建Bean</li><li>底层还有判断是否使用CGLIB方式创建Bean</li><li>创建好之后会走 AbstractAutowireCapableBeanFactory#populateBean 进行Bean的属性注入</li></ol><p>Bean注册完成就会对单例Bean且 lazy&#x3D;false的Bean进行初始化</p><ol><li><p>单例Bean初始化入口：org.springframework.context.support.AbstractApplicationContext#finishBeanFactoryInitialization</p></li><li><p>实例化单例Bean: org.springframework.beans.factory.support.DefaultListableBeanFactory#preInstantiateSingletons</p></li><li><p>从三级缓存分钟获取单例Bean:DefaultSingletonBeanRegistry#getSingleton ， 如果没有就调用ObjectFactory创建</p></li><li><p>获取Bean实例： org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean</p></li><li><p>创建Bean ： org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean</p><ol><li><p>创建Bean ：org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBeanInstance</p></li><li><p>实例化Bean：org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#instantiateBean</p></li><li><p>调用Bean实例化策略创建Bean: org.springframework.beans.factory.support.SimpleInstantiationStrategy#instantiate</p><p>会根据原生类是否有接口，从而选择是否要CGLIB方式创建对象。</p></li><li><p>通过反射获取Bean的构造器实例化Bean ： org.springframework.beans.BeanUtils#instantiateClass</p></li></ol></li><li><p>AbstractAutowireCapableBeanFactory#createBean 实例化好Bean之后，调用 AbstractAutowireCapableBeanFactory#populateBean进行属性注入</p></li></ol><h4 id="1-6-Bean的生命周期"><a href="#1-6-Bean的生命周期" class="headerlink" title="1.6.Bean的生命周期 ****"></a>1.6.Bean的生命周期 ****</h4><p>从宏观的角度来说，Bean的什么周期可以分为四个阶段：</p><ol><li>Bean的实例化</li><li>Bean的属性注入</li><li>Bean的初始化</li><li>Bean的销毁</li></ol><p><img src="/breeze/613abb62/20210617133715497-1635665742667.png" alt="img"></p><p>下面是Bean较为详细的生命周期流程</p><ul><li><p>Bean的实例化</p><p>AbstractAutowireCapableBeanFactory#createBean</p></li><li><p>Bean的属性设置</p><p>AbstractAutowireCapableBeanFactory#populateBean</p></li><li><p>前置处理器</p><p>AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsBeforeInitialization</p></li><li><p>Bean的初始化</p><p>AbstractAutowireCapableBeanFactory#initializeBean -&gt; InitializingBean#afterPropertiesSet</p></li><li><p>自定义Init方法</p><p>AbstractAutowireCapableBeanFactory#invokeCustomInitMethod</p></li><li><p>后置处理器</p><p>AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsAfterInitialization</p></li><li><p>Bean的销毁</p><p>DefaultSingletonBeanRegistry#destroySingleton -&gt; destroyBean</p></li></ul><h4 id="1-7-Bean的属性注入"><a href="#1-7-Bean的属性注入" class="headerlink" title="1.7.Bean的属性注入"></a>1.7.Bean的属性注入</h4><p>Bean的属性注入，或者叫依赖注入在Spring中被叫做DI，他是在Bean的实例化过程中为当前Bean的依赖Bean进行注入值的过程。Bean的属性注入是在Bean的实例化方法中：AbstractAutowireCapableBeanFactory#doCreateBean 调用 populateBean 方法完成的。流程如下：</p><p><img src="/breeze/613abb62/20210612084301813.png" alt="在这里插入图片描述"></p><p>属性注入的大致流程如下：</p><ol><li>通过BeanDeifinition找到当前Bean所依赖的其他Bean(可能通过名字依赖，可能通过类型依赖)</li><li>调用BeanDefinitionValueResolver : BeanDefinition包含的值解析器，根据名字，或者类型去解析依赖的Bean,有可能是从容器中找到，也有可能走Bean的创建流程去创建依赖的Bean。</li><li>得到依赖的Bean实例之后，使用反射，给依赖的字段注入值。</li></ol><h4 id="1-8-Autowired-自动注入原理"><a href="#1-8-Autowired-自动注入原理" class="headerlink" title="1.8.Autowired 自动注入原理"></a>1.8.Autowired 自动注入原理</h4><p>注解自动注入是通过 BeanPostProcessor 后缀处理器来完成的 ， 下面是后置处理器的执行时机：</p><p><img src="/breeze/613abb62/20210617133715497.png" alt="在这里插入图片描述"></p><p>后置处理器的注册是在 AbstractApplicationContext#refresh() 刷新容器的时候 ，调用：registerBeanPostProcessors() 来完成注册的。</p><p>Spring提供了一个 AutowiredAnnotationBeanPostProcessor 后缀处理器专门来处理 @Autowired 自动注入。详细流程如下：</p><p><img src="/breeze/613abb62/20210618092246276.png" alt="在这里插入图片描述"></p><p>总结一下大致思路</p><ol><li>容器刷新过程中，向容器注册后置处理器 ，其中包括： AutowiredAnnotationBeanPostProcessor</li><li>Bean实例化过程中， 触发 AutowiredAnnotationBeanPostProcessor的执行，具体是在 AbstractAutowireCapableBeanFactory#populateBean方法中去调用的后置处理器</li><li>AutowiredAnnotationBeanPostProcessor#postProcessPropertyValues方法被调用，它会走 findAutowiringMetadata 方法扫描当前类中是否有 @autowire 注解。</li><li>然后会通过反射得到自动注入的字段所依赖的Bean，调用 beanFactory 得到依赖Bean的实例</li><li>然后使用放射进行自动注入字段赋值</li></ol><h4 id="1-9-Bean的循环依赖"><a href="#1-9-Bean的循环依赖" class="headerlink" title="1.9.Bean的循环依赖(******)"></a>1.9.Bean的循环依赖(******)</h4><p>循环依赖包括: <strong>构造器注入循环依赖</strong> setter 注入循环依赖 和 <strong>prototype模式Bean的循环依赖</strong>。Spring只解决了单利Bean的 setter 注入循环依赖，对于构造器循环依赖，和 prototype模式的循环依赖是无法解决的，在创建Bean的时候就会抛出异常<strong>BeanCurrentlyInCreationException</strong></p><p><strong>Setter循环依赖</strong></p><p>Spring解决循环依赖主要是使用<strong>三级缓存</strong>，具体流程如下；</p><p><img src="/breeze/613abb62/image-20210803114032222.png" alt="image-20210803114032222"></p><p>所谓的三级缓存 ，其实就是三个 Map</p><ul><li>一级缓存 ： 是一个 singletonObjects &#x3D; new ConcurrentHashMap&lt;String, Object&gt;(256) ，缓存实例化好的单例的Bean，后续applicationContext.getBean 也是从这个Map中获取。</li><li>二级缓存 ：earlySingletonObjects &#x3D; new HashMap&lt;String, Object&gt;(16) ： 缓存的是早期的Bean，也就是正在创建中的Bean，这个时候的Bean并不完整。</li><li>三级缓存 ：singletonFactories &#x3D; new HashMap&lt;String, ObjectFactory&lt;?&gt;&gt;(16) ： 缓存的是Bean的ObjectFactory 工厂，是用来创建Bean的实例的<strong>工厂</strong>。</li></ul><p>注意：构造器转入和 prototype注入是不支持循环依赖的 。构造器循环依赖会导致死循环。Prototype模式下Bean是不做缓存的，所以就没法暴露ObjectFactory，也就没办法实现循环依赖。</p><p><strong>构造器循环依赖</strong></p><ol><li><p>首先Spring会走Bean的实例化流程尝试创建 A 的实例 ，在创建实例之间先从 “正在创建Bean池” (一个缓存Map而已)中去查找A 是否正在创建，如果没找到，则将 A 放入 “正在创建Bean池”中，然后准备实例化构造器参数 B。</p></li><li><p>Spring会走Bean的实例化流程尝试创建 B 的实例 ，在创建实例之间先从 “正在创建Bean池” (一个缓存Map而已)中去查找B 是否正在创建，如果没找到，则将 B 放入 “正在创建Bean池”中，然后准备实例化构造器参数 A。</p></li><li><p>Spring会走Bean的实例化流程尝试创建 A 的实例 ，在创建实例之间先从 “正在创建Bean池” (一个缓存Map而已)中去查找A 是否正在创建。</p></li><li><p>此时：Spring发现 A 正处于“正在创建Bean池”，表示出现构造器循环依赖，抛出异常：“BeanCurrentlyInCreationException”</p></li></ol><p><strong>Prototype循环依赖</strong></p><p>Prototype模式下Bean是不做缓存的，所以就没法暴露ObjectFactory，也就没办法实现循环依赖。</p><h3 id="2-AOP源码分析"><a href="#2-AOP源码分析" class="headerlink" title="2.AOP源码分析"></a>2.AOP源码分析</h3><h4 id="2-1-AOP理解"><a href="#2-1-AOP理解" class="headerlink" title="2.1.AOP理解"></a>2.1.AOP理解</h4><p>AOP是为面向切面编程，为什么要面向切面，何为切面？我们知道对于OOP面向对象而言在某些开发场景中是有一定不足，由于面向对象的思想是纵向的，它面对的是一个一个的对象，当我们需要在多个类中引入同一个公共的业务时(比如：事务,操作日志等)，那么在每个类中都要引入公共的业务代码，从而造成代码大量重复，代码结构不优雅，不方便维护 ，这个时候就需要使用到面向切面的编程来解决这个问题。使用AOP可以把分散在多个类中的公共的代码剥离出来，和业务本身的代码解耦， 然后通过动态代理将公共业务代码作用到多个对象，代码结构也更加优雅。</p><p>所以可以认为 面向切面 是对 面向对象 的补充，它的思想是横向的，它面向的是一个切面，如果把一个对象看做一个点，那么多个对象就是一个面，是为切面，AOP多用于：事务，日志，监控，流控等等业务场景。</p><h4 id="2-2-AOP实现原理"><a href="#2-2-AOP实现原理" class="headerlink" title="2.2.AOP实现原理"></a>2.2.AOP实现原理</h4><p>AOP的实现原理是基于动态代理，动态代理就是在运行时期动态的为某个类(原生类)生成代理类以达到代码增强的目的，且代理类是持有原生类的，可以在代理类中调用原生类以及做一些增强业务。</p><p>动态代理分为JDK动态代理和CGLIB代理，CGLIB代理需要导入相关的jar包。两者的区别是JDK动态代理要求原始类(被代理类)需要实现至少一个接口。而CGLIB则是基于继承进行代理，原生类可以不实现任何接口。</p><p>对于Spring而言默认采用JDK动态代理，如果原生类没有实现任何接口，Spring会选择CGLIB代理，或者你可以通过配置文件强制指定使用CGLIB代理。</p><h4 id="2-3-AOP启动流程"><a href="#2-3-AOP启动流程" class="headerlink" title="2.3.AOP启动流程"></a>2.3.AOP启动流程</h4><p>举例：加入我们定义了一个切面用来对某个Service做增强 。</p><p>那么当Spring启动 ，AopNamespaceHandler 会注册一个 ，AspectJAutoProxyBeanDefinitionParser ，它的作用就是Aop进行解析</p><p><img src="/breeze/613abb62/20210621183954307.png" alt="img"></p><p><strong>解析器注册</strong></p><p>在 AopNamespaceHandler中会注册一个 AspectJAutoProxyBeanDefinitionParser ，它是针对 <em>&lt;aop:aspectj-autoproxy 的解析器</em>，在该解析器中会注册一个 <em>AspectJAnnotationAutoProxyCreator</em>(实现类AnnotationAwareAspectJAutoProxyCreator) ，代理自动创建器。该创建器做两个事情</p><ul><li>查找classpath中的切面类，解析增强方法 ， 并为原始类匹配适用的增强方法</li><li>根据增强器和原始类来创建代理类，底层会选择JDK动态代理或者换CGLIB代理进行创建。</li></ul><p><strong>切面的查找</strong></p><p>AnnotationAwareAspectJAutoProxyCreator 是一个	BeanPostProcessor ，在Bean实例化过程中，也就是Bean的initMethod初始化之后调用postProcessAfterInitialization方法来执行AOP相关的业务。</p><p>AnnotationAwareAspectJAutoProxyCreator 会负责扫描系统中的字节码，通过@Aspect 查找系统中的切面类，以及增强方法。然后去匹配我们的原始类所适用的增强方法。</p><ol><li>查找增强器：AbstractAdvisorAutoProxyCreator#getAdvicesAndAdvisorsForBean</li><li>匹配原始类使用的增强器：AnnotationAwareAspectJAutoProxyCreator#findCandidateAdvisors</li><li>代理的创建：AbstractAutoProxyCreator#createProxy</li><li>创建代理：ProxyFactory.getProxy 选择JDK或者CGLIB</li></ol><p>补充说一下：代理后的代理类是如何被调用的</p><ul><li>Before : 使用 MethodBeforeAdviceInterceptor来调用</li><li>后置：使用AspectJAfterAdvice来调用</li></ul><h4 id="2-4-事务源码分析"><a href="#2-4-事务源码分析" class="headerlink" title="2.4.事务源码分析"></a>2.4.事务源码分析</h4><p>Transcationl注解解析</p><p><img src="/breeze/613abb62/20210702141947657.png" alt="在这里插入图片描述"></p><ol><li>在 TxNamespaceHandler 注册了AnnotationDrivenBeanDefinitionParser用来解析事务注解配置</li><li>在AnnotationDrivenBeanDefinitionParser中创建 InfrastructureAdvisorAutoProxyCreator，其本身是个BeanPostPorcessor，还创建了 TransactionAttributeSource ， TransactionInterceptor ， TransactionAttributeSourceAdvisor</li><li>在Bean实例化的过程中调用InfrastructureAdvisorAutoProxyCreator#postProcessAfterInitialization 来解析Bean是否有@Transational，从而判断是否要进行增强创建代理。</li><li>在AutoProxyCreator 内部的 AopUtils#canApply 方法中通过 BeanFactoryTransactionAttributeSourceAdvisor的TransactionAttributeSourcePointcut切入点的matches方法中进行解析方法上的@Transactional 来决定是否要增强。</li><li>该方法获取到BeanFactoryTransactionAttributeSourceAdvisor 中的AnnotationTransactionAttributeSource，调用其getTransactionAttribute来解析。内部通过 SpringTransactionAnnotationParser#parseTransactionAnnotation来解析 方法上的@Transactional，如果方法上没有就去类上找，或者去父类的方法和类上找。</li><li>如果找到了就缓存到AbstractFallbackTransactionAttributeSource的attributeCache中，如果没找到说明这类不需要被事务增强。</li></ol><h4 id="Transactional-事务流程"><a href="#Transactional-事务流程" class="headerlink" title="Transactional 事务流程"></a>Transactional 事务流程</h4><p>主要是通过 TransactionInterceptor来拦截器请求，核心事务流程在 TransactionAspectSupport#invokeWithinTransaction方法中</p><p>包括：</p><ol><li>事务的创建，嵌套事务处理</li><li>事务回滚</li><li>事务提交</li></ol><h2 id="三-SpringBoot源码"><a href="#三-SpringBoot源码" class="headerlink" title="三.SpringBoot源码"></a>三.SpringBoot源码</h2><h3 id="1-SpringBoot自动配置"><a href="#1-SpringBoot自动配置" class="headerlink" title="1.SpringBoot自动配置"></a>1.SpringBoot自动配置</h3><p>我能以前在整合SpringMVC的时候，是需要咋web.xml中配置 DispatchServlert前端控制器的，为什么在SpringBoot中不用配置了。因为SpringBoot自动配置了，那么你知道它的自动配置流程是怎么样的吗？</p><p>在启动类上，我们通常都会打上： @SpringBootApplication 注解，它是一个组合标签，包括：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span> <span class="comment">//Configuration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br></pre></td></tr></table></figure><ul><li><p>SpringBootConfuration ,本质是一个 Configuration ，代表Spring的配置类。</p></li><li><p>IOC自动扫描的注解 ，ComponentScan 会去扫描类上是否有：@Component ,@Respository ,@Service @Controller ,如果有，就会把这个类自动注册到Spring容器中。</p></li><li><p>EnableAutoConfiguration ：就是启动SpringBoot自动配置的注解</p></li></ul><p><strong>在 EnableAutoConfiguration 注解上 import了一个选择器(AutoConfigurationImportSelector)	,选择器中有一个 selectImports 方，这个方法会去返回很多的自动配置的的全限定名，这些类会自动注册到Spring容器中。</strong></p><p>selectImports是怎么去找到这些所谓的自动配置类的呢？他会通过Spring的SPI接口，也就是通过一个SpringFactoryLoader去扫描 classpath中的所有的jar包中的	MET-INF&#x2F;spring.factories 中的自动配置类，比如： DispatchServlert就对应了DispatchServlertAutoConfiguration自动配置类 ， 它通过@Bean+方法的方式注册了一个 DispatchServlert 到Spring容器中 。</p><p>再比如：DataSourceAutoConfiguration 负责自动配置DataSource ,通过 @Bean+方法的方式注册</p><p>spi：服务提供者接口。</p><p>jdbc—– ———————————————————————————————————-&gt;db厂商以驱动方式提供具体实现。</p><p>springboot（加载所有引入jar里面MET-INF&#x2F;spring.factories里面自动配置类）———交给要集成到springboot里面的框架的starter去中（mybatis-spring-boot-starter，spring-boot-starter-data-redis等）</p><p><strong>姚桑总结：</strong></p><p>​ <strong>springboot自动配置原理，是一种spi思想的体现。它提供一种机制，能够扫描引入所有jar下MET-INF&#x2F;spring.factories的以EnableAutoConfiguration作为key配置类，把它纳入spring管理,并且里面通过@Bean方式来替换原来xml</strong>的很多bean的配置。当然springboot已经提供很多默认自动配置类，redis.springmvc，elastic search等，你也可以自定义比如mybatis.这个自动配置类里面的bean都是有条件。 所有的一切都是通过在入口类上加**@SpringBootApplication** 这句实现的,,,。。。。。。**</p><h3 id="2-SpringBoot启动流程"><a href="#2-SpringBoot启动流程" class="headerlink" title="2.SpringBoot启动流程"></a>2.SpringBoot启动流程</h3><p>1.开启秒表计时</p><p>2.starting监听器，</p><p>3.处理应用参数</p><p>4.加载环境对象</p><p>5.打印横幅</p><p><strong>6.创建Spring容器对象：AnnotationConfigApplicationContext</strong></p><p>7.容器刷新的前置工作</p><p>8**.刷新容器 - IOC启动流程 - Bean实例化-onrefresh(创建tomcat) - finishRerefsh(启动Tomcat)**</p><p>9.刷新容器后置工作</p><p>10.秒表停止</p><p>11.started事件</p><p>12.runninglisteners.</p><h2 id="四-SpringCloud源码"><a href="#四-SpringCloud源码" class="headerlink" title="四.SpringCloud源码"></a>四.SpringCloud源码</h2><p>五大组件一个一个的分析</p><p>nocos: 服务注册(启动) 服务发现(线程池定时任务) 服务续约(线程池定时任务)</p><h2 id="五-Redis源码分析"><a href="#五-Redis源码分析" class="headerlink" title="五.Redis源码分析"></a>五.Redis源码分析</h2><p>io多路复用!!!</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="1-课程内容"><a href="#1-课程内容" class="headerlink" title="1.课程内容"></a>1.课程内容</h3><ul><li>常见设计模式</li><li>Spring的IOC启动流程</li><li>AOP原理</li><li>SpringBoot自动配置</li></ul><h3 id="2-面试必备"><a href="#2-面试必备" class="headerlink" title="2.面试必备"></a>2.面试必备</h3><ul><li><p>常见的设计模式说一下，以及你用过的框架中哪儿用到这些设计模式。</p></li><li><p>什么是单例，如何实现</p></li><li><p>模板模式的作用</p></li><li><p>什么是适配器模式</p></li><li><p>什么是代理模式？有几种代理？</p></li><li><p>Spring使用的是哪种代理模式？</p></li><li><p>JDK动态代理和CGLIB动态代理的区别？</p></li><li><p>介绍一下Spring</p></li><li><p>什么是Spirng的IOC</p></li><li><p>IOC的启动流程有了解过吗？(或 IOC是如何管理Bean的)</p></li><li><p>Bean的生命周期讲一下</p></li><li><p>IOC容器是如何保证Bean的单例的？</p></li><li><p>Spring如何解决Bean的循环依赖</p></li><li><p>说几个Spring的IOC的容器工厂类</p></li><li><p>你知道@Autowaire自动注入的实现原理吗？</p></li><li><p>你知道@Transcational注解的实现原理吗？</p></li><li><p>你知道AOP的实现原理吗？</p></li><li><p>SpringBoot自动配置原理</p></li><li><p>SpringBoot启动流程？</p></li><li><p>Eureka是如何实现服务发现和服务续约的？</p></li><li><p>说一下 Ribbon的工作原理</p></li><li><p>说一下Feign的工作原理</p></li><li><p>说一下Zuul的执行原理？</p></li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://mliutm.github.io">清风</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://mliutm.github.io/breeze/613abb62.html">https://mliutm.github.io/breeze/613abb62.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://mliutm.github.io" target="_blank">清风</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><a class="post-meta__tags" href="/tags/%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81/">框架源码</a></div><div class="post_share"><div class="social-share" data-image="/img/photo-1692708632140-ee01624d558d.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/breeze/dd39a55f.html" title="基础源码分析与Linux优化"><img class="cover" src="/img/photo-1653549892896-dde02867edee.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">基础源码分析与Linux优化</div></div></a></div><div class="next-post pull-right"><a href="/breeze/75a56cf8.html" title="MySQL多机优化"><img class="cover" src="/img/photo-1645943020355-305df166473d.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MySQL多机优化</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/breeze/1d2ccb18.html" title="Spring（一）"><img class="cover" src="/img/photo-1688475747590-d0db5e2412cb.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-20</div><div class="title">Spring（一）</div></div></a></div><div><a href="/breeze/364ea8cc.html" title="设计模式"><img class="cover" src="/img/photo-1653549892896-dde02867edee.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-04</div><div class="title">设计模式</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">清风</div><div class="author-info__description">清风洒六合，邈然不可攀</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">162</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:huangpan0805@163.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div><timing></timing></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">常用设计模式&amp;Spring源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9"><span class="toc-text">课程内容</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">一.常用设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0"><span class="toc-text">1.设计模式概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">1.1.什么是设计模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB"><span class="toc-text">1.2.设计模式分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.常见的设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-0-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.0 享元模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%8D%95%E4%BE%8B"><span class="toc-text">2.1.单例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%A5%BF%E6%B1%89%E5%BC%8F"><span class="toc-text">1.饿汉式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%87%92%E6%B1%89%E5%BC%8F-volatile"><span class="toc-text">2.懒汉式(***volatile)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%9E%9A%E4%B8%BE-%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E5%BB%BA%E8%AE%AE%E7%94%A8%E5%AE%83"><span class="toc-text">3.枚举-自己实现单例建议用它</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-Map-spring"><span class="toc-text">4 Map-spring</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%B7%A5%E5%8E%82"><span class="toc-text">2.2.工厂</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82"><span class="toc-text">1.简单工厂</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="toc-text">2.工厂方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82-%E7%BB%91%E5%AE%9A%E5%88%9B%E5%BB%BA"><span class="toc-text">3.抽象工厂-绑定创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%89%8B%E6%92%95spring-Map%E7%BC%93%E5%AD%98-%E5%8D%95%E4%BE%8B-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82-%E5%8F%8D%E5%B0%84-%E9%87%8D%E8%A6%81"><span class="toc-text">4.手撕spring-Map缓存(单例)+简单工厂+反射-重要</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.3.策略模式+工厂模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E7%8A%B6%E6%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.4 状态设计模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.5 模板模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.6.代理模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">1.静态代理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">2.JDK动态代理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-CGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">3.CGLIB动态代理</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">二.Spring源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-IOC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">1.IOC源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-IOC-DI-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">1.1.IOC&#x2F;DI 的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-IOC%E6%A0%B8%E5%BF%83%E7%B1%BB"><span class="toc-text">1.2.IOC核心类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-IOC%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B"><span class="toc-text">1.3.IOC入门案例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-1-xml%E7%89%88%E6%9C%AC"><span class="toc-text">1.3.1 xml版本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-2-javaconfig-%E9%87%8D%E8%A6%81"><span class="toc-text">1.3.2 javaconfig 重要 *****</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E8%A7%A3%E6%9E%90bean%E5%AE%9A%E4%B9%89"><span class="toc-text">1.4.解析bean定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-%E5%8D%95%E4%BE%8BBean%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">1.5.单例Bean的初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">1.6.Bean的生命周期 ****</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-Bean%E7%9A%84%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5"><span class="toc-text">1.7.Bean的属性注入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8-Autowired-%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86"><span class="toc-text">1.8.Autowired 自动注入原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-9-Bean%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-text">1.9.Bean的循环依赖(******)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-AOP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">2.AOP源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-AOP%E7%90%86%E8%A7%A3"><span class="toc-text">2.1.AOP理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">2.2.AOP实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-AOP%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-text">2.3.AOP启动流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E4%BA%8B%E5%8A%A1%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">2.4.事务源码分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Transactional-%E4%BA%8B%E5%8A%A1%E6%B5%81%E7%A8%8B"><span class="toc-text">Transactional 事务流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-SpringBoot%E6%BA%90%E7%A0%81"><span class="toc-text">三.SpringBoot源码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-text">1.SpringBoot自动配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-SpringBoot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-text">2.SpringBoot启动流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-SpringCloud%E6%BA%90%E7%A0%81"><span class="toc-text">四.SpringCloud源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">五.Redis源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9"><span class="toc-text">1.课程内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87"><span class="toc-text">2.面试必备</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/breeze/7832219d.html" title="十万字面试总结"><img src="/img/photo-1653549892896-dde02867edee.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="十万字面试总结"></a><div class="content"><a class="title" href="/breeze/7832219d.html" title="十万字面试总结">十万字面试总结</a><time datetime="2024-02-29T02:50:00.000Z" title="发表于 2024-02-29 10:50:00">2024-02-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/breeze/7ae0ca37.html" title="Redis_30道经典面试题"><img src="/img/premium_photo-1695185954894-e9382c6f4da8.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Redis_30道经典面试题"></a><div class="content"><a class="title" href="/breeze/7ae0ca37.html" title="Redis_30道经典面试题">Redis_30道经典面试题</a><time datetime="2024-02-29T02:45:00.000Z" title="发表于 2024-02-29 10:45:00">2024-02-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/breeze/2a548e97.html" title="面试实战"><img src="/img/photo-1645943020355-305df166473d.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="面试实战"></a><div class="content"><a class="title" href="/breeze/2a548e97.html" title="面试实战">面试实战</a><time datetime="2024-02-29T02:43:59.000Z" title="发表于 2024-02-29 10:43:59">2024-02-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/breeze/4edde71e.html" title="Vue2-3-Vue3状态管理Pinia（十一）"><img src="/img/photo-1653549892896-dde02867edee.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Vue2-3-Vue3状态管理Pinia（十一）"></a><div class="content"><a class="title" href="/breeze/4edde71e.html" title="Vue2-3-Vue3状态管理Pinia（十一）">Vue2-3-Vue3状态管理Pinia（十一）</a><time datetime="2024-02-03T13:31:25.000Z" title="发表于 2024-02-03 21:31:25">2024-02-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/breeze/da043fa1.html" title="Vue2-3-大事件管理系统（十）"><img src="/img/photo-1692708632140-ee01624d558d.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Vue2-3-大事件管理系统（十）"></a><div class="content"><a class="title" href="/breeze/da043fa1.html" title="Vue2-3-大事件管理系统（十）">Vue2-3-大事件管理系统（十）</a><time datetime="2024-02-03T13:30:11.000Z" title="发表于 2024-02-03 21:30:11">2024-02-03</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/img/photo-1692708632140-ee01624d558d.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 <i id="heartbeat" class="fa fas fa-heartbeat"></i> 清风</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></head></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script src="/js/timing.js"></script><script id="canvas_nest" defer color="255,0,255" opacity="0.7" zindex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!0,document.body.addEventListener("input",POWERMODE)</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="天枢,天璇,天玑,天权,玉衡,开阳,瑶光" data-fontsize="15px" data-random="true" async></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>