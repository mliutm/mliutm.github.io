<!DOCTYPE html><html class="hide-aside" lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>java面试题全覆盖-RH | 清风</title><meta name="author" content="清风"><meta name="copyright" content="清风"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java面试题大全一.JavaSE 部分基础部分Java中基本数据类型有哪些？byte：8位，最大存储数据量是255，存放的数据范围是-128~127之间。 short：16位， int：32位，最大数据存储容量是2的32次方减1，数据范围是负的2的31次方到正的2的31次方减1。 long：64位，最大数据存储容量是2的64次方减1，数据范围为负的2的63次方到正的2的63次方减1。 float"><meta property="og:type" content="article"><meta property="og:title" content="java面试题全覆盖-RH"><meta property="og:url" content="https://mliutm.github.io/breeze/6fb0f153.html"><meta property="og:site_name" content="清风"><meta property="og:description" content="Java面试题大全一.JavaSE 部分基础部分Java中基本数据类型有哪些？byte：8位，最大存储数据量是255，存放的数据范围是-128~127之间。 short：16位， int：32位，最大数据存储容量是2的32次方减1，数据范围是负的2的31次方到正的2的31次方减1。 long：64位，最大数据存储容量是2的64次方减1，数据范围为负的2的63次方到正的2的63次方减1。 float"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://mliutm.github.io/img/premium_photo-1695185954894-e9382c6f4da8.jpg"><meta property="article:published_time" content="2023-12-19T13:10:22.000Z"><meta property="article:modified_time" content="2024-03-01T07:32:30.707Z"><meta property="article:author" content="清风"><meta property="article:tag" content="面试题"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://mliutm.github.io/img/premium_photo-1695185954894-e9382c6f4da8.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://mliutm.github.io/breeze/6fb0f153.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,top_n_per_article:1,unescape:!1,languages:{hits_empty:"找不到您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!1,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"java面试题全覆盖-RH",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-03-01 15:32:30"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,a){0!==a&&(a=864e5*a,t={value:t,expiry:(new Date).getTime()+a},localStorage.setItem(e,JSON.stringify(t)))},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!((new Date).getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=o=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.getCSS=(o,n=!1)=>new Promise((t,e)=>{const a=document.createElement("link");a.rel="stylesheet",a.href=o,n&&(a.id=n),a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">169</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">82</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/img/premium_photo-1695185954894-e9382c6f4da8.jpg)"><nav id="nav"><span id="blog-info"><a href="/" title="清风"><span class="site-name">清风</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java面试题全覆盖-RH</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-19T13:10:22.000Z" title="发表于 2023-12-19 21:10:22">2023-12-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-01T07:32:30.707Z" title="更新于 2024-03-01 15:32:30">2024-03-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">60.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>186分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="java面试题全覆盖-RH"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Java面试题大全"><a href="#Java面试题大全" class="headerlink" title="Java面试题大全"></a>Java面试题大全</h1><h2 id="一-JavaSE-部分"><a href="#一-JavaSE-部分" class="headerlink" title="一.JavaSE 部分"></a>一.JavaSE 部分</h2><h3 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h3><h4 id="Java中基本数据类型有哪些？"><a href="#Java中基本数据类型有哪些？" class="headerlink" title="Java中基本数据类型有哪些？"></a>Java中基本数据类型有哪些？</h4><p>byte：8位，最大存储数据量是255，存放的数据范围是-128~127之间。</p><p>short：16位，</p><p>int：32位，最大数据存储容量是2的32次方减1，数据范围是负的2的31次方到正的2的31次方减1。</p><p>long：64位，最大数据存储容量是2的64次方减1，数据范围为负的2的63次方到正的2的63次方减1。</p><p>float：32位，</p><p>double：64位，</p><p>boolean：只有true和false两个取值。</p><p>char：16位，存储Unicode码，用单引号赋值。</p><h4 id="Integer-和-int的区别"><a href="#Integer-和-int的区别" class="headerlink" title="Integer 和 int的区别"></a>Integer 和 int的区别</h4><p><strong>int</strong>是基本数据类型，变量中直接存放数值，变量初始<strong>化时值是0</strong></p><p><strong>Integer</strong>是引用数据类型，变量中存放的是该对象的引用，变量<strong>初始化时值时null</strong></p><p>Integer是int类型的包装类，将int封装成Integer，符合java面向对象的特性，可以使用各种方法比如和其他数据类型间的转换</p><p>Integer和int的深入对比：</p><ol><li><p>两个通过new生成的Integer对象，由于在堆中地址不同，所以永远不相等</p></li><li><p>int和Integer比较时，只要数值相等，结果就相等，因为包装类和基本数据类型比较时，会自动拆箱，将Integer转化为int</p></li><li><p>通过new生成的Integer对象和非通过new生成的Integer对象相比较时，由于前者存放在堆中，后者存放在Java常量池中，所以永远不相等</p></li><li><p>两个非通过new生成的Integer对象比较时，如果两个变量的数值相等且在-128到127之间，结果就相等。这是因为给Integer对象赋一个int值，java在编译时，会自动调用静态方法valueOf()，根据java api中对Integer类型的valueOf的定义，对于-128到127之间的整数，会进行缓存，如果下次再赋相同的值会直接从缓存中取，即享元模式</p></li></ol><h4 id="有了int为什么还需要integer？"><a href="#有了int为什么还需要integer？" class="headerlink" title="有了int为什么还需要integer？"></a>有了int为什么还需要integer？</h4><ol><li><p>集合和泛型：Java的集合框架和泛型只能操作对象，不能直接使用原始类型。如果需要将int存储在集合(List、Set等)中，就需要将其包装为Integer。</p></li><li><p>可空性：int是原始数据类型，不能表示null值。但是在某些情况下，需要表示一个变量可能为空的情况，此时可以使用Integer，因为Integer是一个类，它可以为null。</p></li><li><p>API要求：某些API要求参数或返回值类型必须是对象，而不是原始类型。如果需要使用这些API，就需要将int转换为Integer。</p></li></ol><h4 id="有了integer为什么还需要int"><a href="#有了integer为什么还需要int" class="headerlink" title="有了integer为什么还需要int?"></a>有了integer为什么还需要int?</h4><p>有了Integer为什么还需要int？</p><ol><li><p>性能：int是原始类型，存储和操作起来更加高效。对于大量的计算和数据操作，使用int可以提高程序的性能。</p></li><li><p>内存占用：Integer是一个对象，会占用额外的内存空间。在需要大量存储整数的情况下，使用int可以节省内存。</p></li><li><p>计算操作：使用int进行算术计算更加方便和简单，不需要进行对象的装箱和拆箱操作。</p></li></ol><blockquote><p><strong>总结：</strong></p><p>int和Integer在使用上有一定的差异和适用场景。Integer适用于需要集合、泛型、可空性以及符合API要求的情况。而int适用于对性能和内存消耗有要求的场景，以及直接进行算术计算的操作。在使用时，可以根据具体的需求和场景来选择适合的类型。</p></blockquote><h4 id="String和StringBuilder和StringBuffer区别"><a href="#String和StringBuilder和StringBuffer区别" class="headerlink" title="String和StringBuilder和StringBuffer区别"></a>String和StringBuilder和StringBuffer区别</h4><p><strong>三者</strong>底层都是<code>char[]</code>存储数据,都是处理字符串，JDK1.9之后使用的是byte[] ，因为往往我们存储都是短字符串，使用byte[]这样更节约空间。</p><p>由于String底层的char[]有<code>final</code>修饰，因此每次对String的操作都会在内存中开辟空间，生成新的对象，所以String内存不可变</p><p>StringBuilder和StringBuffer是可变字符串，没有final修饰，适合字符串拼接，另外StringBuffer是线程安全的，方法有<code>synchronized</code>修饰，但是性能较低，StringBuilder是线程不安全的，方法没有synchronized修饰，性能较高</p><h4 id="String-a-“A”-和-String-a-new-String-“A”-创建字符串的区别"><a href="#String-a-“A”-和-String-a-new-String-“A”-创建字符串的区别" class="headerlink" title="String a &#x3D; “A” 和 String a &#x3D; new String(“A”) 创建字符串的区别"></a>String a &#x3D; “A” 和 String a &#x3D; new String(“A”) 创建字符串的区别</h4><p>String c &#x3D; “A” 首先去常量池找 “A”，如果有，会把a指向这个对象的地址 ，如果没有在常量池中放一个,并指向它</p><p>new String(“A”) ： 在堆中创建一个对象</p><h4 id="String的常量池和享元模式"><a href="#String的常量池和享元模式" class="headerlink" title="String的常量池和享元模式"></a>String的常量池和享元模式</h4><p>常量池是堆中的一块存储区域，用于存储显式的String、float、Integer等数据。这是一个特殊的共享区域，开发时不需要在内存中经常改变的数据，都可以放在这里进行共享。</p><p>享元模式的核心就是共享对象，通过来回利用对象的内部细节创建更少的对象的方式供外部使用，进而降低系统的内存消耗来提升系统性能</p><h4 id="下面代码创建了几个对象"><a href="#下面代码创建了几个对象" class="headerlink" title="下面代码创建了几个对象"></a>下面代码创建了几个对象</h4><ul><li>String s &#x3D; “a” +”b” + “c” + “d”;这条语句创建了几个对象？</li></ul><p>创建了一个对象，因为相对于字符串常量相加的表达式，编译器会在编译期间进行优化，直接将其编译成常量相加的结果。</p><ul><li><p>String s； 创建几个对象？<br>没有创建对象。</p></li><li><p>String a &#x3D; “abc”; String b &#x3D; “abc”; 创建了几个对象</p><p>创建了一个对象，只是在第一条语句中创建了一个对象，a和b都指向相同的对象”abc”，引用不是对象</p></li></ul><h4 id="和-equals-的区别是什么"><a href="#和-equals-的区别是什么" class="headerlink" title="&#x3D;&#x3D; 和 equals 的区别是什么"></a>&#x3D;&#x3D; 和 equals 的区别是什么</h4><p><code>==</code>比较对象比较的是地址，对于Object对象中的<code>equals</code> 方法使用的也是 &#x3D;&#x3D; ，比较的是对象的地址，默认情况下使用对象的equals比较Object中的equals方法，也就是比较地址，如果要实现自己的比较方式需要复写equals 方法。</p><p>对于包装类比如：Integer都是复写过equals方法，比较的是int 值。</p><h4 id="final-和-finally-和-finalize-的区别"><a href="#final-和-finally-和-finalize-的区别" class="headerlink" title="final 和 finally 和 finalize 的区别"></a>final 和 finally 和 finalize 的区别</h4><p>当用final修饰类的时，表明该类不能被其他类所继承。当我们需要让一个类永远不被继承，此时就可以用final修饰</p><p>finally作为异常处理的一部分，它只能用在try&#x2F;catch语句中，并且附带一个语句块，表示这段语句最终一定会被执行（不管有没有抛出异常），经常被用在需要释放资源的情况下</p><p>finalize()是在java.lang.Object里定义的，也就是说每一个对象都有这么个方法。这个方法在gc启动，该对象被回收的时候被调用。其实gc可以回收大部分的对象（凡是new出来的对象，gc都能搞定，一般情况下我们又不会用new以外的方式去创建对象），所以一般是不需要程序员去实现finalize的。</p><h4 id="JDK-和-JRE-有什么区别？"><a href="#JDK-和-JRE-有什么区别？" class="headerlink" title="JDK 和 JRE 有什么区别？"></a>JDK 和 JRE 有什么区别？</h4><p>JRE(Java Runtime Enviroment) ：是Java的运行环境，JRE是运行Java程序所必须环境的集合，包含JVM标准实现及 Java核心类库</p><p>JDK(Java Development Kit) ：是Java开发工具包，它提供了Java的开发环境(提供了编译器javac等工具，用于将java文件编译为class文件)和运行环境(提 供了JVM和Runtime辅助包，用于解析class文件使其得到运行)。JDK是整个Java的核心，包括了Java运行环境(JRE)，一堆Java工具tools.jar和Java标准类库 (rt.jar)。</p><h4 id="面向对象四大特性"><a href="#面向对象四大特性" class="headerlink" title="面向对象四大特性"></a>面向对象四大特性</h4><p>抽象 : 是将一类对象的共同特征总结出来构造类的过程,包括数据抽象和行为抽象两方面,抽象只关注对象的哪些属性和行为,并不关注这此行为的细节是什么 - 举例：定义一个persion类，了就是对<code>人</code>这种事物的抽象</p><p>封装：对数据的访问只能通过已定义的接口,封装就是隐藏一切可隐藏的东西,只向外界提供最简单的编程接口，比如在Java中，把不需要暴露的内容和实现细节隐藏起来，或者private修饰，然后提供专门的访问方法，如JavaBean。 - 生活举例：电脑主机就是把主板等封装到机壳，提供USB接口，网卡接口，电源接口等。 JavaBean就是一种封装。</p><p>继承：新类(子类，派生类)继承了原始类的特性，子类可以从它的父类哪里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。</p><p>多态：多态是指允许不同类的对象对同一消息做出响应。对象的多种形态，当编译时类型和运行时类型不一样，就是多态，意义在于屏蔽子类差异</p><h4 id="方法覆盖和重载"><a href="#方法覆盖和重载" class="headerlink" title="方法覆盖和重载"></a>方法覆盖和重载</h4><p>方法的覆盖是子类和父类之间的关系，方法的重载是同一个类中方法之间的关系。<br>覆盖只能由一个方法，或只能由一对方法产生关系；方法的重载是多个方法之间的关系。<br>覆盖要求参数列表相同；重载要求参数列表不同。</p><h4 id="普通类和抽象类"><a href="#普通类和抽象类" class="headerlink" title="普通类和抽象类"></a>普通类和抽象类</h4><p>抽象类不能被实例化, 需要通过子类实例化<br>抽象类可以有构造函数，被继承时子类必须继承父类一个构造方法，抽象方法不能被声明为静态。<br>抽象方法只需申明，而无需实现，抽象类中可以允许普通方法有主体<br>含有抽象方法的类必须申明为抽象类<br>抽象的子类必须实现抽象类中所有抽象方法，否则这个子类也是抽象类</p><h4 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h4><p>定义接口使用interface，定义抽象类使用abstract class</p><p>接口由全局常量，抽象方法，（java8后：静态方法，默认方法）</p><p>抽象类由构造方法，抽象方法，普通方法</p><p>接口和类是实现关系，抽象类和类是继承关系</p><h4 id="方法重载和方法重写"><a href="#方法重载和方法重写" class="headerlink" title="方法重载和方法重写"></a>方法重载和方法重写</h4><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p><p>重载(overload) 一个类中，同名的方法如果有不同的参数列表（<strong>参数类型不同、参数个数不同甚至是参数顺序不同</strong>）则视为重载</p><p>重写(override)发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。</p><hr><h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><h4 id="你知道BIO-NIO-AIO么？讲一下你的理解"><a href="#你知道BIO-NIO-AIO么？讲一下你的理解" class="headerlink" title="你知道BIO,NIO,AIO么？讲一下你的理解"></a>你知道BIO,NIO,AIO么？讲一下你的理解</h4><p>BIO （Blocking I&#x2F;O）：同步阻塞I&#x2F;O 模式，以流的方式处理数据，数据的读取写入必须阻塞在一个线程内等待其完成。适用于连接数目比较小且固定的架构</p><p>NIO （New I&#x2F;O）：同时支持阻塞与非阻塞模式，以块的方式处理数据，适用于连接数目多且连接比较短（轻操作）的架构，比如聊天器</p><p>AIO （ Asynchronous I&#x2F;O）：异步非阻塞I&#x2F;O 模型，适用于连接数目多且连接比较长（重操作）的架构</p><h4 id="java-中四大基础流"><a href="#java-中四大基础流" class="headerlink" title="java 中四大基础流"></a>java 中四大基础流</h4><p>InputStream : 输入字节流, 也就是说它既属于输入流, 也属于字节流 ，</p><p>OutputStream: 输出字节流, 既属于输出流, 也属于字节流</p><p>Reader: 输入字符流, 既属于输入流, 又属于字符流</p><p>Writer: 输出字符流, 既属于输出流, 又属于字符流</p><h4 id="读文本用什么流，读图片用什么流"><a href="#读文本用什么流，读图片用什么流" class="headerlink" title="读文本用什么流，读图片用什么流"></a>读文本用什么流，读图片用什么流</h4><p>文本用字符输入流，读图片用字节输入流</p><h4 id="字符流和字节流有什么区别"><a href="#字符流和字节流有什么区别" class="headerlink" title="字符流和字节流有什么区别"></a>字符流和字节流有什么区别</h4><p>字符流适用于读文本，字节流适用于读图片，视频，文件等。</p><p>字节流操作的基本单元为字节；字符流操作的基本单元为Unicode码元。</p><p>字节流默认不使用缓冲区；字符流使用缓冲区。</p><p>字节流通常用于处理二进制数据，实际上它可以处理任意类型的数据，但它不支持直接写入或读取Unicode码元；字符流通常处理文本数据，它支持写入及读取Unicode码元</p><h4 id="BufferedInputStream-用到什么设计模式"><a href="#BufferedInputStream-用到什么设计模式" class="headerlink" title="BufferedInputStream 用到什么设计模式"></a>BufferedInputStream 用到什么设计模式</h4><p>主要运用了俩个设计模式，适配器和装饰者模式</p><h4 id="带缓冲区的流"><a href="#带缓冲区的流" class="headerlink" title="带缓冲区的流"></a>带缓冲区的流</h4><p>BufferedInputStream 带缓冲区的字节输入</p><p>BufferedOutputStream 带缓冲区的输出流</p><p>BufferedReader : 带缓冲区的字符输入流</p><p>BufferedWriter : 带缓冲区的字符输出流</p><hr><h3 id="集合篇"><a href="#集合篇" class="headerlink" title="集合篇"></a>集合篇</h3><h4 id="说一下Java中的集合体系"><a href="#说一下Java中的集合体系" class="headerlink" title="说一下Java中的集合体系"></a>说一下Java中的集合体系</h4><p>Collection接口</p><p>List：</p><ul><li><p>ArrayList：底层数据结构是数组，查询性能高，增删性能低</p></li><li><p>Vector：底层数据结构是数组，查询性能高，增删性能低</p></li><li><p>LinkedList：底层数据结构是双向链表，查询性能低，增删性能高</p></li></ul><p>Set：</p><ul><li><p>HashSet：无序不重复的，使用HashMap的key存储元素，判断重复依据是hashCode()和equals()</p></li><li><p>TreeSet：有序不重复的，底层使用TreeMap的key存储元素，排序方式分为自然排序，比较器排序</p></li></ul><p>Map接口</p><ul><li>HashMap：key的值没有顺序，线程不安</li><li>TreeMap：key的值可以自然排序，线程不安全</li><li>HashTable：它的key和value都不允许为null，线程安全</li><li>Properties：它的key和value都是String类型的，线程安全</li></ul><h4 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h4><p>HashMap和HashTable都是实现了Map接口的集合框架，他们的区别</p><ul><li><p>HashTable是线程安全的，它的实现方法都加了synchronized关键字，因此它的性能较低</p></li><li><p>HashMap是线程不安全的，它实现方法没有加synchronized，因此它的性能较高</p></li><li><p>HashMap的key和value都允许为null，HashTable中的key和value都不能为null,如果不考虑线程安全，建议使用HashMap，如果需要考虑线程安全的高并发实现，建议使用ConcurrentHashMap</p></li></ul><h4 id="ArrayList和LinkedList区别"><a href="#ArrayList和LinkedList区别" class="headerlink" title="ArrayList和LinkedList区别"></a>ArrayList和LinkedList区别</h4><p>都属于线性结构，ArrayList是基于数组实现的，开辟的内存空间要求连续，可以根据索引随机访问元素性能高，但是插入和删除元素性能差，因为这会涉及到移位操作</p><p>LinkedList是基于双链表实现的，开配的内存空间不要求连续，因此不支持索引，查找元素需要从头查找，因此性能差，但是添加删除只需要改变指针指向即可，性能高. LinkedList会增加内存碎片化，增加内存管理难度</p><p>根据实际需要，如果项目中使用查找较多，使用ArrayList，如果使用增删较多，请使用LinkedList</p><h4 id="ArrayList和Vector区别"><a href="#ArrayList和Vector区别" class="headerlink" title="ArrayList和Vector区别"></a>ArrayList和Vector区别</h4><p>ArrayList是线程不安全的，Vector相反是线程安全的，方法加了同步锁，线程安全但是性能差，ArrayList底层数组容量不足时，会自动扩容0.5倍，Vector会自动扩容1倍</p><h4 id="一个User的List集合，如何实现根据年龄排序"><a href="#一个User的List集合，如何实现根据年龄排序" class="headerlink" title="一个User的List集合，如何实现根据年龄排序"></a>一个User的List集合，如何实现根据年龄排序</h4><p>第一种方式，让User类实现Comparable接口，覆写compareTo方法，方法中自定义根据年龄比较的算法</p><p>第二种方式，调用Collections.sort方法，传入一个比较器，覆写compare方法，方法中自定义根据年龄比较的算法</p><p>代码实现方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种方式 - 让User类实现Comparable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructor, getters, and setters</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(User otherUser)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(<span class="built_in">this</span>.age, otherUser.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方式 - 使用比较器实现</span></span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgeComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(User user1, User user2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(user1.getAge(), user2.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在某处调用排序</span></span><br><span class="line">List&lt;User&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 添加 User 对象到 userList</span></span><br><span class="line"><span class="comment">// 使用 Comparable 接口方式排序</span></span><br><span class="line">Collections.sort(userList);</span><br><span class="line"><span class="comment">// 使用 Comparator 方式排序</span></span><br><span class="line">Collections.sort(userList, <span class="keyword">new</span> <span class="title class_">AgeComparator</span>());</span><br></pre></td></tr></table></figure><h4 id="HashMap底层实现原理"><a href="#HashMap底层实现原理" class="headerlink" title="HashMap底层实现原理"></a>HashMap底层实现原理</h4><p>HashMap是基于哈希表的Map接口的非同步实现。HashMap是一个存储key-value键值对的集合，每一个键值对也叫做entry，这些entry分散存储在一个数组中，这个数组也是HashMap的主干，这个数组每个元素的初始值都是null。</p><h4 id="HashMap底层用到了那些数据结构？"><a href="#HashMap底层用到了那些数据结构？" class="headerlink" title="HashMap底层用到了那些数据结构？"></a>HashMap底层用到了那些数据结构？</h4><p>JDK1.7及其之前：数组，链表 ; JDK1.8开始：数组，链表，红黑树</p><h4 id="什么是Hash冲突"><a href="#什么是Hash冲突" class="headerlink" title="什么是Hash冲突"></a>什么是Hash冲突</h4><p>哈希冲突，也叫哈希碰撞，指的是两个不同的值，计算出了相同的hash，也就是两个不同的数据计算出同一个下标，通常解决方案有：</p><ul><li><p>拉链法，把哈希碰撞的元素指向一个链表</p></li><li><p>开放寻址法，把产生冲突的哈希值作为值，再进行哈希运算，直到不冲突</p></li><li><p>再散列法，就是换一种哈希算法重来一次</p></li><li><p>建立公共溢出区，把哈希表分为基本表和溢出表，将产生哈希冲突的元素移到溢出表</p></li></ul><h4 id="HashMap为什么要用到链表结构"><a href="#HashMap为什么要用到链表结构" class="headerlink" title="HashMap为什么要用到链表结构"></a>HashMap为什么要用到链表结构</h4><p>当我们向HashMap中添加元素时，会先根据key进行哈希运算，把hash值模与数组长度得到一个下标，然后将该元素添加进去。但是如果产生了哈希碰撞，也就是不同的key计算出了相同的hash值，这就出问题了，因此它采用了拉链法来解决这个问题，将产生hash碰撞的元素，挂载到链表中</p><h4 id="HashMap为什么要用到红黑树"><a href="#HashMap为什么要用到红黑树" class="headerlink" title="HashMap为什么要用到红黑树"></a>HashMap为什么要用到红黑树</h4><p>当HashMap中同一个索引位置出现哈希碰撞的元素多了，链表会变得越来越长，查询效率会变得越来越慢。因此在JDK1.8之后，当链表长度超过8个，会将链表转换为红黑树来提高查询</p><h4 id="hashmap为什么要使用红黑树不使用自平衡二叉树？"><a href="#hashmap为什么要使用红黑树不使用自平衡二叉树？" class="headerlink" title="hashmap为什么要使用红黑树不使用自平衡二叉树？"></a>hashmap为什么要使用红黑树不使用自平衡二叉树？</h4><p>HashMap 在 Java 中使用红黑树来处理哈希冲突的情况，而不是使用自平衡二叉树，是因为红黑树具有更好的平衡性能。红黑树是一种特殊的二叉搜索树，它可以在保持相对平衡的同时，提供较快的插入、删除和查找操作。</p><p>相比之下，普通的自平衡二叉树（如 AVL 树）虽然也能够保持树的平衡，但在某些特定场景下会出现性能问题。例如，AVL 树在进行插入和删除操作时可能需要频繁地进行旋转操作，这会增加操作的时间复杂度。而红黑树通过引入额外的约束条件和旋转操作，可以更好地维护树的平衡性，并且在大多数情况下保持较好的性能表现。</p><p>因此，HashMap 使用红黑树作为解决哈希冲突的一种方式，可以更好地平衡性能和空间的需求，提高整体的运行效率。</p><h4 id="HashMap链表和红黑树在什么情况下转换的？"><a href="#HashMap链表和红黑树在什么情况下转换的？" class="headerlink" title="HashMap链表和红黑树在什么情况下转换的？"></a>HashMap链表和红黑树在什么情况下转换的？</h4><p>当链表的长度大于等于8，同时数组的长度大于64，链表会自动转化为红黑树,当树中的节点数小于等于6，红黑树会自动转化为链表</p><h4 id="HashMap在什么情况下扩容？HashMap如何扩容的？"><a href="#HashMap在什么情况下扩容？HashMap如何扩容的？" class="headerlink" title="HashMap在什么情况下扩容？HashMap如何扩容的？"></a>HashMap在什么情况下扩容？HashMap如何扩容的？</h4><p>HashMap的数组初始容量是16，负载因子是0.75，也就是说当数组中的元素个数大于12个，会成倍扩容</p><p>tips:为啥子是0.75：负载因子过小容易浪费空间，过大容易造成更多的哈希碰撞，产生更多的链表和树，因此折衷考虑采用了0.75</p><p>为啥子是成倍扩容：需要保证数组的长度是2的整数次幂</p><p>为嘛数组的长度必须是2的整数次幂：我们在存储元素到数组中的时候，是通过hash值模与数组的长度，计算出下标的。但是由于计算机的运算效率，加减法&gt;乘法&gt;除法&gt;取模，取模的效率是最低的。开发者们为了让你用的开心，也是呕心沥血。将取模运算转化成了与运算，即数组长度减1的值和hash值的与运算，以此来优化性能。但是这个转化有一个前提，就是数组的长度必须为2的整数次幂</p><h4 id="java中，集合的相关扩容机制"><a href="#java中，集合的相关扩容机制" class="headerlink" title="java中，集合的相关扩容机制"></a>java中，集合的相关扩容机制</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38568503/article/details/114215833">java集合的扩容机制</a></p><h4 id="HashMap是如何Put一个元素的"><a href="#HashMap是如何Put一个元素的" class="headerlink" title="HashMap是如何Put一个元素的"></a>HashMap是如何Put一个元素的</h4><p>首先，将key进行hash运算，将这个hash值与上当前数组长度减1的值，计算出索引。此时判断该索引位置是否已经有元素了，如果没有，就直接放到这个位置</p><p>如果这个位置已经有元素了，也就是产生了哈希碰撞，那么判断旧元素的key和新元素的key的hash值是否相同，并且将他们进行equals比较，如果相同证明是同一个key，就覆盖旧数据，并将旧数据返回，如果不相同的话</p><p>再判断当前桶是链表还是红黑树，如果是红黑树，就按红黑树的方式，写入该数据，</p><p>如果是链表，就依次遍历并比较当前节点的key和新元素的key是否相同，如果相同就覆盖，如果不同就接着往下找，直到找到空节点并把数据封装成新节点挂到链表尾部。然后需要判断，当前链表的长度是否大于转化红黑树的阈值，如果大于就转化红黑树，最后判断数组长度是否需要扩容。</p><h4 id="HashMap是如何Get一个元素的"><a href="#HashMap是如何Get一个元素的" class="headerlink" title="HashMap是如何Get一个元素的"></a>HashMap是如何Get一个元素的</h4><p>首先将key进行哈希运算，计算出数组中的索引位置，判断该索引位置是否有元素，如果没有，就返回null,如果有值，判断该数据的key是否为查询的key，如果是就返回当前值的value</p><p>如果第一个元素的key不匹配，判断是红黑树还是链表,如果是红黑树，就就按照红黑树的查询方式查找元素并返回,如果是链表，就遍历并匹配key，让后返回value值</p><h4 id="你知道HahsMap死循环问题吗"><a href="#你知道HahsMap死循环问题吗" class="headerlink" title="你知道HahsMap死循环问题吗"></a>你知道HahsMap死循环问题吗</h4><p>HashMap在扩容数组的时候，会将旧数据迁徙到新数组中，这个操作会将原来链表中的数据颠倒，比如a-&gt;b-&gt;null，转换成b-&gt;a-&gt;null</p><p>这个过程单线程是没有问题的，但是在多线程环境，就可能会出现a-&gt;b-&gt;a-&gt;b….，这就是死循环</p><p>在JDK1.8后，做了改进保证了转换后链表顺序一致，死循环问题得到了解决。但还是会出现高并发时数据丢失的问题，因此在多线程情况下还是建议使用ConcurrentHashMap来保证线程安全问题</p><h4 id="说一下你对ConcurrentHashMap的理解"><a href="#说一下你对ConcurrentHashMap的理解" class="headerlink" title="说一下你对ConcurrentHashMap的理解"></a>说一下你对ConcurrentHashMap的理解</h4><p>ConcurrentHashMap，它是HashMap的线程安全，支持高并发的版本</p><p>在jdk1.7中，它是通过分段锁的方式来实现线程安全的。意思是将哈希表分成许多片段Segment，而Segment本质是一个可重入的互斥锁，所以叫做分段锁。</p><p>在jdk1.8中，它是采用了CAS操作和synchronized来实现的，而且每个Node节点的value和next都用了volatile关键字修饰，保证了可见性</p><hr><h2 id="二-JavaEE-框架-中间件"><a href="#二-JavaEE-框架-中间件" class="headerlink" title="二.JavaEE&amp;框架&amp;中间件"></a>二.JavaEE&amp;框架&amp;中间件</h2><h3 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h3><h4 id="平均值用什么，分组用什么"><a href="#平均值用什么，分组用什么" class="headerlink" title="平均值用什么，分组用什么"></a>平均值用什么，分组用什么</h4><p>统计平均值：avg , 分组：group by</p><h4 id="两个相同列的结果集求并集用什么"><a href="#两个相同列的结果集求并集用什么" class="headerlink" title="两个相同列的结果集求并集用什么"></a>两个相同列的结果集求并集用什么</h4><p>union 并集 , union all(允许重复并集)</p><h4 id="完整查询SQL中的关键字的定义顺序"><a href="#完整查询SQL中的关键字的定义顺序" class="headerlink" title="完整查询SQL中的关键字的定义顺序"></a>完整查询SQL中的关键字的定义顺序</h4><p>SELECT 列名 FROM 表1 JOIN 表2 ON 条件 WHERE 条件 GROUP BY 列名 HAVING 条件 ORDER BY 列名 LIMIT</p><h4 id="完整的多表JOIN查询，SQL中关键字的执行顺序"><a href="#完整的多表JOIN查询，SQL中关键字的执行顺序" class="headerlink" title="完整的多表JOIN查询，SQL中关键字的执行顺序"></a>完整的多表JOIN查询，SQL中关键字的执行顺序</h4><p>FROM –&gt; ON –&gt; JOIN –&gt; WHERE –&gt; GROUP BY –&gt; HAVING –&gt; ORDER BY –&gt; LIMIT</p><h4 id="员工表employee字段有-id-username-amount-deptname"><a href="#员工表employee字段有-id-username-amount-deptname" class="headerlink" title="员工表employee字段有: id, username, amount ,deptname ."></a>员工表employee字段有: id, username, amount ,deptname .</h4><ul><li>求每个部门总人数怎么做 ,</li></ul><p>select 部门名,count(id) from employee group by deptname</p><ul><li>求每个部门总工资怎么做?</li></ul><p>select 部门名,sum(amount) from employee group by deptname</p><h3 id="Spring部分"><a href="#Spring部分" class="headerlink" title="Spring部分"></a>Spring部分</h3><h4 id="介绍一下Spring"><a href="#介绍一下Spring" class="headerlink" title="介绍一下Spring"></a>介绍一下Spring</h4><p>Spring是一个开源的轻量级控制反转和面向切面编程的容器框架。轻量级是说它开发使用简单，功能强大。控制反转是指将对象的创建，销毁控制交给ioc容器，方便解耦合，降低维护难度，面向切面编程是指将相同的逻辑横向抽取出来，可以对一些通用业务如事务，日志进行集中管理</p><h4 id="说下Spring框架的组成-不熟悉"><a href="#说下Spring框架的组成-不熟悉" class="headerlink" title="说下Spring框架的组成(不熟悉)"></a>说下Spring框架的组成(不熟悉)</h4><ol><li>CoreContain核心容器模块：<ol><li>spring-core：提供框架的基本组成部分，包括 IoC 和依赖注入功能</li><li>spring-beans：提供 BeanFactory，工厂模式</li><li>context：提供国际化，事件传播，资源加载等功能</li><li>spring-ExpressionLanguage：提供表达式语言</li></ol></li><li>Web模块<ol><li>Web：提供面向web的基本功能和面向web的应用上下文</li><li>Web-MVC：为web应用提供模型视图控制（MVC）</li><li>Web-Socket：在 web 应用程序中提供客户端和服务器端之间通信的方式</li><li><strong>Web-Portlet：模块提供了用于Portlet环境的MVC实现</strong></li></ol></li><li>数据&#x2F;集成模块<ol><li>JDBC：包含了Spring对JDBC数据访问进行封装的所有类</li><li>ORM：为对象-关系映射提供交互层</li><li>OXM：提供对Object&#x2F;XML映射实现的抽象层</li><li>JMS：主要包含了一些制造、消费和消息的功能</li><li><strong>Transaction：为实现特殊接口类以及所有的 POJO 支持编程式和声明式的事务管理</strong></li></ol></li><li>其他模块<ol><li>AOP：提供了面向切面编程相关实现</li><li>Aspects：模块提供了与AspectJ的集成，是一个功能强大的AOP框架</li><li><strong>Instrumentation</strong>：提供了class instrumentation 的支持和类加载器classloader的实现</li><li><strong>Messaging：为 STOMP 提供支持</strong></li><li>Test：支持使用JUnit和TestNG对Spring组件进行测试</li></ol></li></ol><h4 id="什么是Spirng的IOC"><a href="#什么是Spirng的IOC" class="headerlink" title="什么是Spirng的IOC"></a>什么是Spirng的IOC</h4><p>IOC控制反转，把对象的创建，属性设置，初始化，销毁等工作交给Spirng的IOC容器去管理，解放程序员的劳动力。</p><p>对象被注册到Spring的IOC容器中，使用的时候从容器中获取即可，非常方便。</p><p>它通过依赖注入，将需要的外部资源注入到组件中，使用IOC使得对象之间的耦合度降低，资源变得容易管理，从而使得代码更加优雅</p><p>IOC操作Bean管理,bean管理是指(1)spring创建对象(2)spring注入属性,在一个类上标注@Service或者@Controller或@Component或@Repository注解后,spring的组件扫描就会发现他,并且会将它初始化为spring应用上下文的bean</p><h4 id="你对AOP的理解"><a href="#你对AOP的理解" class="headerlink" title="你对AOP的理解"></a>你对AOP的理解</h4><p>AOP，Aspect Oriented Programming 英文首字母缩写，意为面向切面编程，是Spring的核心思想之一</p><p>AOP是对OOP(面向对象编程)的一种补充，能够做到很多面向对象无法做到的事情，比如需要在所有方法执行前开启事务，打印日志，如果使用面向对象来编程，将会产生大量重复代码，而使用AOP，可以将那些与业务无关，却为业务模块所共同调用的逻辑封装起来，一次解决这些问题。而这些重复的代码，一般统称为横切逻辑代码</p><p>使用AOP，在不改变原有业务逻辑的情况下，实现解耦合，避免横切逻辑代码重复</p><p>AOP的使用场景包括日志记录，性能统计，安全控制，事务处理，异常处理等等</p><p>它是基于动态代理实现的，分为JDK动态代理和CGLIB动态代理。JDK动态代理只支持实现了接口的类 ，CGLIB支持没有实现接口的类。Spring默认使用JDK动态代理，如果被代理类没有实现接口，会选择CGLIB动态代理</p><h4 id="AOP的通知"><a href="#AOP的通知" class="headerlink" title="AOP的通知"></a>AOP的通知</h4><ul><li><strong>Before advice（前置通知）</strong>：连接点前面执行，不能终止后续流程，除非抛异常</li><li><strong>After returning advice（后置通知）</strong>：连接点正常返回时执行，有异常不执行</li><li><strong>Around advice（环绕通知）</strong>：围绕连接点前后执行，也能捕获异常处理</li><li><strong>After advice（最终通知）</strong>：连接点退出时执行，无论是正常退出还是异常退出</li><li><strong>After throwing advice（异常通知）</strong>：连接点方法抛出异常时执行</li></ul><h4 id="Spring的Bean懒加载和非懒加载有什么区别"><a href="#Spring的Bean懒加载和非懒加载有什么区别" class="headerlink" title="Spring的Bean懒加载和非懒加载有什么区别"></a>Spring的Bean懒加载和非懒加载有什么区别</h4><p>懒加载：需要使用对象的时候才创建，节省资源，但不利于提前发现错误</p><p>非懒加载，也叫迫切加载，容器启动时就创建对象，消耗资源，但有利于提前发现错误</p><p>spring中默认时迫切加载，即在项目启动时，spring会扫描符合条件的所有bean并将其初始化</p><p>如果需要懒加载，可以使用@Lazy注释或者xml中配置属性default-lazy-init&#x3D;”true”</p><h4 id="什么情况下事务会失效？"><a href="#什么情况下事务会失效？" class="headerlink" title="什么情况下事务会失效？"></a>什么情况下事务会失效？</h4><ul><li><p>在方法中捕获异常没有抛出去</p></li><li><p>非事务方法调用事务方法</p><blockquote><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/smallfa/p/14379346.html">同一个Service类中非事务方法调用事务方法，解决方法（3种）</a></p><p><strong>总结：</strong><font color="red">spring是采用动态代理机制实现事务控制的，而动态代理最终都是要调用原始对象的，而原始对象在调用方法的时候不会在触发代理了。所以，同一个类中，非事务方法调用事务方法是使用的原始对象去调用而不是代理对象，所以事务会失效。</font></p><p>使用@Autowired注入的对象也是代理对象，所以可以直接在service中注入自己（也是一个代理对象），然后在非事务方法中使用注入的代理对象去调用事务方法。（这里的事务方法得在接口中进行定义）</p></blockquote></li><li><p>@Transactional标记的方法不是public修饰的</p></li><li><p>抛出的异常与rollbackFor指定的异常不匹配，默认rollbackFor指定的异常为RuntimeException</p><p><code>@Transactional(rollbackFor=XueChengPlusException.class)</code></p></li><li><p>数据库表不支持事务，比如MySQL的MyISAM</p></li><li><p>Spring的传播行为导致事务失效，比如：<code>PROPAGATION_NEVER</code>、<code>PROPAGATION_NOT_SUPPORT</code></p><p><code>PROPAGATION_REQUIRED</code>– 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择</p><p><code>PROPAGATION_SUPPORTS</code>– 支持当前事务，如果当前没有事务，就以非事务方法执行</p><p><code>PROPAGATION_MANDATORY</code>– 支持当前事务，如果当前没有事务，就抛出异常</p><p><code>PROPAGATION_REQUIRES_NEW</code>– 新建事务，如果当前存在事务，把当前事务挂起</p><p><code>PROPAGATION_NOT_SUPPORTED</code>– 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</p><p><code>PROPAGATION_NEVER</code>– 以非事务方式执行，如果当前存在事务，则抛出异常</p><p><code>PROPAGATION_NESTED</code>– 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则与<code>PROPAGATION_REQUIRED</code>类似的操作。</p></li></ul><h4 id="Spring的依赖注入方式有哪些"><a href="#Spring的依赖注入方式有哪些" class="headerlink" title="Spring的依赖注入方式有哪些"></a>Spring的依赖注入方式有哪些</h4><p>方式一：setter方式注入，通过反射调用无参构造方法生成对象，再通过对于的setter方法注入配置的值，支持注解和xml两种实现方式</p><p>方式二：构造器方式注入，通过反射调用有参构造方法生成对象，支持注解和xml两种实现方式</p><p>注解实现方式：@Autowired，它是默认按类型匹配的、@Resource，它是默认按名字匹配的</p><h4 id="说一下定义切面相关的注解-AOP的通知"><a href="#说一下定义切面相关的注解-AOP的通知" class="headerlink" title="说一下定义切面相关的注解(AOP的通知)"></a>说一下定义切面相关的注解(AOP的通知)</h4><p>@Aspect：定义切面</p><p>@Pointcut：定义切点 &#x3D; cn.xx.service.*</p><p>@Before：前置通知，在目标方法运行之前运行</p><p>@After：后置通知，在目标方法运行结束之后运行（无论方法正常结束还是异常结束）</p><p>@AfterReturning：返回通知，在目标方法正常返回之后运行</p><p>@AfterThrowing：异常通知，在目标方法出现异常以后运行</p><p>@Around：动态代理，手动推进目标方法运行</p><h4 id="Bean的四种注册方式"><a href="#Bean的四种注册方式" class="headerlink" title="Bean的四种注册方式"></a>Bean的四种注册方式</h4><p>方式一：普通注册方式，直接通过class注册</p><p>方式二：简单静态工厂方式注册</p><p>方式三：简单实例工厂方式注册</p><p>方式四：FactoryBean方式注册</p><h4 id="四种实例化Bean的方式"><a href="#四种实例化Bean的方式" class="headerlink" title="四种实例化Bean的方式"></a>四种实例化Bean的方式</h4><p>使用构造器实例化Bean</p><p>使用静态工厂方式实例化Bean’</p><p>使用实例工厂方法实例化Bean</p><p>用setter方式</p><h4 id="注册Bean的注解有哪些"><a href="#注册Bean的注解有哪些" class="headerlink" title="注册Bean的注解有哪些"></a>注册Bean的注解有哪些</h4><p>@Controller&#x2F;@RestController 一般用于定义控制层的类</p><p>@Service	一般用于定义服务层的类</p><p>@Repository	一般用于定义持久层类</p><p>@Component	定义一般类</p><p>@Configuration 定义配置类</p><h4 id="IOC的启动流程有了解过吗-不熟悉"><a href="#IOC的启动流程有了解过吗-不熟悉" class="headerlink" title="IOC的启动流程有了解过吗(不熟悉)"></a>IOC的启动流程有了解过吗(不熟悉)</h4><p>当Spring启动时，IOC容器会加载Spring的配置文件，包括XML配置或者注解，然后解析这些Bean并把相关定义信息封装成BeanDefinition对象，通过Bean注册器BeanDefinitionRegistry注册到IOC容器，也就是一个ConcurrentHashMap中</p><p>此时会找出所有的单例且非惰性加载的bean，根据其BeanDefinition进行Bean的实例化，它会判断如果bean中有方法覆盖，就使用JDK反射创建Bean，否则使用CGLIB方式生成代理。然后把实例化好的Bean缓存到一个ConcurrentHashMap中</p><h4 id="Bean的生命周期讲一下-不熟悉"><a href="#Bean的生命周期讲一下-不熟悉" class="headerlink" title="Bean的生命周期讲一下 (不熟悉)"></a>Bean的生命周期讲一下 (不熟悉)</h4><p>从宏观的角度来说就是：实例化 ，属性注入，初始化，使用，销毁。更细的生命周期如下</p><ol><li><p>实例化：如果是单例且迫切加载的bean，在Spring容器启动时就会根据BeanDefinition进行实例化，如果时设置了懒加载或者多例模式的bean，在用的时候才会实例化</p></li><li><p>属性赋值：通过BeanDeifinition找到当前Bean所依赖的其他Bean，如果容器中有就直接拿过来，如果没有就根据创建流程区创建依赖的bean，然后通过反射给依赖的字段注入值</p></li><li><p>然后会调用BeanPostProcessor的前置处理器，对于@Autowired和@Transcational就是基于BeanPostProcessor来实现的。</p></li><li><p>接着会看Bean是否实现InitializingBean ，如果有会触发其afterPropertiesSet方法的调用</p></li><li><p>接着是调用我们自定义的bean的init-method方法，此时会调用执行</p></li><li><p>然后是调用BeanPostProcessor的后置处理</p></li><li><p>容器正常关闭，Bean进行销毁，会先调用实现了DisposableBean的destory方法。</p></li><li><p>接着调用我们指定的bean的destroy-method方法，此时会调用执行</p></li></ol><h4 id="单例多例的区别"><a href="#单例多例的区别" class="headerlink" title="单例多例的区别"></a>单例多例的区别</h4><p>单例和多例属于对象模式，单例模式指对象在整个系统中只存在一份，多例模式则可以有多个实例。</p><p>在spring的ioc容器中的bean默认都是单例的，如果需要使用多例，可以通过修改scope属性：scope&#x3D;”prototype”</p><p>如果一个bean是单例模式的，在处理多次请求的时候，在ioc容器中只实例化一个bean，这个对象会被保存在一个map中，当有请求来的时候，会先从map中查看，如果有就直接使用这个对象，没有才会实例化新的对象。</p><p>如果是多例(prototype)模式的bean，每次请求来的时候，会直接实例化新的bean，没有map缓存的过程。</p><h4 id="Spring的Bean被指定为prototype以及singleton有什么区别"><a href="#Spring的Bean被指定为prototype以及singleton有什么区别" class="headerlink" title="Spring的Bean被指定为prototype以及singleton有什么区别"></a>Spring的Bean被指定为prototype以及singleton有什么区别</h4><p>这两者分别指的是多例和单例模式，singleton即单例模式，指对象在整个系统中只存在一份；prototype即多例模式系统中可以有多个实例。</p><p>如果一个bean是单例模式的，在处理多次请求的时候，在ioc容器中只实例化一个bean，这个对象会被保存在一个map中，当有请求来的时候，会先从map中查看，如果有就直接使用这个对象，没有才会实例化新的对象。</p><p>如果是多例模式的bean，每次请求来的时候，会直接实例化新的bean，没有map缓存的过程。</p><p>在spring的ioc容器中的bean默认都是单例的，如果需要使用多例，可以指定scope属性：scope&#x3D;”prototype”</p><h4 id="BeanFactory和ApplicationContext有什么区别"><a href="#BeanFactory和ApplicationContext有什么区别" class="headerlink" title="BeanFactory和ApplicationContext有什么区别"></a>BeanFactory和ApplicationContext有什么区别</h4><p>BeanFactory接口是IOC容器的核心接口，定义了管理bean的最基本方法，比如实例化，配置，管理，获取bean的方法</p><p>ApplicationContext接口是BeanFactory接口的子接口，除了继承BeanFactory中所有管理bean的方法，还拥有环境、国际化、资源、事件等服务相关的接口</p><p>BeanFactory是延迟加载，ApplicationContext是迫切加载</p><h4 id="BeanFactory和FactoryBean的区别"><a href="#BeanFactory和FactoryBean的区别" class="headerlink" title="BeanFactory和FactoryBean的区别"></a>BeanFactory和FactoryBean的区别</h4><p>BeanFactory接口是IOC容器的核心接口，定义了管理bean的最基本方法，比如实例化，配置，管理，获取bean的方法</p><p>FactoryBean是IOC容器创建bean的一种形式，可以通过实现此接口来创建实例化过程比较复杂的bean</p><h4 id="IOC容器是如何保证Bean的单例的？"><a href="#IOC容器是如何保证Bean的单例的？" class="headerlink" title="IOC容器是如何保证Bean的单例的？"></a>IOC容器是如何保证Bean的单例的？</h4><p>IOC容器会将单例模式的bean放入一个ConcurrentHashMap中，需要这个bean时直接到这个map中获取，如果没有找到才会实例化这个bean。而ConcurrentHashMap本身时线程安全的，也就保证了Bean是单例的</p><h4 id="Spring如何解决Bean的循环依赖-不熟悉"><a href="#Spring如何解决Bean的循环依赖-不熟悉" class="headerlink" title="Spring如何解决Bean的循环依赖 (不熟悉)"></a>Spring如何解决Bean的循环依赖 (不熟悉)</h4><p>核心思想在于提前曝光,是用三级缓存进行提前曝光</p><p>循环依赖分为三种，构造器注入循环依赖 ，setter方式注入循环依赖，多例模式Bean的循环依赖。而Spring解决了单例bean的setter注入循环依赖</p><p>setter循环依赖的解决主要使用了<strong>三级缓存</strong></p><ul><li>一级缓存，用来缓存已经实例化好的bean，即单例Bean缓存池</li><li>二级缓存，用来缓存正在创建的bean</li><li>三级缓存，用来缓存创建bean的实例工厂ObjectFactory</li></ul><p>当Spring发现两个Bean存在循环依赖时，它会将正在创建的Bean及其依赖的Bean的ObjectFactory先存入三级缓存中,当某个Bean的创建完成时，Spring会从它依赖的Bean的ObjectFactory中获取出其依赖的Bean并完成注入，并将Bean从三级缓存中移除，最后以单例的形式放入第一级缓存中</p><p>当实例化好A，在属性注入环境，发现A依赖了B，会先将正在创建的A的实例工厂ObjectFactory放入三级缓存，然后去创建B的实例。</p><p>走Bean的实例化流程创建B，在B的属注入环节发现，B依赖了A，这个时候就会去三级缓存中，找到A的创建工厂ObjectFactory获取A的实例，并注入到B中。此时B就初始化好了，然后将B实例放入一级缓存。最后将B实例注入到A中，A也就创建好了</p><p>在getBean的时候，如果单例Bean缓存池没有Bean,就会走二级缓存尝试获取，如果也没有，就会走三级缓存拿到Bean的ObjectFacory创建Bean,然后把Bean放入二级缓存。</p><h4 id="Spring构造器注入能循环依赖吗"><a href="#Spring构造器注入能循环依赖吗" class="headerlink" title="Spring构造器注入能循环依赖吗"></a>Spring构造器注入能循环依赖吗</h4><p>构造注入不能解决循环依赖的原因是：如果A的构造其中依赖了B B的构造器中又依赖了A 在getSingleton中三级缓存需要调用getObject()构造器，来构造提早暴露但未设置属性的bean，此时就会产生无限递归创建</p><p>多例模式下Bean是不做缓存的，所以就没法暴露ObjectFactory，也就没办法解决循环依赖</p><h4 id="说几个Spring的IOC的容器工厂类"><a href="#说几个Spring的IOC的容器工厂类" class="headerlink" title="说几个Spring的IOC的容器工厂类"></a>说几个Spring的IOC的容器工厂类</h4><p>BeanFactory：IOC容器顶层接口，提供了Bean获取的基础方法</p><p>DefaultListableBeanFactory：是整个 bean 加载的核心部分，Spring 注册及加载Bean 的默认实现</p><p>ApplicationContext：除了实现IOC基本功能外，还扩展了国际化支持，资源访问，事件发布</p><p>ClasspathXmlApplicationContext：从classpath中获取XML配置</p><h4 id="你知道Spring的AOP主要基于什么设计模式实现吗"><a href="#你知道Spring的AOP主要基于什么设计模式实现吗" class="headerlink" title="你知道Spring的AOP主要基于什么设计模式实现吗"></a>你知道Spring的AOP主要基于什么设计模式实现吗</h4><p>AOP的实现原理是基于动态代理，动态代理就是在运行时期动态的为原生类生成代理类以达到代码增强的目的，且代理类是持有原生类的，可以在代理类中调用原生类以及做一些增强业务。</p><p>动态代理分为JDK动态代理和CGLIB代理，CGLIB代理需要导入相关的jar包，两者的区别是JDK动态代理要求目标类需要实现至少一个接口。而CGLIB则是基于继承进行代理，原生类可以不实现任何接口</p><p>Spring中默认采用JDK动态代理，如果原生类没有实现任何接口，Spring会选择CGLIB代理，或者你可以在配置文件中强制指定使用CGLIB代理</p><h4 id="Autowired的使用"><a href="#Autowired的使用" class="headerlink" title="@Autowired的使用"></a><strong>@Autowired的使用</strong></h4><p>可以标注在属性上 方法上和构造器上来完成自动装配,根据属性累型将匹配到的属性值进行注入,就可以使用这个属性autowiredBean对象的方法</p><h4 id="你知道-Autowired自动注入的实现原理吗？"><a href="#你知道-Autowired自动注入的实现原理吗？" class="headerlink" title="你知道@Autowired自动注入的实现原理吗？"></a>你知道@Autowired自动注入的实现原理吗？</h4><p>自动注入是通过BeanPostProcessor 后置处理器AutowiredAnnotationBeanPostProcessor完成的，在Bean实例化过程中，触发了AutowiredAnnotationBeanPostProcessor的postProcessPropertyValues方法的调用执行，它就会扫描当前类中是否有@Autowired注解，然后得到自动注入依赖的bean的类型，并去容器中得到依赖的bean实例，如果没有就走Bean的实例化流程创建依赖的Bean，然后反射进行字段赋值。</p><h4 id="你知道-Transcational注解的实现原理吗？"><a href="#你知道-Transcational注解的实现原理吗？" class="headerlink" title="你知道@Transcational注解的实现原理吗？"></a>你知道@Transcational注解的实现原理吗？</h4><p>分为两个动作吧，第一个是解析@Transcational注解，在Sping中有个后置处理器InfrastructureAdvisorAutoProxyCreator，在Bean的初始化过程中，它负责解析标记了@Transcational注解的类，生成代理。还创建了 TransactionAttributeSource ，它是对事务注解的封装，以及 TransactionInterceptor 事务拦截器。</p><p>在执行业务方法的时候，代码会进入事务拦截器TransactionInterceptor去执行事务相关的代码，TransactionInterceptor主要是通过调用TranscationManagerment的事务API，而TranscationManagerment又是调用connection的事务API完成事务操作。</p><p><strong>Spring的作用域</strong></p><p>singleton</p><p>prototype</p><p>request</p><p>session</p><p>application</p><h3 id="Javaweb基础"><a href="#Javaweb基础" class="headerlink" title="Javaweb基础"></a>Javaweb基础</h3><h4 id="常见Http状态码"><a href="#常见Http状态码" class="headerlink" title="常见Http状态码"></a>常见Http状态码</h4><p>200 成功返回状态</p><p>301 永久重定向，被请求的资源永久移动到新位置</p><p>302 临时重定向，被请求的资源临时移动到新的位置，项目中使用了oauth2，对目标资源访问无权限时就会见到，它是会重定向到授权地址</p><p>401 无权限访问</p><p>403 禁止访问，服务器已经接收到请求，但拒绝执行</p><p>404 找不到该资源</p><p>500 服务器内部错误 zuul找不到服务名就会见到</p><p>503 服务器内部错误 服务器维护或者过载</p><p>504 网关超时</p><h4 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h4><p>Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程：</p><ul><li>Servlet 初始化后调用 <strong>init ()</strong> 方法。</li><li>Servlet 调用 <strong>service()</strong> 方法来处理客户端的请求。</li><li>Servlet 销毁前调用 <strong>destroy()</strong> 方法。</li><li>最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。</li></ul><h4 id="什么是过滤器？怎么创建一个过滤器"><a href="#什么是过滤器？怎么创建一个过滤器" class="headerlink" title="什么是过滤器？怎么创建一个过滤器"></a>什么是过滤器？怎么创建一个过滤器</h4><p>过滤器：在请求发送之后，处理之前对请求的一次拦截，可以更改请求状态或者参数值等。</p><p>创建过滤器：实现filter接口，重写doFilter方法，最后在web.xml中配置过滤器</p><h4 id="讲一下Session的工作原理"><a href="#讲一下Session的工作原理" class="headerlink" title="讲一下Session的工作原理"></a>讲一下Session的工作原理</h4><p>服务端的session id会自动写入客户端的cookie中，每次请求客户端回自动把cookie带入后台，后台自动根据cookie中的sessionid就能找到session</p><h4 id="Session和cookie有什么区别"><a href="#Session和cookie有什么区别" class="headerlink" title="Session和cookie有什么区别"></a>Session和cookie有什么区别</h4><p>session和cookie都是为了弥补http协议的无状态特性，解决会话问题</p><p>session是以ConcurrentHashMap结构存储在服务器端，同时生成一个sessionid返回客户端并存放到cookie中</p><p>cookie是将数据存储在客户浏览器端</p><p>session占用服务器的性能，但安全性较高，使用cookie减轻服务器的压力，但有被用户篡改风险因此安全性较低</p><h4 id="http协议的无状态特性是什么意思？"><a href="#http协议的无状态特性是什么意思？" class="headerlink" title="http协议的无状态特性是什么意思？"></a>http协议的无状态特性是什么意思？</h4><p>HTTP协议的无状态特性指的是每个请求之间是相互独立的，服务器不会保存关于客户端请求的状态信息。简单来说，服务器在处理每个客户端请求时，并不会记住之前的请求信息，也不会保存任何关于客户端的状态数据。这意味着每个请求都必须包含所有必要的信息，服务器不能依赖之前的请求来处理当前请求。因此，每个HTTP请求都是独立的，服务器无法从之前的请求中获取任何信息。</p><h4 id="客户端和服务端的一次会话是啥意思？"><a href="#客户端和服务端的一次会话是啥意思？" class="headerlink" title="客户端和服务端的一次会话是啥意思？"></a>客户端和服务端的一次会话是啥意思？</h4><p>客户端和服务端的一次会话指的是在一段时间内，客户端与服务器之间进行的一系列相互关联的请求和响应交互。在这个会话过程中，客户端发送请求到服务器，服务器处理请求并返回响应给客户端，双方可以进行多次这样的通信交互。在这个过程中，客户端和服务器之间可能会传递一些状态信息，以便在会话期间保持一些状态，比如使用Cookie、Session等机制。</p><p>一次会话的概念有助于理解客户端和服务器之间的交互过程，并且能够帮助管理和维护会话期间的状态信息。通过一次会话，客户端和服务器可以进行连续的通信，实现更复杂的功能和交互体验。</p><h4 id="说说preparedStatement和Statement的区别"><a href="#说说preparedStatement和Statement的区别" class="headerlink" title="说说preparedStatement和Statement的区别"></a>说说preparedStatement和Statement的区别</h4><p>statement的sql语句使用字符串拼接，很容易出错，而preparedStatement使用？作为占位符，不容易出错易于维护</p><p>statement不对sql语句作处理，直接交给数据库，而preparedStatement支持预编译，事先将编译好的sql语句放到数据库端，相当于缓存，因此效率更高</p><p>statement有sql注入风险，preparedStatement没有sql注入风险</p><h4 id="请求转发和重定向的区别"><a href="#请求转发和重定向的区别" class="headerlink" title="请求转发和重定向的区别"></a>请求转发和重定向的区别</h4><p>转发是一次请求，可以共享同一组request和response，重定向是多次请求，不能共享同一组request和response</p><p>转发地址栏不会发生变化，重定向地址栏会发生变化</p><p>转发不能到外部应用，重定向可以到尾部应用</p><p>如果我们需要数据共享，使用转发，如果需要访问内部资源(WEB-INF)，使用转发，如果需要跨域到外部资源，必须使用重定向</p><h4 id="get和post请求的区别"><a href="#get和post请求的区别" class="headerlink" title="get和post请求的区别"></a>get和post请求的区别</h4><p>最直观的区别，get把参数包含在url中，post是把参数放到request body中</p><p>post相对于get更安全,post发送的数据更大，get有url的长度限制</p><p>post更发送更多的数据类型，get只能发送ASCII字符</p><p>在restful中，get一般用户查询搜索数据，post一般用户添加或者修改数据</p><h4 id="JSP的原理"><a href="#JSP的原理" class="headerlink" title="JSP的原理"></a>JSP的原理</h4><p>jsp的本质就是servlet,每个JSP文件都回被编译成一个Serverlet去执行，在该Serverlet会对JSP中的动态内容进行替换，静态部分是标准的html，动态部分是java程序</p><h3 id="SpringMVC部分"><a href="#SpringMVC部分" class="headerlink" title="SpringMVC部分"></a>SpringMVC部分</h3><h4 id="SpringMVC怎么样设定重定向和转发的"><a href="#SpringMVC怎么样设定重定向和转发的" class="headerlink" title="SpringMVC怎么样设定重定向和转发的"></a>SpringMVC怎么样设定重定向和转发的</h4><p>重定向是指将用户从当前请求重新定向到一个视图页面，或者是一个handler处理请求，以前的request域中信息全部失效，同时地址栏会发生变化，它是客户端行为</p><p>转发是指将用户从当前请求转发给另一个视图页面或者handler处理请求，以前的request域可以共享，地址栏不会发生变化，它是服务器行为</p><p>springmvc默认是使用转发方式跳转的，且会默认经过视图解析器,我们也可以通过指定，转发时在返回值前面加”forward:”，重定向时在返回值前面加”redirect:”，且此时就不会再经过视图解析器了</p><h4 id="SpringMVC如何对时间格式的参数进行格式化"><a href="#SpringMVC如何对时间格式的参数进行格式化" class="headerlink" title="SpringMVC如何对时间格式的参数进行格式化"></a>SpringMVC如何对时间格式的参数进行格式化</h4><p>第一种需求，后台接收前台页面返回的string类型时间，要转换成的Date类型数据，可以使用**@DateTimeFormat**注解来接收参数</p><p>第二种需求，后台将Date类型数据返回给前台页面，默认是返回时间戳，如果想要优雅的格式，可以在模型的Date字段或get方法上使用**@JsonFormat**注解</p><h4 id="SpringMVC常用的注解有哪些"><a href="#SpringMVC常用的注解有哪些" class="headerlink" title="SpringMVC常用的注解有哪些"></a>SpringMVC常用的注解有哪些</h4><p>@Controller：用来标识一个类是控制器类</p><p>@RequestMapping：用来映射请求路径和参数</p><p>@ResponseBody：将返回值放到responsebody中，通常返回json或者xml格式数据</p><p>@RequestBody：将前台请求参数转换成对象</p><p>@PathVariable：接收路径参数，通常用在restful接口中</p><p>@RestController：@Controller和@ResponseBody的组合注解</p><p>@ControllerAdvice：运用aop的思想，对全局做一些处理，比如结合@ExceptionHandler做全局异常捕获</p><h4 id="如何定义SpringMVC的拦截器"><a href="#如何定义SpringMVC的拦截器" class="headerlink" title="如何定义SpringMVC的拦截器"></a>如何定义SpringMVC的拦截器</h4><p>SpringMVC 的拦截器主要用于拦截用户的请求并做相应的处理，通常应用在权限验证、判断登录等功能上</p><p>第1步，定义拦截器：可以<strong>实现 HandlerInterceptor 接口</strong>来自定义拦截器，接口定义了三个方法，preHandler方法是在请求到达处理器之前执行，postHandler方法是在请求经过处理器之后、解析试图之前执行，afterCompletion方法是在视图渲染之后、返回客户端之前执行</p><p>第2步，配置拦截器：在springmvc的<strong>配置文件xml</strong>中，配置所有拦截路径，以及需要放行的路径</p><h4 id="HandlerInterceptor和HandlerInterceptorAdapter的区别"><a href="#HandlerInterceptor和HandlerInterceptorAdapter的区别" class="headerlink" title="HandlerInterceptor和HandlerInterceptorAdapter的区别"></a>HandlerInterceptor和HandlerInterceptorAdapter的区别</h4><p>HandlerInterceptor是接口，我们可以实现该接口来定义拦截器，HandlerInterceptorAdapter是抽象类，它实现了HandlerInterceptor接口的子接口AsyncHandlerInterceptor，我们可以继承该类来定义拦截器，它简化拦截器的实现，默认preHandler返回true</p><h4 id="SpringMVC的执行原理"><a href="#SpringMVC的执行原理" class="headerlink" title="SpringMVC的执行原理"></a>SpringMVC的执行原理</h4><p>1.Http请求：客户端请求提交到DispatcherServlet-前端控制器</p><p>2.寻找处理器：由DispatcherServlet调用HandlerMapping-处理器映射器，根据url找到对应的的Handler</p><p>3.调用处理器：DispatcherServlet指定HandlerAdapter-处理器适配器去调用Handler</p><p>4.调用业务处理和返回结果：Handler调用业务逻辑处理完成后，返回ModelAndView</p><p>5.处理视图映射并返回模型： DispatcherServlet查询一个或多个ViewResoler-视图解析器，找到ModelAndView指定的视图</p><p>6.Http响应：将结果显示到客户端</p><h4 id="SpringMVC的执行流程"><a href="#SpringMVC的执行流程" class="headerlink" title="SpringMVC的执行流程"></a>SpringMVC的执行流程</h4><p>1.用户向服务器发送请求被<strong>前端控制器DispatcherServlet</strong>捕获</p><p>2.DispatcherServlet对请求的URL进行解析,得到请求资源符(URI),根据URI调用HandlerMapping<strong>获得该Handler</strong>配置的所有相关对象(包括Handler对象及对应的拦截器),最后以HandlerExecutionChain对象的形式返回</p><p>3.DispatcherServlet根据获取的Handler选择一个合适的HandlerAdpater.提取Request中的模型数据,填充Handler入参,开始<strong>执行Handler</strong>,执行完成后向DispatcherServlet返回一个ModelAndView对象.</p><p>4.DispatcherServlet 根据返回的ModelandView,<strong>选择合适的ViewResolver</strong></p><p>5.通过ViewResolver结合Model和View来渲染视图,DispatcherServlet将渲染结果返回给客户端.</p><p>核心控制器捕获请求,查找handler,执行handler,选择viewResolver,通过viewResolver渲染视图并返回.</p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_53353693/article/details/124057001">SpringMVC工作流程</a></p><h4 id="后端Controller获取参数的方式"><a href="#后端Controller获取参数的方式" class="headerlink" title="后端Controller获取参数的方式"></a>后端Controller获取参数的方式</h4><p>@PathVariable</p><p>@RequestParam</p><p>@RequestBody</p><h4 id="SpringMVC的Controller是单例还是多例，有没有并发安全问题，如何解决"><a href="#SpringMVC的Controller是单例还是多例，有没有并发安全问题，如何解决" class="headerlink" title="SpringMVC的Controller是单例还是多例，有没有并发安全问题，如何解决"></a>SpringMVC的Controller是单例还是多例，有没有并发安全问题，如何解决</h4><p>在spring中，bean默认都是单例的，controller也是交给spring容器管理的一个bean，因此它也是单例的。</p><p>单例的好处是减少了创建对象和垃圾回收的时间，节省了内存资源，但同时单例会造成线程不安全的问题，因为当所有请求访问同一个controller实例，controller中的成员变量是所有线程公用的，某个线程如果修改了这个变量，别的请求再来拿这个变量就变成修改后的值了</p><p>要解决这个问题，最直接有效的方式就是不要在controller中定义成员变量，如果你非要定义成员变量，两种方式</p><p>第一种，可以给controller上加注解@Scope(“prototype”)，将controller设置为多例模式，每次请求都重新实例化一个controller</p><p>第二种，使用ThreadLocal变量，让每一个线程都有自己独立的变量</p><h4 id="RequestMapping-和-GetMapping有什么区别"><a href="#RequestMapping-和-GetMapping有什么区别" class="headerlink" title="RequestMapping 和 GetMapping有什么区别"></a>RequestMapping 和 GetMapping有什么区别</h4><p>@Getmapping是一个组合注解，即是@RequestMapping(method &#x3D; RequestMethod.GET)的缩写，意思是只接收get请求的方法</p><p>@Requestmapping如果没有指定请求方式，可以接收get，put等各种类型的请求</p><h3 id="SpringBoot部分"><a href="#SpringBoot部分" class="headerlink" title="SpringBoot部分"></a>SpringBoot部分</h3><h4 id="相比Spring-Spring-Boot有哪些优点"><a href="#相比Spring-Spring-Boot有哪些优点" class="headerlink" title="相比Spring,Spring Boot有哪些优点"></a>相比Spring,Spring Boot有哪些优点</h4><p>Springboot是一个基于spring的框架，对spring做了大量简化，使开发流程更快，更高效</p><p>它大量简化maven依赖，管理了大量的基础依赖</p><p>基于注解配置（JavaConfig），无需xml配置</p><p>内嵌Tomcat，部署流程简单</p><p>打包和部署更加灵活，允许独立运行</p><p>集成了三方框架</p><h4 id="SpringBoot的常用注解"><a href="#SpringBoot的常用注解" class="headerlink" title="SpringBoot的常用注解"></a>SpringBoot的常用注解</h4><p>@Controller 用于修饰MVC中<code>controller</code>层的组件,为修饰的类实例化对象</p><p>@RequestMapping 于将Web请求路径映射到处理类的方法上 当作用于类上时，可以统一类中所有方法的路由路径 作用于方法上时，可单独指定方法的路由路径</p><p><code>method</code>属性可以指定请求的方式，如GET、POST、PUT、DELETE等</p><p>@Service 用于修饰<code>service</code>层的组件 专注于系统业务逻辑的处理</p><p>@Repository 用于修饰<code>dao</code>层的组件，<code>dao</code>层组件专注于系统数据的处理</p><p>@Component 用于修饰SpringBoot中的组件</p><p>@Autowired 根据对象的<code>类型</code>自动注入依赖对象</p><p>@Resource 默认会根据对象的<code>名称</code>自动注入依赖对象</p><p>@Bean 修饰方法，标识该方法会创建一个Bean实例</p><p>@Scope 声明一个SpringBean实例的作用域 (singleton prototype request session)</p><h4 id="Configuration和-Bean注解的作用"><a href="#Configuration和-Bean注解的作用" class="headerlink" title="@Configuration和@Bean注解的作用"></a>@Configuration和@Bean注解的作用</h4><p>在Spring中设置配置类的注解是<code>@Configuration</code>。使用此注解可以将Java类声明为Spring的配置类，该类中定义的bean将由Spring容器进行管理和配置,配置类中包含了<strong>用于创建和配置bean的方法通过@Bean注解</strong>声明要创建的bean，并通过方法返回值指定其类型</p><h4 id="SpringBoot如何做全局异常处理"><a href="#SpringBoot如何做全局异常处理" class="headerlink" title="SpringBoot如何做全局异常处理"></a>SpringBoot如何做全局异常处理</h4><p>可以使用@ControllerAdvice注解，编写一个全局异常处理类，再自定义一个方法使用@ExceptionHandler来捕获具体的异常并作相应的处理</p><p>通常情况下后台向前台返回结果时，会把结果封装成包含有错误码，错误信息以及数据本身的json数据，因此我们可以使用自定义异常类，自定义枚举错误码，在捕获全局异常后，向前台返回一个包含错误码的信息</p><h4 id="SpringBootApplication注解的含义"><a href="#SpringBootApplication注解的含义" class="headerlink" title="@SpringBootApplication注解的含义"></a>@SpringBootApplication注解的含义</h4><p>@SpringBootApplication是SprnigBoot项目的核心注解，目的是开启自动配置，并表示该类为主启动类。它包含三个子标签</p><ul><li>@ComponentScan注解：开启ioc自动扫描注解，默认扫描当前包及其子包中@Controller,@Service等，并把这些bean加载到ioc容器中</li><li>@EnableAutoConfiguration注解：启用springboot自动配置，自动所有扫描classpath目录下面所有jar中的spring.factories文件实现配置类批量注册</li><li>@SpringBootConfiguration注解：标志该类为springboot配置类</li></ul><h4 id="spring-boot-starter-parent的作用"><a href="#spring-boot-starter-parent的作用" class="headerlink" title="spring-boot-starter-parent的作用"></a>spring-boot-starter-parent的作用</h4><p>这是SpringBoot的父工程，它的作用是帮我们管理了很多的基础jar包，同时它继承了spring-boot-dependencies，在spring-boot-dependencies项目中通过<dependencymanagement>管理了大量的依赖，同时通过<properties>维护了这些依赖的版本号</properties></dependencymanagement></p><p>但是在项目中，还需要通过<dependencies>去导入具体的依赖才能使用</dependencies></p><h5 id="spring-boot-starter-web的作用"><a href="#spring-boot-starter-web的作用" class="headerlink" title="spring-boot-starter-web的作用"></a>spring-boot-starter-web的作用</h5><p>此项目是Springboot和Springmvc整个的jar包，构建了web项目的基本环境，集成了日志，tomcat，springmvc，json支持等等</p><h4 id="SpringBoot中如何读取配置"><a href="#SpringBoot中如何读取配置" class="headerlink" title="SpringBoot中如何读取配置"></a>SpringBoot中如何读取配置</h4><p>方式一：使用@Value读取配置文件</p><p>方式二：使用@ConfigurationProperties读取配置文件</p><h4 id="SpringBoot中日志的level有哪些"><a href="#SpringBoot中日志的level有哪些" class="headerlink" title="SpringBoot中日志的level有哪些"></a>SpringBoot中日志的level有哪些</h4><p>日志级别从低到高分别为：</p><p>TRACE &lt; DEBUG &lt;INFO &lt;WARN &lt; ERROR</p><p>如果设置为 WARN，则低于 WARN 的信息都不会输出</p><p>Spring中默认使用INFO级别输出到控制台</p><h4 id="SpringBoot中如何管理事务"><a href="#SpringBoot中如何管理事务" class="headerlink" title="SpringBoot中如何管理事务"></a>SpringBoot中如何管理事务</h4><p>事务(transaction)是指业务逻辑上对数据库进行的一系列持久化操作，要么全部成功，要么全部失败。</p><p>在Springboot中，可以<strong>通过xml配置和注解配置</strong></p><p>xml方式通过配置<strong>DataSourceTransactionManager和transactionManager</strong>实现</p><p>注解方式配置通过在<strong>主启动类</strong>上加上**@EnableTransactionManagement<strong>开启事务管理器，在具体的</strong>实现层service类<strong>上加上</strong>@Transactional** 实现事务</p><h4 id="SpringBoot自动配置原理"><a href="#SpringBoot自动配置原理" class="headerlink" title="SpringBoot自动配置原理"></a>SpringBoot自动配置原理</h4><p>在启动类上我们会打上： <strong>@SpringBootApplication</strong> 注解，它是一个组合标签，包括：</p><ul><li><strong>SpringBootConfiguration</strong> ,本质是一个 Configuration ，代表Spring的配置类。</li><li>IOC自动扫描的注解 ，<strong>ComponentScan</strong> 会去扫描类上是否有：@Component ,@Respository ,@Service @Controller ,如果有，就会把这个类自动注册到Spring容器中。</li><li>EnableAutoConfiguration ：就是启动SpringBoot自动配置的注解</li></ul><p>在 @EnableAutoConfiguration 注解中，注册了一个选择器，其中有一个方法会去返回很多的自动配置的的全限定名，这些类会自动注册到Spring容器中，</p><p>那它是怎么去找到这些所谓的自动配置类的呢？</p><p>他会通过Spring的SPI接口，也就是通过一个SpringFactoryLoader去扫描 classpath中的所有的jar包中的	MET-INF&#x2F;spring.factories 中的自动配置类，比如： DispatchServlert就对应了DispatchServletAutoConfiguration自动配置类 ， 它通过@Bean+方法的方式注册了一个 DispatchServlert 到Spring容器中了</p><h4 id="SpringBoot启动流程"><a href="#SpringBoot启动流程" class="headerlink" title="SpringBoot启动流程"></a>SpringBoot启动流程</h4><p>1.开启秒表计时</p><p>2.starting监听器，</p><p>3.处理应用参数</p><p>4.加载环境对象</p><p>5.打印横幅</p><p>6.创建Spring容器对象：AnnotationConfigApplicationContext</p><p>7.容器刷新的前置工作</p><p>8.刷新容器 ，这里会执行spring的ioc属性容器的refresh方法,Bean的加载，初始化等都在这个里面，Tomcat的启动也在这个方法里面。</p><p>9.刷新容器后置工作</p><p>10.秒表停止</p><p>11.started事件</p><p>12.调用runner</p><p>13.running.listeners.</p><h4 id="springboot多环境配置什么意思？怎么实现"><a href="#springboot多环境配置什么意思？怎么实现" class="headerlink" title="springboot多环境配置什么意思？怎么实现"></a>springboot多环境配置什么意思？怎么实现</h4><p>在开发SpringBoot项目时，我们通常需要针对不同的环境进行配置，例如开发环境、测试环境、生产环境等等。</p><p>Spring Boot框架提供了两种多环境配置的方式,分别是Profile文件多环境配置和@Profile注解多环境配置</p><h3 id="Mybatis部分"><a href="#Mybatis部分" class="headerlink" title="Mybatis部分"></a>Mybatis部分</h3><h4 id="Mybatis怎么做批量插入？"><a href="#Mybatis怎么做批量插入？" class="headerlink" title="Mybatis怎么做批量插入？"></a>Mybatis怎么做批量插入？</h4><p>在 MyBatis 中进行批量插入操作可以通过使用 <code>&lt;foreach&gt;</code> 标签结合批量操作的方式来实现。下面是使用MyBatis进行批量插入的步骤：</p><ol><li>在Mapper.xml文件中定义一个插入语句，使用foreach标签来遍历插入的数据集合。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;batchInsert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.util.List&quot;</span>&gt;</span></span><br><span class="line">    INSERT INTO table_name (column1, column2, ...) VALUES</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        (#&#123;item.property1&#125;, #&#123;item.property2&#125;, ...)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在Mapper接口中定义对应的方法，并使用@Param注解来指定方法参数的名称。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyMapper</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">batchInsert</span><span class="params">(<span class="meta">@Param(&quot;list&quot;)</span> List&lt;MyObject&gt; list)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在Java代码中调用批量插入的方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;MyObject&gt; dataList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 添加要插入的数据到dataList</span></span><br><span class="line"></span><br><span class="line">myMapper.batchInsert(dataList);</span><br></pre></td></tr></table></figure><p>在调用批量插入方法时，将需要插入的数据集合传递给方法即可。MyBatis会自动将数据批量插入到数据库中。</p><p>需要注意的是，批量插入对于大量数据的插入效果比逐条插入要好，但也需要根据实际情况和数据库性能进行适当的调整和配置，以避免数据库负载过大或其他性能问题。</p><h4 id="Mybatis怎么做高级查询？"><a href="#Mybatis怎么做高级查询？" class="headerlink" title="Mybatis怎么做高级查询？"></a>Mybatis怎么做高级查询？</h4><p>在MyBatis中进行高级查询通常需要结合动态SQL和参数映射来实现。下面是一些常用的技巧和方法：</p><ol><li>使用动态SQL实现条件查询：MyBatis的动态SQL功能允许在SQL语句中根据条件动态添加或排除部分语句。可以使用if、choose、trim、where、set等标签来动态构建查询条件。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM user</span><br><span class="line">  <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span></span><br><span class="line">      AND username = #&#123;username&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;status != null&quot;</span>&gt;</span></span><br><span class="line">      AND status = #&#123;status&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用关联查询：可以使用MyBatis进行多表关联查询，例如使用联合查询、子查询或者连接查询来检索相关数据。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findOrderWithUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Order&quot;</span>&gt;</span></span><br><span class="line">  SELECT order_id, order_name, user_id, username</span><br><span class="line">  FROM orders</span><br><span class="line">  INNER JOIN users ON orders.user_id = users.id</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>分页查询：MyBatis支持分页查询，可以使用limit或者rownum等数据库特定的分页语法，也可以结合动态SQL来动态组装分页相关的语句。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUsersByPage&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM user</span><br><span class="line">  LIMIT #&#123;offset&#125;, #&#123;pageSize&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>使用自定义的ResultMap进行结果映射：可以使用resultMap来自定义查询结果的映射规则，以便将查询结果映射为复杂的对象结构。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userDetails&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;role&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Role&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;roleId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;role_id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;roleName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;role_name&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上是使用MyBatis进行高级查询的一些常用技巧和方法，通过动态SQL、关联查询、分页查询和自定义的ResultMap等功能，可以实现复杂的查询需求。</p><h4 id="MyBatis中-取值和-取值的区别"><a href="#MyBatis中-取值和-取值的区别" class="headerlink" title="MyBatis中${}取值和#{}取值的区别"></a>MyBatis中${}取值和#{}取值的区别</h4><p>{}能够防止SQL注入，因为底层使用PreparedStatement对象，预编译，性能较高</p><p>${}不能防止SQL注入，因为底层使用Statement对象，不会预编译而是拼接字符串，性能较低</p><p>能使用#{}时尽量使用#{}，如果需要动态传入表名或者字段名需要用 ${}比如，像 ORDER BY 时只能使用${}</p><h4 id="MyBatis关联查询中，延迟加载和饥饿加载的区别"><a href="#MyBatis关联查询中，延迟加载和饥饿加载的区别" class="headerlink" title="MyBatis关联查询中，延迟加载和饥饿加载的区别"></a>MyBatis关联查询中，延迟加载和饥饿加载的区别</h4><p>延迟加载，是先从单表查询，需要使用关联数据的时候才发起关联查询，不用的时候不查询关联的数据，又叫懒加载,饥饿加载，是在查询时将关联的数据立即查询出来加载进内存，不管用不用</p><h4 id="MyBatis对象关联查询和集合关联查询怎么做"><a href="#MyBatis对象关联查询和集合关联查询怎么做" class="headerlink" title="MyBatis对象关联查询和集合关联查询怎么做"></a>MyBatis对象关联查询和集合关联查询怎么做</h4><p>单个关联对象用associate ，适用于多对一的关联查询，使用javaType来定义实体类型，集合用collection，适用于一对多的关联查询，使用ofType来定义集合的泛型类型</p><h4 id="MyBatis一级缓存和二级缓存的区别"><a href="#MyBatis一级缓存和二级缓存的区别" class="headerlink" title="MyBatis一级缓存和二级缓存的区别"></a>MyBatis一级缓存和二级缓存的区别</h4><p>缓存，是指将从数据库查询出的数据存放在缓存中，下次使用相同查询时不必再从数据库查询，而是直接从缓存中读取，从而减轻数据库查询的压力，提高性能</p><p>mybaits中的一级缓存，是SqlSession级别，默认开启，使用同一个SqlSession发送相同的SQL时命中；它的生命周期和SqlSession一致，当调用SqlSession.close()方法时会释放缓存</p><p>mybatis中的二级缓存，是namespace级别，默认不开启，执行同一个namespace的相同statement，发送相同的SQL时命中；它的生命周期是程序结束</p><p>当SQL中执行了update()、delete()、insert()操作，则缓存中的数据都会清空</p><h4 id="MyBaits的Mapper接口没有实现类为什么可以用-Autowired直接注入"><a href="#MyBaits的Mapper接口没有实现类为什么可以用-Autowired直接注入" class="headerlink" title="MyBaits的Mapper接口没有实现类为什么可以用@Autowired直接注入"></a>MyBaits的Mapper接口没有实现类为什么可以用@Autowired直接注入</h4><p>动态代理，赋值给mapper接口引用的对象其实是一个代理对象，这个代理对象是由 JDK 动态代理创建的。在解析mapper的时候，mybatis会通过java反射，获取到接口所有的方法</p><p>当调用接口中方法时，将通过接口全限定名+方法名对应找到映射文件中namespace和id匹配的sql，然后将执行结果返回</p><h4 id="mybatis的mapper接口中的方法名是否可以重载"><a href="#mybatis的mapper接口中的方法名是否可以重载" class="headerlink" title="mybatis的mapper接口中的方法名是否可以重载"></a>mybatis的mapper接口中的方法名是否可以重载</h4><h4 id="mybatis中做新增的时候，怎么返回自增长的id"><a href="#mybatis中做新增的时候，怎么返回自增长的id" class="headerlink" title="mybatis中做新增的时候，怎么返回自增长的id"></a>mybatis中做新增的时候，怎么返回自增长的id</h4><p>在mapper.xml文件中使用useGeneratedKeys和keyProperty属性来获取自增主键的值,判断插入操作是否成功</p><h4 id="在MyBatis如何动态修改SQL"><a href="#在MyBatis如何动态修改SQL" class="headerlink" title="在MyBatis如何动态修改SQL"></a>在MyBatis如何动态修改SQL</h4><p>使用Mybatis的拦截器可以做到</p><p>MyBatis 拦截器可以在 SQL 语句执行前后对 SQL 语句进行动态修改。你可以通过实现 MyBatis 的 Interceptor 接口来创建自定义的拦截器，并在需要的时候在这些拦截器中对 SQL 进行修改。</p><p>在实现 Interceptor 接口时，你需要重写其中的 <code>intercept</code> 方法，这个方法将会在 MyBatis 执行 SQL 语句前后被调用。在 <code>intercept</code> 方法内部，你可以通过参数 <code>Invocation</code> 对象来获得 SQL 语句，并可以对 SQL 语句进行动态修改。</p><p>以下是一个简单的示例，演示了如何在 MyBatis 拦截器中对 SQL 语句进行动态修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCustomInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 获取原始的 SQL 语句</span></span><br><span class="line">        <span class="type">MappedStatement</span> <span class="variable">mappedStatement</span> <span class="operator">=</span> (MappedStatement) invocation.getArgs()[<span class="number">0</span>];</span><br><span class="line">        <span class="type">BoundSql</span> <span class="variable">boundSql</span> <span class="operator">=</span> (BoundSql) mappedStatement.getBoundSql(parameterObject);</span><br><span class="line">        <span class="type">String</span> <span class="variable">originalSql</span> <span class="operator">=</span> boundSql.getSql();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对 SQL 语句进行修改</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">modifiedSql</span> <span class="operator">=</span> originalSql + <span class="string">&quot; LIMIT 10&quot;</span>; <span class="comment">// 添加动态条件</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将修改后的 SQL 语句设置回去</span></span><br><span class="line">        <span class="type">BoundSql</span> <span class="variable">newBoundSql</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BoundSql</span>(mappedStatement.getConfiguration(), modifiedSql, boundSql.getParameterMappings(), boundSql.getParameterObject());</span><br><span class="line">        <span class="type">MappedStatement</span> <span class="variable">newMappedStatement</span> <span class="operator">=</span> MappedStatement.Builder().ad</span><br><span class="line">        <span class="type">StatementHandler</span> <span class="variable">statementHandler</span> <span class="operator">=</span> (StatementHandler) invocation.getTarget();</span><br><span class="line">        <span class="type">MetaObject</span> <span class="variable">metaStatementHandler</span> <span class="operator">=</span> MetaObject.forObject(statementHandler, <span class="keyword">new</span> <span class="title class_">DefaultObjectFactory</span>(), <span class="keyword">new</span> <span class="title class_">DefaultObjectWrapperFactory</span>(), <span class="keyword">new</span> <span class="title class_">DefaultReflectorFactory</span>());</span><br><span class="line">        metaStatementHandler.setValue(<span class="string">&quot;delegate.boundSql&quot;</span>, newBoundSql);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继续执行原始的 SQL 语句</span></span><br><span class="line">        <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">plugin</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Plugin.wrap(target, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties properties)</span> &#123;</span><br><span class="line">        <span class="comment">// 进行一些配置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们创建了一个名为 MyCustomInterceptor 的拦截器，重写了 Interceptor 接口的方法，并在 <code>intercept</code> 方法中对原始的 SQL 语句进行了动态修改。</p><p>你也可以根据自己的需求对 SQL 进行其他修改，例如添加一个动态的 WHERE 子句、改变表名或者列名等。需要注意，对 SQL 进行修改时要保持 SQL 语法的正确性，以避免出现语法错误。</p><p>MyBatis的动态SQL标签有哪些？</p><p>if标签：条件判断</p><p>choose、when、otherwise标签：选择结构，类似java中的switch</p><p>trim标签：对包含的内容加上前缀，后缀</p><p>where标签：主要是用来简化SQL语句中where条件判断的，能智能的处理and or，不必担心多余导致语法错误</p><p>foreach标签：遍历元素</p><h4 id="Mybatis的mapper如何传递多个参数"><a href="#Mybatis的mapper如何传递多个参数" class="headerlink" title="Mybatis的mapper如何传递多个参数"></a>Mybatis的mapper如何传递多个参数</h4><p>方式一，可以使用map进行传参，SQL中使用map的key来引用取值</p><p>方式二，可以在SQL中使用#{param1}，#{param2}…来引用取值，它是根据mapper接口对应方法中形参的顺序进行匹配的，不管接口方法的参数名字叫个啥，SQL都只能使用param1，param2，等来取值</p><p>方式三，可以使用@Param注解，给mapper接口方法的参数命名，在SQL中直接使用取的名字来引用</p><h4 id="Mybatis，关联对象查询，使用嵌套子查询和JOIN连表有什么区别"><a href="#Mybatis，关联对象查询，使用嵌套子查询和JOIN连表有什么区别" class="headerlink" title="Mybatis，关联对象查询，使用嵌套子查询和JOIN连表有什么区别"></a>Mybatis，关联对象查询，使用嵌套子查询和JOIN连表有什么区别</h4><p>嵌套子查询，指的是在查询一个主对象的时候，使用单表查询，在resultmap中额外发送一个子sql查询关联对象，然后映射给主对象</p><p>连表join查询，指的是查询一个主对象的时候，使用join连表的方式把主对象和关联对象的数据一次性查出来，用resultmap映射结果</p><p>他们的区别，join连表查询只发一条sql就能把数据查询出来，嵌套子查询会有一个n+1的问题，就是说如果主查询出来n条数据，那么会额外发送n条子sql去查询对应的关联对象，加上主查询那1次，也就是n+1次，因此它的性能相对较低的，一般我们会使用join连表查询</p><h4><a href="#" class="headerlink"></a></h4><h4 id="分别给出一个嵌套子查询和join连表查询的sql"><a href="#分别给出一个嵌套子查询和join连表查询的sql" class="headerlink" title="分别给出一个嵌套子查询和join连表查询的sql"></a>分别给出一个嵌套子查询和join连表查询的sql</h4><p>当涉及 SQL 查询时，嵌套子查询和 JOIN 连表查询是两种常见的查询方式。以下是一个简单示例：</p><h3 id="嵌套子查询"><a href="#嵌套子查询" class="headerlink" title="嵌套子查询"></a>嵌套子查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> department_id <span class="keyword">FROM</span> departments <span class="keyword">WHERE</span> location <span class="operator">=</span> <span class="string">&#x27;New York&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上面的查询中，嵌套子查询在 <code>departments</code> 表中查找位置为 ‘New York’ 的部门 ID，并将这些部门 ID 用于过滤 <code>employees</code> 表中的记录。</p><h3 id="JOIN-连表查询"><a href="#JOIN-连表查询" class="headerlink" title="JOIN 连表查询"></a>JOIN 连表查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employees.employee_id, employees.first_name, employees.last_name, departments.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments <span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.department_id;</span><br></pre></td></tr></table></figure><p>这个查询使用了 INNER JOIN 连接了 <code>employees</code> 和 <code>departments</code> 表，通过他们之间的共同字段 <code>department_id</code> 来检索员工的信息以及他们所在部门的名称。</p><p>这些示例展示了嵌套子查询和 JOIN 连表查询的基本用法，它们都是 SQL 查询中常用的技术。</p><h4 id="inner-join-和join的区别"><a href="#inner-join-和join的区别" class="headerlink" title="inner join 和join的区别"></a>inner join 和join的区别</h4><p>指代不同:</p><p>​	join:用于根据两个或多个表中的列之间的关系,从这些表中查询数据</p><p>​	inner join:组合两个表中的记录,只要在公共字段之中有相符的值</p><p>特点不同:</p><p>​	join:每个主键的值都是唯一的,这样做的目的是在不重复每个表中的所有数据的情况下,把表间的数据交叉捆绑在一起.</p><p>​	inner join:只要在这两个表的公共字段之中有相符值,内部联接将组合两个表中的记录</p><p>规定不同:</p><p>​	join:如果表中有至少一个匹配,则返回行</p><p>​	inner join:被联接的字段的名称.若不是由数字构成的,则这些字段必须为相同的数据类型并包含同类数据,但无须具有相同的名称.</p><h4 id="为什么要使用连接池"><a href="#为什么要使用连接池" class="headerlink" title="为什么要使用连接池"></a>为什么要使用连接池</h4><p>对数据库的操作都需要取得连接，使用完都需要关闭连接，如果每次操作需要打开关闭连接，这样系统性能很低下。连接池就可以动态的管理这些连接的申请，使用和释放，我们操作数据库只需要在连接池里获取连接，使用完放回连接池，这样大大节省了内存，提高效率。</p><p>数据库连接池的原理主要分为三部分</p><ul><li>第一，连接池的建立，在系统初始化时建立几个连接对象以便使用。</li><li>第二，连接池的管理，客户请求连接数据库时，首先查看连接池中是否有空闲连接，如果有直接分配，如果没有就等待，直到超出最大等待时间，抛出异常</li><li>第三，连接池的关闭，当系统关闭时，连接池中所有连接关闭</li></ul><h3 id="Redis部分"><a href="#Redis部分" class="headerlink" title="Redis部分"></a>Redis部分</h3><h4 id="讲一下你理解的Redis，为什么Redis很快"><a href="#讲一下你理解的Redis，为什么Redis很快" class="headerlink" title="讲一下你理解的Redis，为什么Redis很快"></a>讲一下你理解的Redis，为什么Redis很快</h4><p>Redis是一种高性能的，开源的，C语言编写的非关系型数据库，可以对关系型数据库起到补充作用，同时支持持久化，可以将数据同步保存到磁盘</p><p>说Redis很快是相对于关系型数据库如mysql来说的，主要有以下因素</p><ul><li>第一，数据结构简单，所以速度快</li><li>第二，直接在内存中读写数据，所以速度快</li><li>第三，采用多路IO复用模型，减少网络IO的时间消耗，避免大量的无用操作，所以速度快</li><li>第四，单线程避免了线程切换和上下文切换产生的消耗，所以速度快</li></ul><h4 id="你常用的Redis的数据存储结构有哪些，他们的使用场景分别是什么"><a href="#你常用的Redis的数据存储结构有哪些，他们的使用场景分别是什么" class="headerlink" title="你常用的Redis的数据存储结构有哪些，他们的使用场景分别是什么"></a>你常用的Redis的数据存储结构有哪些，他们的使用场景分别是什么</h4><p>Redis存储形式是键值对，支持value形式包括String，List，Set，ZSet，Hash。</p><p>String可以用作缓存，计数器，防攻击，验证码、登录过期等，List可以用来做队列，秒杀等，Set可以用来去重</p><h4 id="Redis每种存储结构说-4-个命令吧"><a href="#Redis每种存储结构说-4-个命令吧" class="headerlink" title="Redis每种存储结构说 4 个命令吧"></a>Redis每种存储结构说 4 个命令吧</h4><p>1.String</p><ul><li>set key value	设置值</li><li>get key 取值</li><li>mset key value key value…	设置多个值</li><li>mget key key	获取多个值</li><li>incr key	将key中的值自增1</li><li>decre key	将key中的值自减1</li></ul><p>2.List</p><ul><li>lpush key value value…	从最左边设置值</li><li>rpush key value value…	从最右边设置值</li><li>lrange key start stop	查询key中指定区间的元素</li><li>lpop key	移出并返回key中最左边的元素</li><li>rpop key	移出并返回key中最右边的元素</li></ul><p>3.Set</p><ul><li>sadd key value value	添加元素</li><li>smembers key	返回集合key中的所有元素</li><li>srem key member	删除集合key中member元素</li><li>scard key	查询集合key中的元素数量</li></ul><p>4.ZSet</p><ul><li>zadd key score value (score value)…	添加元素</li><li>zcard key	查询集合key中元素数量</li><li>zcount key min max	返回有序集合key中score 在min和max之间的元素</li><li>zrange key start stop	返回有序集合key中索引在start和stop之间的元素</li></ul><p>5.Hash</p><ul><li>hset key field value	添加元素</li><li>hget key field	获取key集合中field键对应的值</li><li>hmset key field value (field value)…	添加元素并批量添加子键值对</li><li>hmget key field field	获取key集合中所有的子键值对</li></ul><h4 id="你们项目是怎么用Redis的"><a href="#你们项目是怎么用Redis的" class="headerlink" title="你们项目是怎么用Redis的"></a>你们项目是怎么用Redis的</h4><p>使用的是Springboot整合的redis，主要用来解决前后端分离后前后端会话问题，以及验证码的问题</p><h4 id="怎么防止Redis宕机数据丢失问题"><a href="#怎么防止Redis宕机数据丢失问题" class="headerlink" title="怎么防止Redis宕机数据丢失问题"></a>怎么防止Redis宕机数据丢失问题</h4><p>通过对Redis持久化，把内存中的数据和命令，保存一份到磁盘中做备份，当Redis发生宕机，重启服务器的时候，会从磁盘重新加载备份的数据，从而解决数据丢失问题</p><h4 id="Redis持久化是什么？有几种方式"><a href="#Redis持久化是什么？有几种方式" class="headerlink" title="Redis持久化是什么？有几种方式"></a>Redis持久化是什么？有几种方式</h4><p>将内存中的数据备份到磁盘的过程，就叫作持久化</p><p>Redis持久化主要有两种方式，RDB(Redis Database)和AOF(Append Only File)，可以通过修改redis.conf进行配置(将 redis.conf 中将 appendonly no，修改为 appendonly yes 来开启AOF 持久化功能)RDB是默认持久化方式,如果服务器开始了 AOF 持久化功能，服务器会优先使用 AOF 文件来还原数据库状态。只有在 AOF 持久化功能处于关闭状态时，服务器才会使用 RDB 文件来还原数据库状态</p><p>RDB是记录数据快照，保存和还原Redis服务器中所有的键值对数据; 而AOF是记录写命令的,保存Redis服务器执行的写命令来记录数据库的状态</p><h4 id="Redis有了AOF持久化为什么还要RDB？"><a href="#Redis有了AOF持久化为什么还要RDB？" class="headerlink" title="Redis有了AOF持久化为什么还要RDB？"></a>Redis有了AOF持久化为什么还要RDB？</h4><p>AOF和RDB各有所长</p><ul><li>RDB是记录数据快照，它的优点是只产生一个持久化文件，体积相对较小，启动恢复速度快，备份方便，它的缺点是没办法做到数据百分百不丢失，因为它是每隔一定时间保存一次</li><li>AOF是记录写命令，它的优点是格式清晰，容易理解，数据更安全，采用append模式即使持久化过程中宕机，也不影响已经保存的数据，它的缺点是文件体积较大，恢复速度慢</li></ul><p>根据实际需要来选择，通常二者可以结合来使用</p><h4 id="Redis内存不够了怎么办？"><a href="#Redis内存不够了怎么办？" class="headerlink" title="Redis内存不够了怎么办？"></a>Redis内存不够了怎么办？</h4><p>方式一：增加物理内存</p><p>方式二：使用淘汰策略，删掉一些老旧数据</p><p>方式三：集群</p><h4 id="你们Redis用在哪些业务上？用的什么存储结构"><a href="#你们Redis用在哪些业务上？用的什么存储结构" class="headerlink" title="你们Redis用在哪些业务上？用的什么存储结构"></a>你们Redis用在哪些业务上？用的什么存储结构</h4><p>主要用做缓存,比如：验证码，分类缓存，数据字典缓存，权限数据缓存，登录信息缓存等。</p><p>String类型的存储结构用的比较多，并且使用了Json格式进行序列化。</p><h4 id="淘汰策略有哪些？你们用的哪种"><a href="#淘汰策略有哪些？你们用的哪种" class="headerlink" title="淘汰策略有哪些？你们用的哪种"></a>淘汰策略有哪些？你们用的哪种</h4><ul><li>volatile-lru ：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</li><li>volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰</li><li>volatile-random：从已设置过期时间的数据集中任意选择数据淘汰</li><li>allkeys-lru：从数据集中挑选最近最少使用的数据淘汰</li><li>allkeys-random：从数据集中任意选择数据淘汰</li><li>no-enviction：不使用淘汰</li></ul><h4 id="Redis事务和Mysql事务的区别"><a href="#Redis事务和Mysql事务的区别" class="headerlink" title="Redis事务和Mysql事务的区别"></a>Redis事务和Mysql事务的区别</h4><p>Mysql的事务是基于日志，记录修改数据前后的状态来实现的，而Redis的事务是基于队列实现的</p><p>Mysql中的事务满足原子性：即一组操作要么同时成功，要么同时失败，</p><p>Redis中的事务不满足原子性，即一组操作中某些命令执行失败了，其他操作不会回滚</p><p>因此对于比较重要的数据，应该存放在mysql中</p><h4 id="使用Redis如何实现消息广播"><a href="#使用Redis如何实现消息广播" class="headerlink" title="使用Redis如何实现消息广播"></a>使用Redis如何实现消息广播</h4><p>Redis是使用发布订阅来实现广播的</p><p>订阅者通过 SUBSCRIBE channel命令订阅某个频道 ， 发布者通过 PUBLISH channel message向该频道发布消息，该频道的所有订阅者都可以收到消息</p><h4 id="为什么要使用Redis做缓存"><a href="#为什么要使用Redis做缓存" class="headerlink" title="为什么要使用Redis做缓存"></a>为什么要使用Redis做缓存</h4><p>一个字，快。</p><p>缓存它指的是将数据库的数据同步到内存中，客户端获取数据直接从内存中获取。由于内存读写速度大于磁盘，而使用缓存能减少磁盘读取，大大提高查询性能。</p><p>我们一般会将经常查询的，不会经常改变的热点数据，保存到缓存中，提高响应速度</p><h4 id="缓存的执行流程"><a href="#缓存的执行流程" class="headerlink" title="缓存的执行流程"></a>缓存的执行流程</h4><p>1.客户端发起查询请求</p><p>2.判断缓存中是否有数据</p><ul><li>如果有，直接返回</li><li>如果没有，就从数据库查询，再把数据同步到缓存</li></ul><p>3.返回数据给客户端</p><h4 id="你们怎么保证Redis和Mysql的一致性"><a href="#你们怎么保证Redis和Mysql的一致性" class="headerlink" title="你们怎么保证Redis和Mysql的一致性"></a>你们怎么保证Redis和Mysql的一致性</h4><p>我们在代码中控制，如果数据库做是写操作，直接把redis中的对应数据删除，下次查询数据会重新写入缓存。</p><p>我们的业务对一致性要求不是很高，因此采用了先操作mysql，后删除redis。在写数据库和删除缓存行代码之间如果有查询请求依然会查询到Redis中的老数据，但是这种情况非常极端，而且我们的业务也能容忍这种短暂的脏数据。</p><p>我还知道其他方案，比如延迟双删 ， 监听Mysql事务日志自动同步Redis等。</p><h4 id="SpringCache常用注解"><a href="#SpringCache常用注解" class="headerlink" title="SpringCache常用注解"></a>SpringCache常用注解</h4><p>@EnableCaching：打在主启动类上，开启缓存功能</p><p>@Cacheable：打在方法上，表示该方法会开启缓存，打在类上，表示类中所有的方法都开启缓存，方法的返回值会自动写入缓存。如果缓存中已经有数据，方法将不会被调用，而是拿着缓存数据直接返回给客户端。</p><p>@CacheEvict：搭载类或者方法上，会将缓存清除</p><p>@CachePut：更新缓存</p><p>@Caching：组合操作，要应用于方法的多个缓存操作</p><p>@CacheConfig：打在类上，共享的一些常见缓存设置</p><h4 id="了解缓存击穿，穿透，雪崩吗？怎么处理？"><a href="#了解缓存击穿，穿透，雪崩吗？怎么处理？" class="headerlink" title="了解缓存击穿，穿透，雪崩吗？怎么处理？"></a>了解缓存击穿，穿透，雪崩吗？怎么处理？</h4><p>缓存击穿：缓存中没有，数据库中有的数据，由于某种原因比如缓存过期了，同时并发用户特别多，一时间都往数据库中读取数据</p><ul><li>解决方案：加互斥锁，只能允许一个线程访问数据库，然后其他线程就可以往内存中拿</li></ul><p>缓存穿透：客户端频繁请求一个缓存和数据库中都没有数据，导致数据库压力大。</p><ul><li>解决方案：布隆过滤器来判断数据库中有没有这个key</li></ul><p>缓存雪崩：缓存重启，或者大量key失效，导致大量并发打到数据库</p><ul><li>解决方案：为key设置不同的过期时间</li></ul><h4 id="Redis的主从有什么优点，和缺点？"><a href="#Redis的主从有什么优点，和缺点？" class="headerlink" title="Redis的主从有什么优点，和缺点？"></a>Redis的主从有什么优点，和缺点？</h4><p>优点是读写分离，分担了读的压力，同时能起到备份作用，防止数据丢失</p><p>缺点是不能分担写的压力，主的单点故障没有解决，存储没有得到扩容</p><h4 id="解释一下Redis的哨兵模式。哨兵的不足？"><a href="#解释一下Redis的哨兵模式。哨兵的不足？" class="headerlink" title="解释一下Redis的哨兵模式。哨兵的不足？"></a>解释一下Redis的哨兵模式。哨兵的不足？</h4><p>当主服务器中断服务后，可以将一个从服务器升级为主服务器 ，以便继续提供服务</p><p>哨兵就是用来监控主从服务器，实现故障恢复功能的。它会不断的检查主服务器和从服务器的健康状态，当某个服务器出现问题时，可以向管理员发起通知。如果主服务器不可用时，会自动选择一个从服务器作为新的主服务器，并让其他的从服务器从新的主服务器复制数据</p><p>哨兵也是主从模式，没有解决写的压力，只减轻了读的压力，而且存储也得不到扩容</p><h4 id="Redis的cluster集群怎么存储数据的？"><a href="#Redis的cluster集群怎么存储数据的？" class="headerlink" title="Redis的cluster集群怎么存储数据的？"></a>Redis的cluster集群怎么存储数据的？</h4><p>Redis Cluster集群采用哈希槽 (hash slot)的方式来分配的。它默认分配了16384个槽位，当我们set一个key 时，会用CRC16算法得到所属的槽位，然后将这个key 分到对应区间的节点上</p><h4 id="什么情况下Redis集群不可用？"><a href="#什么情况下Redis集群不可用？" class="headerlink" title="什么情况下Redis集群不可用？"></a>什么情况下Redis集群不可用？</h4><p>Redis Cluster有一个容错机制，如果半数以上的主节点与故障节点通信都超时了，就会认为该节点故障了，自动触发故障转移操作，故障节点对应的从节点升级为主节点。</p><p>但是如果某个主节点挂了，又没有从节点可以使用，那么整个Redis集群就不可用了、</p><h4 id="Redis存储结构底层有没有了解？什么是SDS"><a href="#Redis存储结构底层有没有了解？什么是SDS" class="headerlink" title="Redis存储结构底层有没有了解？什么是SDS"></a>Redis存储结构底层有没有了解？什么是SDS</h4><p>简单动态字符串，是Redis自己封装的字符串结构。它记录了字节数组buf，字节数组中用到的字节数len，以及未使用的字节数free。</p><ul><li>为了解决二进制安全问题，定义了len来表示已有字符串长度</li><li>为了防止缓冲区溢出，在分配内存的时候做了预留空间free</li><li>内存惰性释放，多余的内存加入free做预留，优化了内存频繁分配</li><li>针对不同的String长度定制了不同的SDS结构</li></ul><h4 id="Redis如何模拟队列和栈，用什么命令"><a href="#Redis如何模拟队列和栈，用什么命令" class="headerlink" title="Redis如何模拟队列和栈，用什么命令"></a>Redis如何模拟队列和栈，用什么命令</h4><p>list控制同一边进，同一边出就是栈；list控制一边进，另一边出就是队列</p><h4 id="Redis存储单个对象怎么存，存储对象集合怎么存"><a href="#Redis存储单个对象怎么存，存储对象集合怎么存" class="headerlink" title="Redis存储单个对象怎么存，存储对象集合怎么存"></a>Redis存储单个对象怎么存，存储对象集合怎么存</h4><p>单个对象可以使用String，也可以使用hash</p><p>集合对象可以使用hash，以便可以快速的通过field来取值</p><h4 id="你们Redis用来做什么？使用的什么结构？"><a href="#你们Redis用来做什么？使用的什么结构？" class="headerlink" title="你们Redis用来做什么？使用的什么结构？"></a>你们Redis用来做什么？使用的什么结构？</h4><p>登录信息login，使用的是String结构存储</p><p>手机验证码code，使用的是String结构</p><p>课程分类course_type ，使用的是String结构</p><p>购物车保存，使用的是Hash结构</p><h4 id="统计全国高考前20名用什么？"><a href="#统计全国高考前20名用什么？" class="headerlink" title="统计全国高考前20名用什么？"></a>统计全国高考前20名用什么？</h4><p>Zrevrangebyscore</p><h4 id="从100个VIP用户中随机抽取5名怎么做？"><a href="#从100个VIP用户中随机抽取5名怎么做？" class="headerlink" title="从100个VIP用户中随机抽取5名怎么做？"></a>从100个VIP用户中随机抽取5名怎么做？</h4><p>Srandmember</p><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><h4 id="RabbitMQ的使用场景"><a href="#RabbitMQ的使用场景" class="headerlink" title="RabbitMQ的使用场景"></a>RabbitMQ的使用场景</h4><p>rabbitMQ消息队列可以用来</p><ul><li>做任务的异步处理，提高程序的相应时间</li><li>提高系统稳定性，通过手动确认机制，当消费者出现故障，只要没有确认签收，请求的数据都不会丢失可以再次处理</li><li>服务解耦，生产者通过MQ与消费者交互</li><li>消除峰值，通过异步处理，消息传到MQ直接返回，接着等待排队处理，避免了线路拥堵</li></ul><h4 id="RabbitMQ如何防止消息丢失"><a href="#RabbitMQ如何防止消息丢失" class="headerlink" title="RabbitMQ如何防止消息丢失"></a>RabbitMQ如何防止消息丢失</h4><p>首先，RabbitMQ的消息确认机制，默认是自动签收，也就是说消息一旦被消费者接收，就自动签收，消息就从队列里清除了。因此对于重要的消息，不容丢失的数据，我们需要设置在消费完成后手动签收</p><p>其次，我们可以将消息持久化，避免消息在消费前MQ宕机，网络问题等造成的消息丢失</p><h4 id="RabbitMQ的交换机有哪几种"><a href="#RabbitMQ的交换机有哪几种" class="headerlink" title="RabbitMQ的交换机有哪几种"></a>RabbitMQ的交换机有哪几种</h4><p>Fanout：广播，将消息交给所有绑定到交换机的队列</p><p>Direct：定向，把消息交给符合指定routing key的队列</p><p>Topic：通配符，把消息交给符合routing pattern的队列</p><h4 id="消息是如何从发送者到达消费者的（RabbitMQ工作流程）"><a href="#消息是如何从发送者到达消费者的（RabbitMQ工作流程）" class="headerlink" title="消息是如何从发送者到达消费者的（RabbitMQ工作流程）"></a>消息是如何从发送者到达消费者的（RabbitMQ工作流程）</h4><p>分为消息发送和消息接收两个步骤</p><ul><li>消息发送：生产者和Broker建立TCP连接，创建信道。通过信道将消息发送给Broker，由Exchange将消息进行转发到指定的队列</li><li>消息接收：消费者和Broker建立TCP连接 ，创建信道 ，然后监听指定的队列，当有消息到达队列时，Broker默认将消息推送给消费者，消费者就能接收到消息</li></ul><h4 id="如何防止消息重复消费"><a href="#如何防止消息重复消费" class="headerlink" title="如何防止消息重复消费"></a>如何防止消息重复消费</h4><p>重复消费，一般时由于消费者消费成功后，在给MQ确认签收的时候出现了网络波动，MQ没有接到确认，就会继续给消费者投递之前的消息，造成消费者接收到了两条一样的消息。</p><p>我们可以通过实现消息的幂等性来避免这种情况，比如说让生产者给每个消息携带一个唯一的id，消费者获取消息后根据这个id去查询数据库，如果不存在就正常消费，如果存在了就证明该消息被消费过，直接丢弃</p><h4 id="RabbitMQ消息投递失败，你们怎么处理"><a href="#RabbitMQ消息投递失败，你们怎么处理" class="headerlink" title="RabbitMQ消息投递失败，你们怎么处理"></a>RabbitMQ消息投递失败，你们怎么处理</h4><p>我们可以设置confirm回调和 returned 回调</p><p>比如说，可以在发送消息的时候，把消息详情包括交换机名，路由键，都保存到一个表中，状态设置为发送中，如果在confirm方法中ack为false,代表发送到交换机失败 ，就把这个记录状态修改为发送失败</p><p>然后我们创建一个定时任务定时扫表，去读取发送失败的数据并重新发送，为了优化性能，我们设置重试次数3次，如果3次都失败了，我们可以采取人工干预</p><p>定时器扫描表的代码示例如下：</p><p>假设您已连接到数据库，并拥有表t_message，可以根据您的要求编写如下的run方法来扫描t_message表中status为1的数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataScanner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">        <span class="type">TimerTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 在这里编写扫描指定表中指定数据的逻辑</span></span><br><span class="line">                <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 连接数据库</span></span><br><span class="line">                    conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/yourDB&quot;</span>, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;password&quot;</span>);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 查询指定表中status为1的数据</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM t_message WHERE status = 1&quot;</span>;</span><br><span class="line">                    <span class="type">PreparedStatement</span> <span class="variable">statement</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">                    <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery();</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 处理结果集</span></span><br><span class="line">                    <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> resultSet.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;message&quot;</span>);</span><br><span class="line">                        <span class="comment">// 对获取的数据进行处理</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;Found data with id: &quot;</span> + id + <span class="string">&quot; and message: &quot;</span> + message);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">                            conn.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义定时任务的执行间隔，这里设置为每5分钟执行一次</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">period</span> <span class="operator">=</span> <span class="number">5</span> * <span class="number">60</span> * <span class="number">1000</span>; <span class="comment">// 5分钟</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动定时任务</span></span><br><span class="line">        timer.scheduleAtFixedRate(task, delay, period);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们假设使用MySQL数据库，并且通过JDBC连接到数据库，然后编写SQL查询语句来查找表t_message中status为1的数据。在<code>run</code>方法中，我们创建了一个数据库连接，执行了SQL查询并处理了结果集。需要注意的是，您需要替换连接数据库的URL、用户名、密码以及SQL语句中的具体内容以匹配您的实际情况。此外，也需要引入相应的数据库驱动程序包。</p><h4 id="RabbitMQ的消息类型"><a href="#RabbitMQ的消息类型" class="headerlink" title="RabbitMQ的消息类型"></a>RabbitMQ的消息类型</h4><p>简单消息队列模型</p><p>work工作队列模型</p><p>发布订阅模型</p><p>路由模式</p><p>通配符模式</p><h3 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h3><h4 id="Lucene创建索引原理"><a href="#Lucene创建索引原理" class="headerlink" title="Lucene创建索引原理"></a>Lucene创建索引原理</h4><p>Lucene是基于倒排索引原理来实现的</p><ul><li>首先，将原文档进行分词处理，形成一个个单独的单词，</li><li>然后取出标点符号以及停词，形成词元，</li><li>再将词元做一些语言相关的处理，比如变成小写，转换时态，单复数形式等等，</li><li>将得到的词创建一个字典，按照字母顺序排序，合并相同的词，最终生成一个倒排索引文档</li></ul><h4 id="ES的keyword和text区别"><a href="#ES的keyword和text区别" class="headerlink" title="ES的keyword和text区别"></a>ES的keyword和text区别</h4><p>keyword：不分词，直接建立索引，支持模糊查询，精确查询，聚合查询</p><p>text：分词后建立索引，支持模糊查询，精确查询，不支持聚合查询</p><p>keyword通常用于通常用于存储年龄，性别，邮编，邮箱号码等等，直接将完整数据保存的场景</p><p>text通常存储全文搜索的数据，例如地址，文章内容的保存</p><h4 id="ES的优势"><a href="#ES的优势" class="headerlink" title="ES的优势"></a>ES的优势</h4><p>ES是基于Lucene的开源搜索引擎，它解决了原生Lucene使用的不足，优化了Lucene的调用方式</p><ul><li>分布式的实时文件存储，每个字段都被索引并可被搜索</li><li>支持实时分析搜索</li><li>可以扩展到上百台服务器，处理PB级结构化或非结构化数据</li><li>通过简单的 RESTful API、可以跟各种语言的客户端甚至命令行进行交互</li><li>上手非常容易，只需很少的学习就可以在生产环境中使用</li></ul><h4 id="Lucene-ES为什么那么快-ES用到什么数据结构"><a href="#Lucene-ES为什么那么快-ES用到什么数据结构" class="headerlink" title="Lucene&#x2F;ES为什么那么快(ES用到什么数据结构)"></a>Lucene&#x2F;ES为什么那么快(ES用到什么数据结构)</h4><p>传统搜索比如mysql的like关键字查询，它的搜索方式就是全文扫表，查询性能很低</p><p>ES是基于Lucene的全文检索引擎，它采用的是倒排索引结构，在存储时先对文档进行分词，再做一些标点符号去除，大小写时态转换等优化处理，最后按照字母顺序去重排序，形成一个倒排索引文档，我们在检索时，就可以通过二分查找的方式找到目标值</p><h4 id="ES的分层结构，index下面是什么"><a href="#ES的分层结构，index下面是什么" class="headerlink" title="ES的分层结构，index下面是什么"></a>ES的分层结构，index下面是什么</h4><p>Index：索引库，包含有一堆相似结构的文档数据，类比Mysql中的数据库</p><p>Type：类型，它是index中的一个逻辑数据分类，类比Mysql中的表</p><p>Document：文档：是ES中的最小数据单元，通常用json结构标识，类比Mysql中的一行数据</p><p>Field：字段：类比Mysql中的一个列</p><p>从ES7.0开始，Type被干掉了，从此库表合一即一个Index中只有一个默认的Type</p><h4 id="讲几个ES中的查询对象：比如TermQuery"><a href="#讲几个ES中的查询对象：比如TermQuery" class="headerlink" title="讲几个ES中的查询对象：比如TermQuery"></a>讲几个ES中的查询对象：比如TermQuery</h4><p>TermQuery：匹配关键字查询（关键词不分词）</p><p>MatchQuery：匹配关键字查询（关键字分词后）</p><p>BooleanQuery：按条件查询</p><p>matchAllQuery：匹配所有文档查询</p><p>rangeQuery：查询指定范围内的数据</p><h4 id="你简单描述一下DSL语法"><a href="#你简单描述一下DSL语法" class="headerlink" title="你简单描述一下DSL语法"></a>你简单描述一下DSL语法</h4><p>DSL是一种以json形式标识的，由ES提供的一种查询语言，它由两部分组成，DSL查询和DSL过滤。</p><p>DSL过滤类似于mysql的精确查询,等值查询,筛选的结果就是符合条件,把结果集进行缓存用于后续的DSL查询</p><p>DSL查询类似于mysql的模糊查询,会进行分词匹配,计算相关度</p><h4 id="你说一下-match和term的区别？"><a href="#你说一下-match和term的区别？" class="headerlink" title="你说一下 match和term的区别？"></a>你说一下 match和term的区别？</h4><p>term：不会对搜索词进行分词处理，而是作为一个整体与目标字段进行匹配，若完全匹配，则可查询到</p><p>match：会将搜索词分词，再与目标查询字段进行匹配，若分词中的任意一个词与目标字段匹配上，则可查询到</p><h4 id="你使用过ES的哪些聚合查询？"><a href="#你使用过ES的哪些聚合查询？" class="headerlink" title="你使用过ES的哪些聚合查询？"></a>你使用过ES的哪些聚合查询？</h4><p>指标聚合，比如求和，求最大值，最小值，平均数</p><p>数量统计聚合，计算满足条件数据的总条数，相当于sql中的count</p><p>去重聚合，它会计算非重复的数据个数，相当于sql中的distinct</p><p>桶聚合，它会将某个field的每个唯一值当成一个桶，并计算每个桶内的文档个数，相当于sql中的group by</p><p>最高权值聚合，它会匹配每组前n条数据，相当于sql中的group by后取出前n条</p><h4 id="ES高亮怎么做的？"><a href="#ES高亮怎么做的？" class="headerlink" title="ES高亮怎么做的？"></a>ES高亮怎么做的？</h4><p>使用HighlightBuilder对关键字作高亮处理，由于我们项目使用的是SpringBoot整合ES的jar包，结果没有进行高亮处理，我们使用ElasticsearchTemplate的queryForPage方法来获取结果，再手动进行分页封装返回前台</p><h4 id="你们ES和数据库的数据一致性怎么做的"><a href="#你们ES和数据库的数据一致性怎么做的" class="headerlink" title="你们ES和数据库的数据一致性怎么做的"></a>你们ES和数据库的数据一致性怎么做的</h4><p>代码控制的，数据库做了写操作，直接更新ES中的数据，我知道可以通过 Logstash 中数据和ES的数据自动同步。</p><h4 id="ES分片机制了解吗"><a href="#ES分片机制了解吗" class="headerlink" title="ES分片机制了解吗"></a>ES分片机制了解吗</h4><p>ES的索引库由多个分片 shard组成，shard分为primary shard主shard和replica shard 副本,主shard承担写请求，replica副本的数据从primary复制而来，同时分担读请求，primary shard的数量设定了就不能修改，replica数量可以修改。</p><h4 id="描述一下ES添加文档的过程"><a href="#描述一下ES添加文档的过程" class="headerlink" title="描述一下ES添加文档的过程"></a>描述一下ES添加文档的过程</h4><p>(1) 客户端请求一个协调节点coordinating node</p><p>(2) 协调节点根据算法选择一个primary shard: 算法 hash(document_id) % (num_of_primary_shards)</p><p>(3) 对应的primary shard 所在节点保存完数据后，将数据同步到replica node。</p><p>(4) 协调节点coordinating node 发现 primary node 和所有 replica node 都搞定之后返回结果给客户端</p><h4 id="数据节点存储数据详细流程："><a href="#数据节点存储数据详细流程：" class="headerlink" title="数据节点存储数据详细流程："></a>数据节点存储数据详细流程：</h4><p>(1) 当分片所在的节点接收到来自协调节点的请求后，会将请求写入到Memory Buffer，然后定时（默认是每隔1秒）写入到Filesystem Cache，这个从Momery Buffer到Filesystem 　　Cache的过程就叫做refresh</p><p>(2) 当然在某些情况下，存在Momery Buffer和Filesystem Cache的数据可能会丢失，ES是通过translog的机制来保证数据的可靠性的。其实现机制是接收到请求后，同时也会写入到translog中，当Filesystem cache中的数据写入到磁盘中时，才会清除掉，这个过程叫做flush；</p><p>(3)在flush过程中，内存中的缓冲将被清除，内容被写入一个新段，段的fsync将创建一个新的提交点，并将内容刷新到磁盘，旧的translog将被删除并开始一个新的translog。<br>flush触发的时机是定时触发（默认30分钟）或者translog变得太大（默认为512M）时；</p><h4 id="详细描述一下Elasticsearch获取文档的过程"><a href="#详细描述一下Elasticsearch获取文档的过程" class="headerlink" title="详细描述一下Elasticsearch获取文档的过程"></a>详细描述一下Elasticsearch获取文档的过程</h4><p>(1) 客户端请求一个协调节点coordinating node</p><p>(2) coordinate node 根据算法hash(document_id) % (num_of_primary_shards)，将请求转发到对应的 node，此时会使用 round-robin随机轮询算法，在 primary shard 以及其所有 replica 中随机选择一个，让读请求负载均衡</p><p>(3) 接收到请求的 node 返回 document 给调节点 coordinate node。</p><p>(4) coordinate node 返回 document 给客户端。</p><p>搜索被执行成一个两阶段过程，我们称之为 Query Then Fetch；</p><h4 id="详细描述一下Elasticsearch搜索过程"><a href="#详细描述一下Elasticsearch搜索过程" class="headerlink" title="详细描述一下Elasticsearch搜索过程"></a>详细描述一下Elasticsearch搜索过程</h4><p>(1) 在初始查询阶段时，查询会广播到索引中每一个分片拷贝（主分片或者副本分片）。</p><p>(2) 每个分片在本地执行搜索并构建一个匹配文档的大小为 from + size 的优先队列。PS：在搜索的时候是会查询Filesystem Cache的，但是有部分数据还在Memory Buffer，所以搜索是近实时的。</p><p>(3) 每个分片返回各自优先队列中所有文档的 ID 和排序值给协调节点，协调节点它合并这些值到自己的优先队列中来产生一个全局排序后的结果列表。</p><p>(4) 接下来就是 取回阶段，协调节点辨别出哪些文档需要被取回并向相关的分片提交多个 GET 请求。每个分片加载并 丰富 文档，如果有需要的话，接着返回文档给协调节点。一旦所有的文档都被取回了，协调节点返回结果给客户端。</p><h4 id="详细描述一下Elasticsearch更新和删除文档的过程"><a href="#详细描述一下Elasticsearch更新和删除文档的过程" class="headerlink" title="详细描述一下Elasticsearch更新和删除文档的过程"></a>详细描述一下Elasticsearch更新和删除文档的过程</h4><p>删除和更新也都是写操作，但是Elasticsearch中的文档是不可变的，因此不能被删除或者改动以展示其变更；　磁盘上的每个段都有一个相应的.del文件。当删除请求发送后，文档并没有真的被删除，而是在.del文件中被标记为删除。该文档依然能匹配查询，但是会在结果中被过滤掉。当段合并时，在.del文件中被标记为删除的文档将不会被写入新段。</p><p>在新的文档被创建时，Elasticsearch会为该文档指定一个版本号，当执行更新时，旧版本的文档在.del文件中被标记为删除，新版本的文档被索引到一个新段。旧版本的文档依然能匹配查询，但是会在结果中被过滤掉。</p><h4 id="ES有几种节点类型？他们的作用分别是什么"><a href="#ES有几种节点类型？他们的作用分别是什么" class="headerlink" title="ES有几种节点类型？他们的作用分别是什么"></a>ES有几种节点类型？他们的作用分别是什么</h4><p>分为主节点，node.master &#x3D;true , 数据节点node.data &#x3D;true , 负载均衡节点(node.data &#x3D;false,node.master&#x3D;false),</p><p>node.master&#x3D;true,代表该节点有成为主资格 ,主节点的主要职责是和集群操作相关的内容，如创建或删除索引，跟踪哪些节点是群集的一部分，并决定哪些分片分配给相关的节点。一般会把主节点和数据节点分开</p><p>node.data&#x3D;true,数据节点主要是存储索引数据的节点，主要对文档进行增删改查操作，聚合操作等,数据节点对CPU,IO,内存要求较高，优化节点的时候需要做状态监控，资源不够时要做节点扩充</p><p>当主节点和数据节点配置都设置为false的时候，该节点只能处理路由请求，处理搜索，分发索引操作等，从本质上来说该客户节点表现为智能负载平衡器。配置：mode.master&#x3D;false,mode.data&#x3D;false</p><h4 id="ES集群的三种颜色代表什么"><a href="#ES集群的三种颜色代表什么" class="headerlink" title="ES集群的三种颜色代表什么"></a>ES集群的三种颜色代表什么</h4><p>绿色，黄色，红色，绿色代表集群健康，所有的主备分片都得到分配，如果有备分片没有node去分配，集群是黄色，黄色和绿色都是可用状态，如果有主分片的节点down机，集群不可写数据，呈现红色，代表集群不健康。</p><h4 id="你们项目怎么使用ES"><a href="#你们项目怎么使用ES" class="headerlink" title="你们项目怎么使用ES"></a>你们项目怎么使用ES</h4><p>我们使用的是spring-boot-start-data-elasticsearch这个库来操作ES，用在大数据的搜索场景，比如商品的发布，搜索功能。</p><hr><h3 id="SpringSeucity"><a href="#SpringSeucity" class="headerlink" title="SpringSeucity"></a>SpringSeucity</h3><h4 id="说一下security中的的filter"><a href="#说一下security中的的filter" class="headerlink" title="说一下security中的的filter"></a>说一下security中的的filter</h4><p>SecurityContextPersistenceFilter：请求开始会从SecurityContextRepository中获取SecurityContext对象并设置给SecurityContextHolder，在请求完处理成后将SecurityContextHolder持有的SecurityContext再保存到配置好的SecurityContextRepository中，同时清除SecurityContextHolder中的SecurityContext</p><p>UsernamePasswordAuthenticationFilter：默认拦截“&#x2F;login”登录请求，将请求中的认证信息包括用户名，密码封装成UsernamePasswordAuthenticationToken，然后调用AuthenticationManager的认证方法进行认证</p><p>BasicAuthenticationFilter：处理 HTTP 请求的 BASIC 授权标头，如果身份验证成功，就把生成的Authentication对象放入SecurityContextHolder。如果设置了记住我，下次访问就不会走这里来了</p><p>RememberAuthenticationFilter：记住我，调用RememberMeServices的autoLogin方法自动登录</p><p>AnonymousAuthenticationFilter：匿名filter，检测SecurityContextHolder有没有Authentication对象，如果没有，就会创建一个AnonymousAuthenticationToken并保存到SecurityContextHolder</p><p>ExceptionTranslationFilter：处理filter链中的所有AccessDeniedException和AuthenticationException</p><p>FilterSecurityInterceptor：继承自AbstractSecurityInterceptor，通过调用AccessDecisionManager.decide方法进行授权</p><h4 id="说一下security的认证原理"><a href="#说一下security的认证原理" class="headerlink" title="说一下security的认证原理"></a>说一下security的认证原理</h4><p>首先，请求会经过UsernamePasswordAuthenticationFilter拦截，请求的用户名密码会封装成UsernamePasswordAuthenticationToken，过滤器将token提交给认证管理器AuthenticationManager进行认证</p><p>然后，认证管理器调用AuthenticationProvider进行认证，AuthenticationProvider再调用UserDetailsService获取到数据库中存储的用户信息UserDetails，然后调用密码编码器对密码进行比较，认证成功后封装Authentication</p><p>再后来，请求回到UsernamePasswordAuthenticationFilter，调用SecurityContextHolder将Authentication对象封装成SecurityContext并保存到SecurityContextHolder中</p><p>最后，请求回到SecurityContextPersistenceFilter，它会调用SecurityContextRepository将SecurityContext对象存储起来，再清理掉SecurityContextHolder中的信息</p><h2 id="三-微服务部分"><a href="#三-微服务部分" class="headerlink" title="三.微服务部分"></a>三.微服务部分</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><h4 id="什么是集群"><a href="#什么是集群" class="headerlink" title="什么是集群"></a>什么是集群</h4><p>集群使将应用复制成多个相同的应用，一起来工作，从而提高工作能力。即将多个应用程序分散在不同的服务器，每个服务器都独立运行相同的代码。可以分散服务器压力解决高并发的问题，同时也能预防单节点故障，即一台服务器故障不影响其他服务器正常运行，但没有解决单体应用代码臃肿，业务复杂，维护性差等等问题</p><h4 id="什么是负载均衡"><a href="#什么是负载均衡" class="headerlink" title="什么是负载均衡"></a>什么是负载均衡</h4><p>使用了集群后，解决高并发同时有一个新的问题，就是客户端的请求如何分配到多台服务。因此需要通过负载均衡器，比如Nginx，使用负载均衡算法比如轮询、权重、随机等等将请求路由到不同的服务器</p><h4 id="什么是分布式"><a href="#什么是分布式" class="headerlink" title="什么是分布式"></a>什么是分布式</h4><p>分布式是将应用按照业务类型拆分成多个子应用，每个子应用部署在不同的服务器上单独运行，子应用之间通过API相互调用。</p><p>可以分散服务器压力解决高并发问题，同时可以解决单体应用代码臃肿、业务复杂、维护性差等等问题，但是不能防止单节点故障，比如一个子应用故障，整个应用就能不完整运行</p><h4 id="集群和分布式的区别，分别解决什么问题"><a href="#集群和分布式的区别，分别解决什么问题" class="headerlink" title="集群和分布式的区别，分别解决什么问题"></a>集群和分布式的区别，分别解决什么问题</h4><p>集群是将一个应用程序复制多份，部署在多台服务器上，每个服务器中的程序都是完整的，可以独立运行</p><p>分布式是将一个应用程序拆分成多个子程序，分别部署在多台服务器上，每个服务器中的程序都是不完整的，所有服务器需要相互通信相互协调才能完成最终的业务</p><p>集群能解决高并发问题，同时能防止单节点故障，即一台服务器宕机不影响其他服务器的正常运行</p><p>分布式也能解决高并发问题，但不能防止单节点故障，即一台服务器宕机了，整体业务就无法完成</p><p>集群无法解决项目本身的代码臃肿、业务复杂等等问题，分布式能降低模块之间的耦合</p><p>实际应用中，我们可以将分布式和集群相结合，比如分布式某个子程序的负载很高，可以单独对这个子程序做集群</p><h4 id="说一下你理解的微服务"><a href="#说一下你理解的微服务" class="headerlink" title="说一下你理解的微服务"></a>说一下你理解的微服务</h4><p>微服务也是一个分布式系统，它将单体应用进行细粒度拆分，形成多个微服务，每个服务独立运行，每个服务也都可以有自己的数据库，服务之间使用HTTP通信，互相协调完成整个系统的业务。</p><p>它的优点是服务之间解耦合，不同的服务可以有不同的编程语言，技术选型多元化，支持敏捷开发</p><p>他的缺点是分布式事务很复杂，部署麻烦，技术成本高，服务间通信对性能也有一定的损耗</p><h4 id="什么是CAP理论-，-哪些技术用到AP，哪些用到CP"><a href="#什么是CAP理论-，-哪些技术用到AP，哪些用到CP" class="headerlink" title="什么是CAP理论 ， 哪些技术用到AP，哪些用到CP"></a>什么是CAP理论 ， 哪些技术用到AP，哪些用到CP</h4><p>CAP理论指的是，在一个分布式系统中，一致性，可用性，分区容错性，三个要素最多只能同时实现两点。</p><p>分区容错性是分布式系统的内在要求，因此我们通常会在一致性和可用性之间做取舍。</p><p>满足CP，也就是满足一致性和容错性，舍弃可用性，如果系统允许有段时间失效就可以考虑。常见的如Redis，Nacos，ZooKeeper</p><p>满足AP，也就是满足可用性和容错性，舍弃一致性，如果系统允许出现短暂时间的不一致可以考虑。常见的如MySQL，Eureka</p><h4 id="什么是强一致性和最终一致性"><a href="#什么是强一致性和最终一致性" class="headerlink" title="什么是强一致性和最终一致性"></a>什么是强一致性和最终一致性</h4><p>强一致性是指数据在多个副本中总是实时同步的，如果能容忍数据在多个副本中在一定的延迟时间内同步，则是弱一致性</p><p>最终一致性则不要求数据什么时候同步，但是最终会同步即可。通常情况下我们在分布式领域选择会牺牲了强一致性，会采用最终一致性</p><h4 id="什么是Base理论"><a href="#什么是Base理论" class="headerlink" title="什么是Base理论"></a>什么是Base理论</h4><p>Base指的是基本可用，软状态，最终一致性。它是对CAP中的AP的扩展，意思是说当出现故障部分服务不可用时，要保证核心功能可用，允许在一段时间内数据不一致，但最终要保证一致性。满足Base理论的事务也叫柔性事务</p><h3 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h3><h4 id="讲一下你们公司微服务解决方案"><a href="#讲一下你们公司微服务解决方案" class="headerlink" title="讲一下你们公司微服务解决方案"></a>讲一下你们公司微服务解决方案</h4><p>我司正在使用的是第一代微服务方案，Springcloud Netflix全家桶。</p><p>它是使用Eureka做服务注册与发现，也就是解决服务之间通信问题，</p><p>使用Ribbon&#x2F;OpenFeign做客户端的负载均衡，也就是解决将请求路由到微服务集群的问题，</p><p>使用Hystrix断路器的熔断、降级来解决单节点故障，</p><p>使用Zuul做服务网关，将它作为整个微服务的大门，来实现登录、权限检查等业务，</p><p>使用Config分布式配置中心，来统一管理配置所有微服务的配置文件，</p><p>使用Bus消息总线给各个微服务广播消息，可以实现各个微服务配置的自动刷新，</p><p>使用Sleuth链路追踪，来实时监控各个微服务建的调用关系，快速定位故障节点</p><h4 id="说一说Spring-Cloud有哪些常用组件"><a href="#说一说Spring-Cloud有哪些常用组件" class="headerlink" title="说一说Spring Cloud有哪些常用组件"></a>说一说Spring Cloud有哪些常用组件</h4><p>Eureka：做服务注册与发现，用来解决服务之间通信问题，</p><p>Ribbon&#x2F;OpenFeign：用做客户端的负载均衡，也就是解决将请求路由到微服务集群的问题，</p><p>Hystrix：断路器，它的熔断、降级策略用来解决单节点故障，</p><p>Zuul：做服务网关，它是整个微服务的大门，可以用来实现登录、权限检查等业务，</p><p>Config：分布式配置中心，用来统一管理配置所有微服务的配置文件，</p><p>Bus：消息总线，用来给各个微服务广播消息，可以实现各个微服务配置的自动刷新，</p><p>Sleuth：链路追踪，用来实时监控各个微服务建的调用关系，快速定位故障节点</p><h4 id="Spring-Cloud的优缺点？"><a href="#Spring-Cloud的优缺点？" class="headerlink" title="Spring Cloud的优缺点？"></a>Spring Cloud的优缺点？</h4><p>微服务相对单体应用来说</p><p>优点</p><ul><li>服务之间无耦合，代码简单方便开发维护，服务之间升级维护互不影响</li><li>轻量级HTTP通信机制，不同的服务可以采用不同的编程语言</li><li>有极强的扩展能力,业务量大的服务可以再次拆分服务，或者也可以集群部署</li><li>支持时下流行的敏捷开发并做了优化</li></ul><p>缺点</p><ul><li>分布式事务繁琐</li><li>部署麻烦，开发人员的学习成本高</li><li>技术成本高，开发人员需要花更多的时间学习相关技术</li><li>微服务间的通信存在对性能的损耗问题</li></ul><h4 id="什么是服务注册"><a href="#什么是服务注册" class="headerlink" title="什么是服务注册"></a>什么是服务注册</h4><p>Eureka是一个服务组测与发现的组件，翻译成人话就是管理所有微服务的通讯录的组件。它包含注册中心，客户端两部分组成。客户端在启动的时候会向注册中心发送一条自我介绍信息，比如端口，ip等等，在注册中心就会保存一张所有微服务的通讯录。这就叫服务注册</p><h4 id="什么是服务发现"><a href="#什么是服务发现" class="headerlink" title="什么是服务发现"></a>什么是服务发现</h4><p>微服务会定期的从客户端拉取一份微服务通讯录，到本地缓存起来，默认是30s一次。当一个微服务向另一个微服务发起调用，直接根据本地的通讯录找到对方的服务名，发送HTTP请求。这个就叫服务发现</p><h4 id="什么是服务续约"><a href="#什么是服务续约" class="headerlink" title="什么是服务续约"></a>什么是服务续约</h4><p>微服务会定时（默认30s）发送心跳请求，告诉注册中心，自己还处于存活状态，那么服务中心就不会将其从清单中删除，否则，当微服务宕机或者网络故障等因素，没有在规定时间（默认90s）内提交心跳请求，注册中心就会将它从通讯录中删除。</p><h4 id="如果服务挂了，注册中心要等到90s后剔除，那么在剔除前的这段时间内，挂掉的服务有可能还是会被调用，怎么处理？"><a href="#如果服务挂了，注册中心要等到90s后剔除，那么在剔除前的这段时间内，挂掉的服务有可能还是会被调用，怎么处理？" class="headerlink" title="如果服务挂了，注册中心要等到90s后剔除，那么在剔除前的这段时间内，挂掉的服务有可能还是会被调用，怎么处理？"></a>如果服务挂了，注册中心要等到90s后剔除，那么在剔除前的这段时间内，挂掉的服务有可能还是会被调用，怎么处理？</h4><p>第一，可以修改注册中心剔除服务时间，同时加快服务续约心跳请求的频率</p><p>第二，可以使用Hystrix的熔断降级机制，当某个服务不可访问，快速失败，并返回托底数据</p><p>第三。重试,提供者集群</p><h4 id="你知道EurekaClient服务发现和服务续约每隔30s做一次请求是用什么技术实现的吗？"><a href="#你知道EurekaClient服务发现和服务续约每隔30s做一次请求是用什么技术实现的吗？" class="headerlink" title="你知道EurekaClient服务发现和服务续约每隔30s做一次请求是用什么技术实现的吗？"></a>你知道EurekaClient服务发现和服务续约每隔30s做一次请求是用什么技术实现的吗？</h4><p>使用了ScheduledThreadPoolExecutor线程池定时任务来实现</p><p>服务发现是先判断是否开启了服务发现功能（默认是开启的），获取定时任务的间隔时间（默认是30s），然后初始化服务发现的定时任务，间隔时间可以在yml中修改</p><p>服务续约是先判断是否开启服务注册功能（默认是开启的），获取定时任务间隔时间（默认是30s），然后初始化心跳请求的定时任务，间隔时间可以在yml中修改</p><h4 id="Ribbon是什么，Ribbon的工作原理讲一下"><a href="#Ribbon是什么，Ribbon的工作原理讲一下" class="headerlink" title="Ribbon是什么，Ribbon的工作原理讲一下"></a>Ribbon是什么，Ribbon的工作原理讲一下</h4><p>Ribbon是一个客户端负载均衡器，它可以按照负载均衡算法，向多个服务发起调用。当一个微服务有多个集群时，就可以使用它做请求负载均衡，通常结合RestTemplate来使用</p><h4 id="说一下-Ribbon的工作原理"><a href="#说一下-Ribbon的工作原理" class="headerlink" title="说一下 Ribbon的工作原理"></a>说一下 Ribbon的工作原理</h4><p>消费者会30&#x2F;次注册中心拉取服务注册清单缓存到本地，当消费者需要调用一组提供者集群服务时，Ribbon会根据提供者服务名，在本地缓存的服务地址清单里找到这一组服务的通讯地址，然后按照负债均衡算法（默认是轮询），选择其中的一个通讯地址，发起http调用服务。</p><p>Ribobn内部通过LoadBalancerInterceptor拦截RestTemplate发起的请求，然后交给RibbonLoadBalancerClient负载均衡客户端做负载均衡，RibbonLoadBalancerClient把选择服务的工作交给ILoadBalancer负载均衡器 ，ILoadBalancer会调用 IRule负载均衡算法类来选择服务。之后RibbonLoadBalancerClient把选择好的服务交给LoadBalancerRequest去发请求。</p><h4 id="Ribbon有哪些负载均衡算法，怎么配置"><a href="#Ribbon有哪些负载均衡算法，怎么配置" class="headerlink" title="Ribbon有哪些负载均衡算法，怎么配置"></a>Ribbon有哪些负载均衡算法，怎么配置</h4><p>RoundRobinRule：简单轮询，ribbon默认规则</p><p>AvailabilityFilteringRule：忽略短路状态和并发过高的服务器</p><p>WeightedResponseTimeRule：根据服务器响应时间作为权重，响应时间越长权重越小</p><p>ZoneAvoidanceRule：根据区域选择</p><p>BestAvailableRule：忽略短路的服务器，选择并发较低的服务器</p><p>RandomRule：随机选择一个可用服务器</p><p>Retry：重试机制的选择逻辑</p><h4 id="OpenFeign和Ribbon的区别"><a href="#OpenFeign和Ribbon的区别" class="headerlink" title="OpenFeign和Ribbon的区别"></a>OpenFeign和Ribbon的区别</h4><p>OpenFeign整合了Ribbon和Hystrix,屏蔽了Ribbon拼接URL，参数的细节，使用声明式编程，让服务调用变得更加简单，OpenFiegn底层也是走的Ribbon的负载均衡策略。推荐使用OpenFeign</p><h4 id="OpengFiegn的工作流程"><a href="#OpengFiegn的工作流程" class="headerlink" title="OpengFiegn的工作流程"></a>OpengFiegn的工作流程</h4><p>首先，当程序启动时，@EnableFeignClient会扫描@FeignClient注解的接口，并交给Spring容器管理。</p><p>当发起请求时，会使用jdk动态代理，并为每个方法都生成相应的RequestTemplate，同时封装http信息，包括url和请求参数等，</p><p>最后把RestTemplate交个HttpClient发送请求，使用ribbon的负载均衡发起调用</p><h4 id="为什么要使用Eureka-为什么要使用Ribbon-为什么要使用config配置中心"><a href="#为什么要使用Eureka-为什么要使用Ribbon-为什么要使用config配置中心" class="headerlink" title="为什么要使用Eureka   为什么要使用Ribbon   为什么要使用config配置中心"></a>为什么要使用Eureka 为什么要使用Ribbon 为什么要使用config配置中心</h4><p>在微服务系统中，各个服务之间是需要进行网络通信的，那么他们相互调用就得知道对方的通信地址。eureka就是专门来做做服务注册与发现，解决服务之间通信问题的</p><p>当一个微服务做了集群，也就是同一个服务名会对应多个地址，那么我们在调用的时候，应该调用哪一个就成了问题，Ribbon是一个负债均衡器，它可以按照负债均衡算法，向多个服务发起调用。当一个微服务有多个集群时，就可以使用它做请求的分发</p><p>在微服务系统中，服务数量很多，而每个服务都有自己的配置文件，管理起来很麻烦。用了配置中心就可以帮我们集中管理配置文件，它支持本地配置文件，也支持将配置文件放到远程仓库如git集中管理</p><h4 id="为什么Feign的客户端接口没有写实现类也可以直接被依赖注入"><a href="#为什么Feign的客户端接口没有写实现类也可以直接被依赖注入" class="headerlink" title="为什么Feign的客户端接口没有写实现类也可以直接被依赖注入"></a>为什么Feign的客户端接口没有写实现类也可以直接被依赖注入</h4><p>自动注入的实例其实是一个jdk动态代理对象，Feign会为每个方法生成相应的requestTemplate，它根据服务名找到对应的服务，根据返回值类型、形参列表匹配相应的接口，然后封装url、请求参数，最后生成request请求，使用Ribbon负载均衡发起调用</p><h4 id="介绍一下Hystrix"><a href="#介绍一下Hystrix" class="headerlink" title="介绍一下Hystrix"></a>介绍一下Hystrix</h4><p>Hystrix意为熔断器，它可以将出现故障的服务，通过熔断、降级等手段隔离开，这样不影响整个系统的主业务。它可以防止由单节点异常导致整个微服务故障，如果遇到故障时，快速失败，熔断的同时可以返回兜底数据达到服务降级的目的</p><h4 id="什么是熔断，什么是降级"><a href="#什么是熔断，什么是降级" class="headerlink" title="什么是熔断，什么是降级"></a>什么是熔断，什么是降级</h4><p>熔断，是对服务链路的一种保护机制，当链路上的某个服务不可访问时，服务就会触发降级返回拖地数据，同时当失败率到达一个阈值，就标记该服务为短路状态，当请求访问时直接熔断。直到检查到该服务能正常访问时，就快速恢复</p><p>降级，是当某个服务不可访问时，我们返回一些事先准备好的数据给客户端，比如说，友情提示服务暂不可用，请骚后重试，这样用户体验就上去了</p><h4 id="什么是资源隔离？"><a href="#什么是资源隔离？" class="headerlink" title="什么是资源隔离？"></a>什么是资源隔离？</h4><p>指的是限制某一个分布式服务的资源使用，可以理解为限流，也就是限制某个服务的请求数量。它包括线程池隔离和信号量隔离</p><p>线程池隔离：是指用一个线程池来存储当前请求，可以通过设置线程池最大线程数和最大排队队列数来限制请求数量</p><p>信号量隔离：是指用一个计数器来记录当前有多少个线程在运行，请求进来计数器就增加1，超过最大信号量，就直接返回</p><h4 id="资源隔离：信号量和线程池的区别"><a href="#资源隔离：信号量和线程池的区别" class="headerlink" title="资源隔离：信号量和线程池的区别"></a>资源隔离：信号量和线程池的区别</h4><p>线程池方式是异步处理，它与调用线程不是同一个线程</p><p>信号量方式是同步处理，与调用线程是同一个线程</p><p>线程池方式由于需要排队，调度，线程切换，因此开销较大，信号量方式无需切换线程，开销较小</p><h4 id="对于CAP理论，Eureka选择的是AP还是CP？它保证了一致性还是可用性？"><a href="#对于CAP理论，Eureka选择的是AP还是CP？它保证了一致性还是可用性？" class="headerlink" title="对于CAP理论，Eureka选择的是AP还是CP？它保证了一致性还是可用性？"></a>对于CAP理论，Eureka选择的是AP还是CP？它保证了一致性还是可用性？</h4><p>CAP理论指的是，一个分布式系统中，一致性，可用性，分区容错性，三个要素只能同时实现两点。Eureka选择的是AP，它是弱一致性的，保证了可用性和分区容错性，放弃了数据一致性。也就是说当多个Eureka之间不可通信时，需要保证服务可用，正常提供服务注册发现功能，但是网络恢复后最终还是会同步的。</p><h4 id="说一下Eureka的自我保护"><a href="#说一下Eureka的自我保护" class="headerlink" title="说一下Eureka的自我保护"></a>说一下Eureka的自我保护</h4><p>为了防止服务被误删除，Eureka不会立即删除过时的服务数据。这种机制可能会导致客户端从注册中心获取到已经下线的服务并发起调用而导致错误，因此在开发阶段我们可以关闭自我保护机制。在生产环境中，我们需要打开自我保护，因为它可以防止因为网络波动，服务没有及时续约而造成的服务误删除问题。</p><h4 id="你们项目是如何做服务降级的？"><a href="#你们项目是如何做服务降级的？" class="headerlink" title="你们项目是如何做服务降级的？"></a>你们项目是如何做服务降级的？</h4><p>比如在秒杀业务中，需要实时从redis中查询库存，通过设置hystrix的最大信号量，以此来防止redis雪崩。当并发过高，请求数超过最大信号量，触发降级，直接向客户端返回兜底数据：”活动太火爆啦，请稍后重试“</p><p>​</p><h4 id="Zuul有哪几类Filter-他们的执行顺序是怎么样的？"><a href="#Zuul有哪几类Filter-他们的执行顺序是怎么样的？" class="headerlink" title="Zuul有哪几类Filter,他们的执行顺序是怎么样的？"></a>Zuul有哪几类Filter,他们的执行顺序是怎么样的？</h4><p>zuul按照执行顺序，分为pre前置过滤，route路由过滤，post后置过滤，error异常后过滤</p><p>正常流程是请求先经过前置过滤器，到达路由过滤器进行路由，路由到各种微服务执行请求，返回结果后经过后置过滤，返回用户</p><p>异常流程，如果再整个过程中出现异常，都会进入error异常过滤器，处理完毕后经过post过滤器返回用户，如果error自己出现异常，最终也会通过post过滤器返回用户，如果post过滤器出现异常，也会跳转到error过滤器，然后直接返回用户</p><h4 id="在Zuul中做登录检查如何实现？"><a href="#在Zuul中做登录检查如何实现？" class="headerlink" title="在Zuul中做登录检查如何实现？"></a>在Zuul中做登录检查如何实现？</h4><p>可以通过继承ZuulFilter抽象类，自定义pre类型的过滤器，shouldFilter方法中可以定义需要放行的资源，run方法中检查请求头中的token信息，如果没有token，就响应到客户端未登录的信息，并组织filter继续往后执行</p><h4 id="在Zuul中如何做限流？"><a href="#在Zuul中如何做限流？" class="headerlink" title="在Zuul中如何做限流？"></a>在Zuul中如何做限流？</h4><p>方式一：可以通过继承ZuulFilter抽象类自定义pre过滤器，加上限流算法，来实现</p><p>方式二：可以通过hystrix的资源隔离模式，设置线程池最大连接数或者最大信号量来实现</p><p>方式三：常用，Ratelimit，使用令牌桶算法。。。</p><h4 id="配置中心解决什么问题？"><a href="#配置中心解决什么问题？" class="headerlink" title="配置中心解决什么问题？"></a>配置中心解决什么问题？</h4><p>在分布式系统中，服务数量很多，而每个服务都有自己的配置文件，管理起来很麻烦。配置中心是个好东西，可以帮我们集中管理配置文件，它支持本地配置文件，也支持将配置文件放到远程仓库如git集中管理。</p><h4 id="EureakServer的搭建流程"><a href="#EureakServer的搭建流程" class="headerlink" title="EureakServer的搭建流程"></a>EureakServer的搭建流程</h4><p>第一步，导入eureka-server依赖，以及springboot的web环境依赖。</p><p>第二布，主启动类上打注解，@EnableEurekaServer，开启eureka服务端功能</p><p>第三步，yml配置文件中，配置注册中心的端口号，主机名，注册中心地址</p><h4 id="Ribbon的整合流程"><a href="#Ribbon的整合流程" class="headerlink" title="Ribbon的整合流程"></a>Ribbon的整合流程</h4><p>第一步，导入ribbon依赖</p><p>第二部，给RestTemplate的Bean定义方法上，加上注解@LoadBalanced，让这个restTemplate有负载均衡的功能</p><p>第三步，修改restTemplate调用服务的url，将目标主机名换成目标服务名</p><h4 id="Feign的整合流程"><a href="#Feign的整合流程" class="headerlink" title="Feign的整合流程"></a>Feign的整合流程</h4><p>第一步，导入openfeign依赖</p><p>第二部，主配置类加注解，@EnableFeignClients，开启feign支持</p><p>第三步，定义feign客户端接口，并加上注释@FeignClient(“目标服务名”)，接口中定义方法，该方法与目标服务的对应方法的方法名，返回值类型，形参列表，url路径要一致</p><h4 id="Hystrix的整合流程"><a href="#Hystrix的整合流程" class="headerlink" title="Hystrix的整合流程"></a>Hystrix的整合流程</h4><ul><li><p>第一步，导入hystrix依赖</p></li><li><p>第二部，主启动类加注解，@EnableCircuitBreaker，开启熔断功能</p></li><li><p>第三步，在需要开启熔断功能的方法上，加注解@HystrixCommand(fallbackMethod&#x3D;”xxx”)，xxx是降级方法</p></li><li><p>第四步，定义降级方法，方法名需要和fallbackMethod的值一致，形参列表和返回值类型需要和目标方法一致</p></li></ul><p>feign整合Hystrix：</p><ul><li><p>第一步，yml中配置，feign.hystrix.enable&#x3D;true，开启hystrix功能</p></li><li><p>第二部，@FeignClient标签中，定义fallback或者fallbackFactory，指定降级类</p></li><li><p>第三步，</p></li></ul><p>如果是fallback，就实现feign接口，并覆写接口中的方法作为降级方法</p><p>如果是fallbackFactory，就实现FallbackFactory接口，同时指定泛型为feign接口，覆写create方法，返回一个feign接口的匿名内部类，类中写降级方法</p><h4 id="Zuul的整合流程"><a href="#Zuul的整合流程" class="headerlink" title="Zuul的整合流程"></a>Zuul的整合流程</h4><p>第一步，导入zuul依赖</p><p>第二步，主启动类上加注解@EnableZuulProxy，开启zuul功能</p><p>第三步，yml中配置，统一访问前缀prefix，禁用通过服务名方式访问服务ignoredServices，配置路由routes指定某个服务使用某个路径来访问</p><h4 id="ConfigServer的整合流程"><a href="#ConfigServer的整合流程" class="headerlink" title="ConfigServer的整合流程"></a>ConfigServer的整合流程</h4><p>配置中心服务端配置：</p><p>​	第一步，导入config-server依赖</p><p>​	第二步，主启动类加注解，@EnableConfigServer，开启配置中心</p><p>​	第三步，配置文件中，配置远程仓库地址，仓库账号密码</p><p>客户端配置：</p><p>​	第一步，导入config-client依赖</p><p>​	第二步，创建bootstrap.yml配置文件，配置中心地址config.uri，要拉取的配置文件名name，环境名profile</p><h4 id="你们微服务项目的技术栈描述一下"><a href="#你们微服务项目的技术栈描述一下" class="headerlink" title="你们微服务项目的技术栈描述一下"></a>你们微服务项目的技术栈描述一下</h4><p>​	前端门户系统：HTML + JQuery + CSS</p><p>​	前端管理系统：VUE + ElementUI</p><p>​	后端系统：基于SpringCloud微服务框架（Eureka+OpenFeign+Hystrix+Zuul+Config）</p><p>+MyBatisPlus+SpringMVC+Redis+ElasticSearch+RabbitMQ+AlicloudOSS</p><h4 id="浏览器发起一个请求，在你的微服务项目中的怎么去执行的？"><a href="#浏览器发起一个请求，在你的微服务项目中的怎么去执行的？" class="headerlink" title="浏览器发起一个请求，在你的微服务项目中的怎么去执行的？"></a>浏览器发起一个请求，在你的微服务项目中的怎么去执行的？</h4><p>浏览器发起的所有请求首先通过Nginx，通过负载均衡算法，路由给zuul集群，然后通过zuul前置过滤，作登录校验后，它会从配置中心拉取的通讯地址中，根据url匹配到对应的服务，然后使用ribbon发起restful调用。微服务间也可以通过feign相互调用，最终执行完任务，返回浏览器</p><h4 id="说下Ribbon和Feign的区别呢"><a href="#说下Ribbon和Feign的区别呢" class="headerlink" title="说下Ribbon和Feign的区别呢"></a>说下Ribbon和Feign的区别呢</h4><p>Ribbon和Feign都是SpringCloud Netflix中实现负载均衡的组件，不同点在于</p><p>Ribbon是需要我们手动构建http请求，根据目标服务名通过负载均衡算法直接调用目标服务，</p><p>Feign是采用接口的方式，将需要调用的目标服务方法定义成抽象方法，路径，服务名，形参列表，返回值类型需要保持一致。我们只需要调用接口中的方法就可以了。它会自动帮我们生成jdk动态代理，为每个方法生成RequestTemplate并封装url和请求参数，使用负载均衡算法发起调用</p><p>Ribbon的实现方式，一般配合RestTemplate发起http请求，我们需要在注册RestTemplate的Bean的方法上加@LoadBalanced，使它具有负载均衡的能力</p><p>Feign的实现方式，是在主启动类上加@EnableFeignClients，在客户端接口上加注解@FeignClient</p><h4 id="Spring-SpringBoot和SpringCloud的关系以及区别"><a href="#Spring-SpringBoot和SpringCloud的关系以及区别" class="headerlink" title="Spring,SpringBoot和SpringCloud的关系以及区别"></a>Spring,SpringBoot和SpringCloud的关系以及区别</h4><p>Spring是一个开源的轻量级控制反转和面向切面编程的容器框架。轻量级是说它开发使用简单，功能强大。控制反转是指将对象的创建，销毁控制交给ioc容器，方便解耦合，降低维护难度，面向切面编程是指将相同的逻辑横向抽取出来，可以对一些通用业务如事务，日志进行集中管理。</p><p>Springboot是一个基于spring的框架，对spring做了大量简化，使开发流程更快，更高效。比如它大量简化maven依赖，基于注解配置（JavaConfig）无需XML，内嵌Tomcat，部署流程简单，打包和部署更加灵活，允许独立运行</p><p>SpringCloud是基于SpringBoot实现的，用于微服务架构中管理和协调服务的，它是一系列框架的有序集合，它为开发者提供了一系列工具，例如服务发现与注册，配置中心，网关，负载均衡，熔断器，链路追踪等等，让微服务架构落地变得更简单</p><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><h4 id="什么是分布式事务，"><a href="#什么是分布式事务，" class="headerlink" title="什么是分布式事务，"></a>什么是分布式事务，</h4><p>分布式事务，指的是在分布式环境中，一个请求可能涉及到对多个数据库的写操作，要保证多数据库的一致性就需要用到分布式事务</p><h4 id="分布式事务你知道哪些解决方案？-这些方案如何选型"><a href="#分布式事务你知道哪些解决方案？-这些方案如何选型" class="headerlink" title="分布式事务你知道哪些解决方案？   这些方案如何选型"></a>分布式事务你知道哪些解决方案？ 这些方案如何选型</h4><p>常见的分布式事务解决方案，2PC，TCC，可靠消息最终一致性，最大努力通知</p><p>2PC，它将整个事务流程分为两个阶段，P指的是准备阶段，C指的是提交阶段。它是一个阻塞协议，不适用于并发较高，事务生命周期长的分布式事务。</p><p>TCC，它是基于补偿性事务的AP系统的一种实现，补偿也就是说先按照预定方案执行，如果失败了就走补偿方案。它可以自己定义数据操作的粒度，但是对应用的侵入性强，可以用在登录送积分，送优惠券等等场景</p><p>可靠消息最终一致性，指的是当事务发起方执行完本地事务后，就发出一条消息通知其他参与方，并且他们一定能接收到消息并处理事务。适合执行周期长，并且实时性要求不高的场景</p><p>最大努力通知，是在不影响主业务的情况下，尽可能的保证数据的一致性，它适用于一些最终一致性敏感度低的业务，比如支付结果通知</p><h4 id="什么是2pc"><a href="#什么是2pc" class="headerlink" title="什么是2pc"></a>什么是2pc</h4><p>2PC，是将整个事务流程分为两个阶段，P指的是准备阶段，C指的是提交阶段。它常见的标准有XA，JTA，Seata</p><p>由DTP模型定义事务管理器TM和资源管理器RM之间通讯的接口规范叫做XA，它规定的交互方式是酱紫的：应用程序AP通过TM提交和回滚事务，TM通过XA接口来通知RM数据库事务的开始，结束，提交，回滚</p><p>2PC能保证分布式事务的原子性，但是也有很多缺陷</p><p>比如，在第一阶段，如果参与者迟迟不回复协调者，就会造成事务的阻塞，性能不好</p><p>比如，在第二阶段，如果事务协调者发出提交事务指令后宕机，一部分参与者收到消息提交了事务，另一部分没有收到消息没有提交事务，这就会导致数据不一致</p><p>再比如，在第二阶段，如果事务协调者发出提交事务指令后宕机，收到指令的参与者也宕机了，我们就不能确定事务的执行结果，究竟有没有提交</p><h4 id="Seata相比传统2PC有什么区别，以及优点？"><a href="#Seata相比传统2PC有什么区别，以及优点？" class="headerlink" title="Seata相比传统2PC有什么区别，以及优点？"></a>Seata相比传统2PC有什么区别，以及优点？</h4><p>Seata是由阿里中间件团队发起的开源项目Fescar更名而来，是一个开源的分布式事务框架，它通过对本地关系数据库的分支事务协调，来驱动完成全局事务</p><p>Seata的主要优点是性能好，不会长时间占用链接资源，对业务零入侵</p><p>与传统的2PC的区别主要两方面</p><p>在架构层次方面，传统的2PC方案的RM本质就是数据库自身，而Seata的RM是以jar包形式作为中间件层部署在应用程序上</p><p>在两阶段提交上方面，传统2PC方案是在第二阶段完成才释放资源，而Seata是在第一阶段就将本地事务提交，提高了效率</p><h4 id="Seata的TC-TM-RM的含义，以及作用？"><a href="#Seata的TC-TM-RM的含义，以及作用？" class="headerlink" title="Seata的TC,TM,RM的含义，以及作用？"></a>Seata的TC,TM,RM的含义，以及作用？</h4><p>TC：事务协调器，它是独立的中间件，需要独立部署运行，它维护全局事务的运行状态，接收TM指令发起全局事务的提交与回滚，负责与RM通信协调各各分支事务的提交或回滚</p><p>TM：事务管理器，TM需要嵌入应用程序中工作，它负责开启一个全局事务，并最终向TC发起全局提交或全局回滚的指令</p><p>RM：控制分支事务，负责分支注册、状态汇报，并接收事务协调器TC的指令，驱动分支事务的提交和回滚</p><h4 id="你知道TCC吗，它有什么样的优缺点？"><a href="#你知道TCC吗，它有什么样的优缺点？" class="headerlink" title="你知道TCC吗，它有什么样的优缺点？"></a>你知道TCC吗，它有什么样的优缺点？</h4><p>TCC是基于补偿型事务的AP系统的一种实现。补偿指的先按照事先预定的方案去执行，如果失败了就走补偿方案</p><p>它的优点是异步执行效率高，它能对分布式事务中的各个资源分别锁定，分别提交与释放</p><p>它的缺点是对应用的侵入性强，改动成本高，实现难度大</p><h4 id="-1"><a href="#-1" class="headerlink"></a></h4><h4 id="解释一下Seata的工作原理"><a href="#解释一下Seata的工作原理" class="headerlink" title="解释一下Seata的工作原理"></a>解释一下Seata的工作原理</h4><p>Seata有三个角色：</p><ul><li>TM任务管理器，负责开启，提交，回滚事务的发起，</li><li>TC事务协调器 ，接收TM的指令通知RM提交或者回滚事务</li><li>RM资源管理器，控制着分支事务的提交和回滚</li></ul><p>假设有服务A需要调用服务B，且两个服务都需要修改各自的数据库,A服务作为程序入口充当TM和RM，B服务控制着分支事务充当RM。</p><ul><li><p>A服务的TM向TC申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的XID</p></li><li><p>A服务的RM向TC注册分支事务，并将其纳入XID对应全局事务的管辖</p></li><li><p>A服务执行分支事务，写undolog日志，向TC上报事务状态</p></li><li><p>当调用B服务时，B服务的RM向TC注册分支事务，该分支事务执行，然后写undolog,向TC上报事务状态</p></li><li><p>服务执行完毕A服务的TM向TC发送commit或者rollback指令</p></li><li><p>TC接收到指令，向参与事务的RM发送指令</p></li><li><p>事务参与者RM受到commit指令，删除undolog日志。 如果是rollback指令就根据undolog回滚</p></li></ul><h4 id="你能简单描述一下你在项目中是如何集成Seata的吗"><a href="#你能简单描述一下你在项目中是如何集成Seata的吗" class="headerlink" title="你能简单描述一下你在项目中是如何集成Seata的吗"></a>你能简单描述一下你在项目中是如何集成Seata的吗</h4><p>事务协调器：安装并启动Seata客户端</p><p>主业务端：</p><ul><li><p>第一步，导入Seata依赖</p></li><li><p>第二步，yml中配置事务组名，同时需要添加配置文件file.conf，registry.conf，需要注意yml中事务组名与file.comf中的事务组名一致</p></li><li><p>第三步，配置DataSource，需要适用Seata对DataSource进行代理</p></li><li><p>第四步，数据库中添加undo log日志表</p></li><li><p>第五步，业务方法上加注解@GlobalTransactional(rollbackFor &#x3D; Exception.class)注解</p></li></ul><p>事务参与者：</p><ul><li>前四步与主业务端相同，第五步不需要了</li></ul><h4 id="没有Seata或者TCC这些事务框架-你可以怎么处理事务"><a href="#没有Seata或者TCC这些事务框架-你可以怎么处理事务" class="headerlink" title="没有Seata或者TCC这些事务框架,你可以怎么处理事务?"></a>没有Seata或者TCC这些事务框架,你可以怎么处理事务?</h4><p>不用框架就要自己实现,如果业务要求强一致性这个不太好做,需要协调多个数据库的同时提交和回滚.如果是业务不要求强一致性,我可以参照TCC思想 ,可以考虑自己实现异步写数据库方案,如果失败可以做补偿.当然这个要根据业务特性来,很多大公司都是自己封装事务框架.</p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><h4 id="你说一下什么是分布式锁"><a href="#你说一下什么是分布式锁" class="headerlink" title="你说一下什么是分布式锁"></a>你说一下什么是分布式锁</h4><p>分布式锁是在分布式&#x2F;集群环境中解决多线程并发造成的一系列数据安全问题.所用到的锁就是分布式锁，这种锁需要被多个应用共享才可以，通常使用Redis和zookeeper来实现。</p><h4 id="分布式锁有哪些解决方案"><a href="#分布式锁有哪些解决方案" class="headerlink" title="分布式锁有哪些解决方案"></a>分布式锁有哪些解决方案</h4><h4 id="常用的三种方案"><a href="#常用的三种方案" class="headerlink" title="常用的三种方案"></a>常用的三种方案</h4><p>基于数据库实现：通常基于主键，或者唯一索引来实现分布式锁,但是性能比较差，一般不建议使用</p><p>基于Redis ：可以使用setnx来加锁 ，但是需要设置锁的自动删除来防止死锁，所以要结合expire使用.为了保证setnx和expire两个命令的原子性，可以使用set命令组合。</p><p>另外释放锁在finallly中调用del删除锁，而删除锁前需要判断该锁是否是当前线程加的锁以免误删除锁，需要通过get获取锁然后进行判断，但是需要保证get判断或和del删除锁的原子性，可以使用LUA脚本实现。</p><p>总之自己封装Redis的分布式锁是很麻烦的，我们可以使用Redissoin来实现分布式锁，Redissoin已经封装好了。</p><p>基于zookeeper ： 使用临时顺序节点实现，线程进来都去创建临时顺序节点,第一个节点的创建线程获取到锁，后面的节点监听自己的上一个节点的删除事件，如果第一个节点被删除，释放锁第二个节点就成为第一个节点，获取到锁。</p><p>在项目中可以使用curator，这个是Apache封装好的基于zookeeper的分布式锁方案。</p><h4 id="Redis如何实现分布式锁，用什么命令"><a href="#Redis如何实现分布式锁，用什么命令" class="headerlink" title="Redis如何实现分布式锁，用什么命令"></a>Redis如何实现分布式锁，用什么命令</h4><p>可以使用setnx来加锁 ，但是需要设置锁的自动删除来防止死锁，所以要结合expire使用.为了保证setnx和expire两个命令的原子性，可以使用set命令组合。</p><h4 id="Redis实现分布式锁可能会出现什么问题，如何解决"><a href="#Redis实现分布式锁可能会出现什么问题，如何解决" class="headerlink" title="Redis实现分布式锁可能会出现什么问题，如何解决"></a>Redis实现分布式锁可能会出现什么问题，如何解决</h4><p>添加锁和设置过期时间可以使用set命令进行组合，达到原子性加锁</p><p>需要用lua解决删除和判断锁的原子性，否则可能会删除掉别人的锁。</p><p>Redis集群环境中，redis节点挂掉可能会导致加锁失败，可以使用Redisson的红锁来解决。</p><h4 id="你项目中怎么使用分布式锁的"><a href="#你项目中怎么使用分布式锁的" class="headerlink" title="你项目中怎么使用分布式锁的"></a>你项目中怎么使用分布式锁的</h4><p>自己封装Redis的分布式锁是很麻烦的，我们可以使用Redissoin来实现分布式锁，Redissoin已经封装好了</p><h4 id="了解Redission的看门狗原理吗？"><a href="#了解Redission的看门狗原理吗？" class="headerlink" title="了解Redission的看门狗原理吗？"></a>了解Redission的看门狗原理吗？</h4><p>Redisson对分布式锁进行了封装，对于锁超时问题，它提供了看门狗进行锁时间的续期，底层使用了定时任务每10s检查一下，如果业务还未执行完成，未释放锁，就进行超时时间续期。</p><h4 id="你在项目中如果使用ZK实现分布式锁的？"><a href="#你在项目中如果使用ZK实现分布式锁的？" class="headerlink" title="你在项目中如果使用ZK实现分布式锁的？"></a>你在项目中如果使用ZK实现分布式锁的？</h4><p>基于zookeeper ： 使用临时顺序节点实现，线程进来都去创建临时顺序节点,第一个节点的创建线程获取到锁，后面的节点监听自己的上一个节点的删除事件，如果第一个节点被删除，释放锁第二个节点就成为第一个节点，获取到锁。</p><p>在项目中可以使用curator，这个是Apache封装好的基于zookeeper的分布式锁方案。</p><h2 id="四-技能提升"><a href="#四-技能提升" class="headerlink" title="四.技能提升"></a>四.技能提升</h2><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h4 id="创建线程是几种方式"><a href="#创建线程是几种方式" class="headerlink" title="创建线程是几种方式"></a>创建线程是几种方式</h4><p>方式一：继承<strong>Thread</strong>类，覆写run方法，创建实例对象，调用该对象的start方法启动线程<br>方式二：创建<strong>Runnable</strong>接口的实现类，类中覆写run方法，再将实例作为此参数传递给Thread类有参构造创建线程对象，调用start方法启动</p><p>方式三：创建<strong>Callable</strong>接口的实现类，类中覆写call方法，创建实例对象，将其作为参数传递给FutureTask类有参构造创建<strong>FutureTask</strong>对象，再将FutureTask对象传递给Thread类的有参构造创建线程对象，调用start方法启动</p><p>方式四: 通过线程池创建线程</p><p>Thread有单继承的局限性，Runnable和Callable三避免了单继承的局限，使用更广泛。Runnable适用于无需返回值的场景，Callable使用于有返回值的场景</p><h4 id="Thread的start和run的区别"><a href="#Thread的start和run的区别" class="headerlink" title="Thread的start和run的区别"></a>Thread的start和run的区别</h4><p>start是开启新线程， 而调用run方法是一个普通方法调用，还是在主线程里执行。没人会直接调用run方法</p><h4 id="sleep-和-wait的区别"><a href="#sleep-和-wait的区别" class="headerlink" title="sleep 和 wait的区别"></a>sleep 和 wait的区别</h4><p>第一，sleep方法是Thread类的静态方法，wait方法是Object类的方法</p><p>第二：sleep方法不会释放对象锁，wait方法会释放对象锁</p><p>第三：sleep方法必须捕获异常，wait方法不需要捕获异常</p><h4 id="线程的几种状态"><a href="#线程的几种状态" class="headerlink" title="线程的几种状态"></a>线程的几种状态</h4><p>新建状态：线程刚创建，还没有调用start方法之前</p><p>就绪状态：也叫临时阻塞状态，当调用了start方法后，具备cpu的执行资格，等待cpu调度器轮询的状态</p><p>运行状态：就绪状态的线程，获得了cpu的时间片，真正运行的状态</p><p>冻结状态：也叫阻塞状态，指的是该线程因某种原因放弃了cpu的执行资格，暂时停止运行的状态，比如调用了wait，sleep方法</p><p>死亡状态：线程执行结束了，比如调用了stop方法</p><h4 id="Synchronized-和-lock的区别"><a href="#Synchronized-和-lock的区别" class="headerlink" title="Synchronized 和 lock的区别"></a>Synchronized 和 lock的区别</h4><p>他们都是用来解决并发编程中的线程安全问题的，不同的是</p><ul><li>synchronized是一个关键字，依靠Jvm内置语言实现，底层是依靠指令码来实现；Lock是一个接口，它基于CAS乐观锁来实现的</li><li>synchronized在线程发生异常时，会自动释放锁，不会发生异常死锁，Lock在异常时不会自动释放锁，我们需要在finally中释放锁</li><li>synchronized是可重入，不可判断，非公平锁，Lock是可重入，可判断的，可手动指定公平锁或者非公平锁</li></ul><h4 id="你知道AQS吗"><a href="#你知道AQS吗" class="headerlink" title="你知道AQS吗"></a>你知道AQS吗</h4><p>AQS：AbstractQuenedSynchronizer抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制，它维护了一个volatile修饰的 int 类型的，state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。</p><p>工作思想是如果被请求的资源空闲，也就是还没有线程获取锁，将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果请求的资源被占用，就将获取不到锁的线程加入队列。</p><h4 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h4><p>悲观锁和乐观锁，指的是看待并发同步问题的角度</p><ul><li><p>悲观锁认为，对同一个数据的并发操作，一定是会被其他线程同时修改的。所以在每次操作数据的时候，都会上锁，这样别人就拿不到这个数据。如果不加锁，并发操作一定会出问题。用阳间的话说，就是总有刁民想害朕</p></li><li><p>乐观锁认为，对同一个数据的并发操作，是不会有其他线程同时修改的。它不会使用加锁的形式来操作数据，而是在提交更新数据的时候，判断一下在操作期间有没有其他线程修改了这个数据</p></li></ul><p>悲观锁一般用于并发小，对数据安全要求高的场景,乐观锁一般用于高并发，多读少写的场景，通常使用版本号控制，或者时间戳来解决.</p><h4 id="你知道什么是CAS嘛"><a href="#你知道什么是CAS嘛" class="headerlink" title="你知道什么是CAS嘛"></a>你知道什么是CAS嘛</h4><p>CAS,compare and swap的缩写，中文翻译成比较并交换。它是乐观锁的一种体现，CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。</p><h4 id="Synchronized-加非静态和静态方法上的区别"><a href="#Synchronized-加非静态和静态方法上的区别" class="headerlink" title="Synchronized 加非静态和静态方法上的区别"></a>Synchronized 加非静态和静态方法上的区别</h4><p>实例方法上的锁，锁住的是这个对象实例，它不会被实例共享，也叫做对象锁</p><p>静态方法上的锁，锁住的是这个类的字节码对象，它会被所有实例共享，也叫做类锁</p><h4 id="Synchronized-this-和-Synchronized-User-class-的区别"><a href="#Synchronized-this-和-Synchronized-User-class-的区别" class="headerlink" title="Synchronized(this) 和  Synchronized (User.class)的区别"></a>Synchronized(this) 和 Synchronized (User.class)的区别</h4><p>Synchronized(this) 中，this代表的是该对象实例，不会被所有实例共享</p><p>Synchronized (User.class)，代表的是对类加锁，会被所有实例共享</p><h4 id="Synchronized-和-volatitle-关键字的区别"><a href="#Synchronized-和-volatitle-关键字的区别" class="headerlink" title="Synchronized 和 volatitle 关键字的区别"></a>Synchronized 和 volatitle 关键字的区别</h4><p>这两个关键字都是用来解决并发编程中的线程安全问题的，不同点主要有以下几点</p><p>第一：volatile的实现原理，是在每次使用变量时都必须重主存中加载，修改变量后都必须立马同步到主存；synchronized的实现原理，则是锁定当前变量，让其他线程处于阻塞状态</p><p>第二：volatile只能修饰变量，synchronized用在修饰方法和同步代码块中</p><p>第三：volatile修饰的变量，不会被编译器进行指令重排序，synchronized不会限制指令重排序</p><p>第四：volatile不会造成线程阻塞，高并发时性能更高，synchronized会造成线程阻塞，高并发效率低</p><p>第五：volatile不能保证操作的原子性，因此它不能保证线程的安全，synchronized能保证操作的原子性，保证线程的安全</p><p><strong>结合下面的回答一起看：</strong></p><blockquote><p>Synchronized 和 Volatile 都是用来保证多线程环境下共享变量的可见性和有序性的关键字，但是它们之间有一些重要的区别。</p><ol><li><p>Synchronized 是一种独占锁，它可以确保同一时间只有一个线程可以访问被 synchronized 修饰的代码块，从而保障了共享数据的同步和互斥访问。而 Volatile 并不具备互斥访问的功能，它只是确保了被修饰的变量在多线程环境下的可见性。</p></li><li><p>Synchronized 可以保证线程进入同步代码块之前先获取锁，并且在退出同步代码块时释放锁，这样可以确保线程间的有序访问。而 Volatile 并不会对访问被修饰变量的线程进行任何控制，它只是通过内存屏障来禁止指令重排序，保证变量的可见性。</p></li><li><p>Synchronized 可以用来保证原子性，即对共享变量的操作在同一时刻只有一个线程进行，从而避免了多线程环境下的并发问题。而 Volatile 并不能保证原子性，只能保证可见性。</p></li></ol><p>总的来说，Synchronized 是在并发编程中常用的同步工具，它既可以保证共享变量的可见性，又可以保证原子性和有序性；而 Volatile 则只能保证被修饰变量的可见性，无法保证原子性和有序性。</p></blockquote><h4 id="synchronized-锁的原理"><a href="#synchronized-锁的原理" class="headerlink" title="synchronized 锁的原理"></a>synchronized 锁的原理</h4><p>synchronized是基于JVM内置锁实现，通过内部对象Monitor(监视器锁)实 现，基于进入与退出Monitor对象实现方法与代码块同步，监视器锁的实现依赖 底层操作系统的Mutex lock（互斥锁）实现，它是一个重量级锁性能较低，涉及到用户态到内核态的切换，会让整个程序性能变得很差。</p><p>因此在JDK1.6及以后的版本中，增加了锁升级的过程，依次为无锁，偏向锁，轻量级锁，重量级锁。而且还增加了锁粗化，锁消除等策略，这就节省了锁操作的开销，提高了性能</p><h4 id="synchronized-锁升级原理"><a href="#synchronized-锁升级原理" class="headerlink" title="synchronized 锁升级原理"></a>synchronized 锁升级原理</h4><p>每个对象都拥有对象头，对象头由Mark World ，指向类的指针，以及数组长度三部分组成，锁升级主要依赖Mark Word中的锁标志位和释放偏向锁标识位。</p><ul><li>偏向锁（无锁）</li></ul><p>大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是在某个线程	获得锁之后（线程的id会记录在对象的Mark Word锁标志位中），消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。(第二次还是这个线程进来就不需要重复加锁，基本无开销)，如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。</p><ul><li>轻量级锁（CAS）：</li></ul><p>轻量级锁是由偏向锁升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁自旋锁）；没有抢到锁的线程将自旋，获取锁的操作。轻量级锁的意图是在没有多线程竞争的情况下，通过CAS操作尝试将MarkWord锁标志位更新为指向LockRecord的指针，减少了使用重量级锁的系统互斥量产生的性能消耗。</p><p>长时间的自旋操作是非常消耗资源的，一个线程持有锁，其他线程就只能在原地空耗CPU，执行不了任何有效的任务，这种现象叫做忙等（busy-waiting）</p><ul><li>重量级锁：</li></ul><p>如果锁竞争情况严重，某个达到最大自旋次数(10次默认)的线程，会将轻量级锁升级为重量级锁，重量级锁则直接将自己挂起，在JDK1.6之前，synchronized直接加重量级锁，很明显现在得到了很好的优化。</p><p>虚拟机使用CAS操作尝试将MarkWord更新为指向LockRecord的指针，如果更新成功表示线程就拥有该对象的锁；如果失败，会检查MarkWord是否指向当前线程的栈帧，如果是，表示当前线程已经拥有这个锁；如果不是，说明这个锁被其他线程抢占，此时膨胀为重量级锁。</p><h4 id="乐观锁的使用场景-数据库-ES"><a href="#乐观锁的使用场景-数据库-ES" class="headerlink" title="乐观锁的使用场景(数据库,ES)"></a>乐观锁的使用场景(数据库,ES)</h4><p>场景一：ES中对version的控制并发写。</p><p>场景二：数据库中使用version版本号控制来防止更新覆盖问题。</p><p>场景三：原子类中的CompareAndSwap操作</p><h4 id="AtomicInterger怎么保证并发安全性的"><a href="#AtomicInterger怎么保证并发安全性的" class="headerlink" title="AtomicInterger怎么保证并发安全性的"></a>AtomicInterger怎么保证并发安全性的</h4><p>通过CAS操作原理来实现的，就可见性和原子性两个方面来说</p><p>它的value值使用了volatile关键字修饰，也就保证了多线程操作时内存的可见性</p><p>Unsafe这个类是一个很神奇的类，而compareAndSwapInt这个方法可以直接操作内存，依靠的是C++来实现的，它调用的是Atomic类的cmpxchg函数。而这个函数的实现是跟操作系统有关的，比如在X86的实现就利用汇编语言的CPU指令lock cmpxchg，它在执行后面的指令时，会锁定一个北桥信号，最终来保证操作的原子性</p><h4 id="什么是重入锁，什么是自旋锁，什么是阻塞"><a href="#什么是重入锁，什么是自旋锁，什么是阻塞" class="headerlink" title="什么是重入锁，什么是自旋锁，什么是阻塞"></a>什么是重入锁，什么是自旋锁，什么是阻塞</h4><p>可重入锁是指允许同一个线程多次获取同一把锁，比如一个递归函数里有加锁操作</p><p>自旋锁不是锁，而是一种状态，当一个线程尝试获取一把锁的时候，如果这个锁已经被占用了，该线程就处于等待状态，并间隔一段时间后再次尝试获取的状态，就叫自旋</p><p>阻塞，指的是当一个线程尝试获取锁失败了，线程就就进行阻塞，这是需要操作系统切换CPU状态的</p><h4 id="你用过JUC中的类吗，说几个"><a href="#你用过JUC中的类吗，说几个" class="headerlink" title="你用过JUC中的类吗，说几个"></a>你用过JUC中的类吗，说几个</h4><p>Lock锁体系 ，ConcurrentHashMap ，Atomic原子类，如：AtomicInteger ；ThreadLoal ; ExecutorService</p><h4 id="ThreadLocal的作用和原理"><a href="#ThreadLocal的作用和原理" class="headerlink" title="ThreadLocal的作用和原理"></a>ThreadLocal的作用和原理</h4><p>ThreadLocal，翻译成中国话，叫做线程本地变量，它是为了解决线程安全问题的，它通过为每个线程提供一个独立的变量副本，来解决并发访问冲突问题 - 简单理解它可以把一个变量绑定到当前线程中，达到线程间数据隔离目的。</p><p>原理：ThredLocal是和当前线程有关系的，每个线程内部都有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，它用来存储每个线程中的变量副本，key就是ThreadLocal变量，value就是变量副本。</p><p>当我们调用get方法是，就会在当前线程里的threadLocals中查找，它会以当前ThreadLocal变量为key获取当前线程的变量副本</p><p>它的使用场景比如在spring security中，我们使用SecurityContextHolder来获取SecurityContext，比如在springMVC中，我们通过RequestContextHolder来获取当前请求，比如在 zuul中，我们通过ContextHolder来获取当前请求</p><h4 id="线程池的作用"><a href="#线程池的作用" class="headerlink" title="线程池的作用"></a>线程池的作用</h4><p>请求并发高的时候，如果没有线程池会出现线程频繁创建和销毁而浪费性能的情况，同时没办法控制请求数量，所以使用了线程池后有如下好处</p><ul><li>主要作用是控制并发数量，线程池的队列可以缓冲请求</li><li>线程池可以实现线程的复用效果</li><li>使用线程池能管理线程的生命周期</li></ul><h4 id="Executors创建四种线程池"><a href="#Executors创建四种线程池" class="headerlink" title="Executors创建四种线程池"></a>Executors创建四种线程池</h4><ul><li><p>CachedThreadPool：可缓存的线程池，它在创建的时候，没有核心线程，线程最大数量是Integer最大值，最大空闲时间是60S</p></li><li><p>FixedThreadPool：固定长度的线程池，它的最大线程数等于核心线程数，此时没有最大空闲时长为0</p></li><li><p>SingleThreadPool：单个线程的线程池，它的核心线程和最大线程数都是1，也就是说所有任务都串行的执行</p></li><li><p>ScheduledThreadPool：可调度的线程池，它的最大线程数是Integer的最大值，默认最长等待时间是10S，它是一个由延迟执行和周期执行的线程池</p></li></ul><h4 id="线程池的执行流程"><a href="#线程池的执行流程" class="headerlink" title="线程池的执行流程"></a>线程池的执行流程</h4><p>corePoolSize，maximumPoolSize，workQueue之间关系。</p><ol><li>当线程池中线程数小于corePoolSize时，新提交任务将创建一个新线程(使用核心)执行任务，即使此时线程池中存在空闲线程。</li><li>当线程池中线程数达到corePoolSize时(核心用完)，新提交任务将被放入workQueue中，等待线程池中任务调度执行 。</li><li>当workQueue已满，且maximumPoolSize &gt; corePoolSize时，新提交任务会创建新线程(非核心)执行任务。</li><li>当workQueue已满，且提交任务数超过maximumPoolSize(线程用完，队列已满)，任务由RejectedExecutionHandler处理。</li><li>当线程池中线程数超过corePoolSize，且超过这部分的空闲时间达到keepAliveTime时，回收这些线程。</li><li>当设置allowCoreThreadTimeOut(true)时，线程池中corePoolSize范围内的线程空闲时间达到keepAliveTime也将回收。</li></ol><p><strong>线程池执行流程 ：</strong> 核心线程 &#x3D;&gt; 等待队列 &#x3D;&gt; 非核心线程 &#x3D;&gt; 拒绝策略</p><h4 id="线程池构造器的7个参数"><a href="#线程池构造器的7个参数" class="headerlink" title="线程池构造器的7个参数"></a>线程池构造器的7个参数</h4><ul><li><p>CorePoolSize：核心线程数，它是不会被销毁的</p></li><li><p>MaximumPoolSize ：最大线程数，核心线程数+非核心线程数的总和</p></li><li><p>KeepAliveTime：非核心线程的最大空闲时间，到了这个空闲时间没被使用，非核心线程销毁</p></li><li><p>Unit：空闲时间单位</p></li><li><p>WorkQueue：是一个BlockingQueue阻塞队列，超过核心线程数的任务会进入队列排队</p></li><li><p>ThreadFactory：它是一个创建新线程的工厂</p></li><li><p>Handler：拒绝策略，任务超过最大线程数+队列排队数 ，多出来的任务该如何处理取决于Handler</p></li></ul><h4 id="线程池拒绝策略有几种"><a href="#线程池拒绝策略有几种" class="headerlink" title="线程池拒绝策略有几种"></a>线程池拒绝策略有几种</h4><p>拒绝策略，当线程池任务超过 最大线程数+队列排队数 ，多出来的任务该如何处理取决于Handler</p><ol><li>AbortPolicy丢弃任务并抛出RejectedExecutionException异常；</li><li>DiscardPolicy丢弃任务，但是不抛出异常；</li><li>DiscardOldestPolicy丢弃队列最前面的任务，然后重新尝试执行任务；</li><li>CallerRunsPolicy由调用线程处理该任务</li></ol><p>可以定义和使用其他种类的RejectedExecutionHandler类来定义拒绝策略。</p><h4 id="你知道ScheduledThreadPool使用场景吗"><a href="#你知道ScheduledThreadPool使用场景吗" class="headerlink" title="你知道ScheduledThreadPool使用场景吗"></a>你知道ScheduledThreadPool使用场景吗</h4><p>这是带定时任务的线程池，EurekaClient拉取注册表&amp;心跳续约就是使用的这个线程池。</p><h3 id="索引部分"><a href="#索引部分" class="headerlink" title="索引部分"></a>索引部分</h3><h4 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h4><p>索引是用来高效获取数据的存储结构如同字典的目录一样，数据库的索引通常使用b+tree来实现，索引树的节点和数据地址相关联，查询的时候在索引树种进行高效搜索，然后根据数据地址获取数据。索引提高了搜索的效率同时增加了索引维护的成本，滥用索引也会降低insert,update,delete的性能。</p><h4 id="mysql数据库的三大范式，五大约束"><a href="#mysql数据库的三大范式，五大约束" class="headerlink" title="mysql数据库的三大范式，五大约束"></a>mysql数据库的三大范式，五大约束</h4><p>MySQL数据库的三大范式是数据库设计中用来规范化数据库结构的原则，有助于减少数据冗余和确保数据一致性。它们包括：</p><p>第一范式（1NF）：确保每一列具有原子性，即每个列都不可再分。换句话说，每个表的每一列都是不可再拆分的最小数据单位。</p><p>第二范式（2NF）：要求在满足第一范式的基础上，非主键列完全依赖于全部主键而非部分主键。简而言之，表中的每个非主键字段都必须完全依赖于全部主键列，而不是部分。</p><p>第三范式（3NF）：要求在满足第二范式的基础上，消除传递依赖，确保任何非主键的列都不能依赖于其他非主键列。</p><p>MySQL数据库中的五大约束包括：</p><ol><li><p>主键约束（Primary Key Constraint）：用于唯一标识每条记录的字段或字段组合。主键字段的值必须唯一且不能为空。</p></li><li><p>外键约束（Foreign Key Constraint）：用于定义不同表之间的关联关系。外键是另一张表的主键，它确保了数据的一致性。</p></li><li><p>唯一约束（Unique Constraint）：确保列或列组合的值是唯一的，但允许NULL值。</p></li><li><p>非空约束（Not Null Constraint）：确保列中的值不为空。</p></li><li><p>检查约束（Check Constraint）：允许管理员在表中DECLARATION或modification期间为可变数据定义规则，通常是为了检查列中的值是否满足特定条件。</p></li></ol><h4 id="Mysql索引有哪些类型"><a href="#Mysql索引有哪些类型" class="headerlink" title="Mysql索引有哪些类型"></a>Mysql索引有哪些类型</h4><p>普通索引：允许重复的值</p><p>唯一索引：不允许有重复的值</p><p>主键索引：数据库自动为我们的主键创建索引，如果我们没有指定主键，它会根据没有null的唯一索引创建主键索引，否则会默认根据一个隐藏的rowId作为主键索引</p><p>全文索引，用来对文本域进行索引，比如text，varchar，只针对MyISAM有效</p><h4 id="索引方式有哪些"><a href="#索引方式有哪些" class="headerlink" title="索引方式有哪些"></a>索引方式有哪些</h4><p>B+树和hash，Myisam和innodb都不支持hash</p><h4 id="Mysql的索引结构原理"><a href="#Mysql的索引结构原理" class="headerlink" title="Mysql的索引结构原理"></a>Mysql的索引结构原理</h4><p>采用了B+树的数据结构,采用B+树的原因，B+树是多叉树，适合存储大量数据，B+树的数据存储在叶子节点，内部节点只存键值，因此B+树每次查询都要走到叶子节点， 查询性能更稳定，同时它的非叶子节点只存储key，因此每个节点能存储更多的key，树的高度变的更低，查询性能更快，而且它的叶子节点能够形成一个链表，支持范围查询，排序 。</p><h4 id="InnoDB的索引结构和MyIsam的索引结构有什么区别"><a href="#InnoDB的索引结构和MyIsam的索引结构有什么区别" class="headerlink" title="InnoDB的索引结构和MyIsam的索引结构有什么区别"></a>InnoDB的索引结构和MyIsam的索引结构有什么区别</h4><p>他们都是用的B+树，不同的是</p><ul><li><p>innodb的叶子节点存放的是数据，myisam的叶子节点存放的是数据的地址</p></li><li><p>innodb中辅助索引的叶子节点存放的是主键索引的键值，myisam中辅助索引的叶子节点存放的也是数据的地址</p></li><li><p>innodb的索引和数据都存放到一个文件中，myisam的索引和数据分别存放到不同的文件中</p></li></ul><h4 id="哪些列不适合创建索引"><a href="#哪些列不适合创建索引" class="headerlink" title="哪些列不适合创建索引"></a>哪些列不适合创建索引</h4><p>不经常查询的列不适合创建索引</p><p>不出现在where中的字段不适合创建索引</p><p>离散度太低的字段不适合创建索引，比如性别</p><p>更新非常频繁的字段不适合创建索引</p><h4 id="哪些因素会造成索引失效"><a href="#哪些因素会造成索引失效" class="headerlink" title="哪些因素会造成索引失效"></a>哪些因素会造成索引失效</h4><p>模糊查询时，通配符放到左边的时候，会导致索引失效	比如 like ‘’%keyword%’’</p><p>列是字符串类型，查询条件没有用引号，会导致索引失效</p><p>使用了or，in，not in，not exist， !&#x3D;等，会导致索引失效</p><p>查询null值，会导致索引失效</p><p>还有mySQL认为全表扫描会比索引查找快，就不会使用索引，比如表里只有一条记录</p><h4 id="什么是辅助索引-什么是覆盖索引"><a href="#什么是辅助索引-什么是覆盖索引" class="headerlink" title="什么是辅助索引&amp;什么是覆盖索引"></a>什么是辅助索引&amp;什么是覆盖索引</h4><p>除了主键索引之外的其他索引都叫辅助索引，也叫二级检索。辅助索引的叶子节点存储的是主键索引的键值，因此辅助索引扫描完之后还会扫描主键索引，这也叫回表</p><p>但是如果查询的列恰好包含在辅助索引的键值中，就不会再回表了，这也叫覆盖索引</p><h4 id="InnoDB辅助索引的叶子节点也存数据吗"><a href="#InnoDB辅助索引的叶子节点也存数据吗" class="headerlink" title="InnoDB辅助索引的叶子节点也存数据吗"></a>InnoDB辅助索引的叶子节点也存数据吗</h4><p>InnoDB辅助索引的叶子节点存放的是，主键索引的键值</p><p>因此辅助索引扫描完还会扫描主键索引，也叫回表</p><p>但是如果查询的列恰好包含在辅助索引的键值中，就不会再回表了，这也叫覆盖索引</p><h4 id="组合索引的匹配原则"><a href="#组合索引的匹配原则" class="headerlink" title="组合索引的匹配原则"></a>组合索引的匹配原则</h4><p>组合索引向左匹配，我们应该优先选择组合索引，因为对覆盖索引命中率更高，查询性能更高，但是应该考虑列的顺序，因为组合索引会向左匹配</p><h4 id="Like一定会让索引失效吗"><a href="#Like一定会让索引失效吗" class="headerlink" title="Like一定会让索引失效吗"></a>Like一定会让索引失效吗</h4><p>不一定，比如：like “值%” 一样可以使用索引，向左匹配，而 like “%值”或 “_值”就不能命中索引。</p><h4 id="索引创建的原则有哪些"><a href="#索引创建的原则有哪些" class="headerlink" title="索引创建的原则有哪些"></a>索引创建的原则有哪些</h4><p>查询较频繁的列应该考虑创建索引</p><p>不经常查询的列不适合创建索引</p><p>不出现在where中的字段不适合创建索引</p><p>离散度太低的字段不适合创建索引，比如性别</p><p>更新非常频繁的字段不适合创建索引</p><h4 id="什么是mysql存储过程、触发器？"><a href="#什么是mysql存储过程、触发器？" class="headerlink" title="什么是mysql存储过程、触发器？"></a>什么是mysql存储过程、触发器？</h4><p>MySQL的存储过程（Stored Procedure）是一段预先定义好的SQL代码集合，它们可以被多次调用和执行。存储过程通常用于封装一系列的SQL语句，实现特定的业务逻辑和功能。存储过程可以接收输入参数，执行一系列的SQL语句，然后返回结果。存储过程可以被调用和执行，而不需要重复编写相同的SQL代码，从而提高了应用程序的性能和可维护性。</p><p>MySQL的触发器（Trigger）是与数据库表相关联的特殊类型的存储过程。触发器是在特定的数据库操作（如插入、更新、删除等）发生时自动执行的代码。可以在表级别上定义触发器，以便在特定的操作发生时执行相应的逻辑。触发器常用于实现数据的验证、约束、日志记录、审计等功能。通过触发器，可以将这些逻辑处理过程封装到数据库中，实现了数据库的自动化业务逻辑。</p><p>总结：</p><ul><li>存储过程是一段预先定义好的SQL代码集合，用于封装业务逻辑和功能，可以被多次调用和执行。</li><li>触发器是与数据库表相关联的特殊类型的存储过程，它是在特定的数据库操作发生时自动执行的代码，用于实现数据验证、约束、日志记录等功能。</li></ul><h3 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h3><h4 id="哪些因素可能会造成数据库性能问题"><a href="#哪些因素可能会造成数据库性能问题" class="headerlink" title="哪些因素可能会造成数据库性能问题"></a>哪些因素可能会造成数据库性能问题</h4><p>不合理的商业需求，比如实时更新总注册人数，总交易额等等，应该考虑不要实时</p><p>对于热点数据的查询并发太高，应该考虑用缓存</p><p>数据库结构设计不合理，比如几十个字段集中在一张表，应该考虑分表</p><p>SQL语句有问题，比如太多JOIN，很多不需要的字段也要全部查询出来，应该考虑优化SQL</p><p>硬件和网络方面的影响</p><h4 id="Mysql的执行流程是怎么样的"><a href="#Mysql的执行流程是怎么样的" class="headerlink" title="Mysql的执行流程是怎么样的"></a>Mysql的执行流程是怎么样的</h4><p>客户端发起SQL查询，首先通过连接器，它会检查用户的身份，包括校验账户密码，权限</p><p>然后会查询缓存，如果缓存命中直接返回，如果没有命中再执行后续操作，但是MySQL8.0之后已经删除了缓存功能</p><p>接下来到达分析器，主要检查语法词法，比如SQL有没有写错，总共有多少关键字，要查询哪些东西</p><p>然后到达优化器，他会以自己的方式优化我们的SQL</p><p>最后到达执行器，调用存储引擎执行SQL并返回结果</p><h4 id="优化SQL你从哪些方面着手"><a href="#优化SQL你从哪些方面着手" class="headerlink" title="优化SQL你从哪些方面着手"></a>优化SQL你从哪些方面着手</h4><p>不需要的字段就不要查询出来</p><p>小结果集驱动大结果集，将能过率更多数据的条件写到前面</p><p>in和not in尽量不要用，会导致索引失效</p><p>避免在where中使用or链接条件，这会导致索引失效</p><p>给经常要查询的字段建立索引</p><p>考虑如果不需要事务，并且主要查询的化，可以考虑使用MyISAM存储引擎</p><p>如果表数据量实在太庞大了，考虑分表</p><h4 id="如何去定位慢SQL"><a href="#如何去定位慢SQL" class="headerlink" title="如何去定位慢SQL"></a>如何去定位慢SQL</h4><p>通过druid连接池的内置监控来定位慢SQL</p><p>通过MySQL的慢查询日志查看慢SQL</p><p>通过show processlist，查看当前数据库SQL执行情况来定位慢SQL</p><h4 id="页面上发起的一个查询很慢，你怎么去优化"><a href="#页面上发起的一个查询很慢，你怎么去优化" class="headerlink" title="页面上发起的一个查询很慢，你怎么去优化"></a>页面上发起的一个查询很慢，你怎么去优化</h4><p>首先看一下硬件和网络层面，有没有什么异常</p><p>然后分析代码有没有什么问题，算法有没有什么缺陷，比如多层嵌套循环</p><p>最后我们再定位到慢SQL，比如</p><ul><li>通过druid连接池的内置监控来定位慢SQL</li><li>通过MySQL的慢查询日志查看慢SQL</li><li>通过show processlist，查看当前数据库SQL执行情况来定位慢SQL</li></ul><p>定位到慢SQL再考虑优化该SQL，比如说</p><ul><li>不需要的字段就不要查询出来</li><li>小结果集驱动大结果集，将能过率更多数据的条件写到前面</li><li>in和not in尽量不要用，会导致索引失效</li><li>避免在where中使用or链接条件，这会导致索引失效</li><li>考虑如果不需要事务，并且主要查询的化，可以考虑使用MyISAM存储引擎</li></ul><p>如果优化SQL后还是很慢，可以考虑给查询字段建索引来提升效率</p><p>如果建立索引了还是慢，看一下是不是数据量太庞大了，应该考虑分表了</p><h4 id="你如何看SQL有没有命中索引"><a href="#你如何看SQL有没有命中索引" class="headerlink" title="你如何看SQL有没有命中索引"></a>你如何看SQL有没有命中索引</h4><p>在SQL语句前加上explain，结果中的key就是实际用到的索引</p><h4 id="mysql存储引擎有哪些，有什么区别，如何选择"><a href="#mysql存储引擎有哪些，有什么区别，如何选择" class="headerlink" title="mysql存储引擎有哪些，有什么区别，如何选择"></a>mysql存储引擎有哪些，有什么区别，如何选择</h4><p>主要有innodb，memory，myisam</p><p>innodb支持事务，速度相对较慢，支持外键，不支持全文索引（InnoDB 存储引擎从 MySQL 5.6.4 版本开始支持全文索引）</p><p>myisam 速度相对较快，支持全文索引，不支持外键，不支持事务，</p><p>memory不支持事务，基于内存读写，速度快，支持全文索引</p><p>如果对事务要求不高，而且是查询为主，考虑用myisam</p><p>如果对事务要求高，保存的都是重要的数据，建议使用innodb，它也是默认的存储引擎</p><p>如果数据频繁变化的，不需要持久化，可以使用memory</p><h4 id="什么是全文索引？"><a href="#什么是全文索引？" class="headerlink" title="什么是全文索引？"></a>什么是全文索引？</h4><p>全文索引是一种用于文本数据的索引类型，它可以快速高效地查询文本中的关键词和短语。传统的索引通常用于查询结构化数据，如数字或字符串等，但对于包含大量文本内容的字段，传统索引往往无法提供高效的搜索功能。全文索引的出现就是为了解决这个问题。</p><p>全文索引可以通过对文本数据进行分词处理，将每个单词或短语建立索引，使得在进行搜索时可以快速定位文档。它还可以支持一些特殊的搜索功能，如模糊搜索、词干提取、搜索算法等。</p><p>全文索引的创建过程受到自然语言处理和信息检索领域的技术影响，使得它能够更好地处理用户的搜索需求。在数据库系统中，全文索引通常用于实现全文搜索功能，如在文档库、新闻文章、博客内容等包含大量文本的应用中进行关键词搜索。</p><h4 id="下面SQL如何优化"><a href="#下面SQL如何优化" class="headerlink" title="下面SQL如何优化"></a>下面SQL如何优化</h4><p>一个sql ： select sum(amount) from recharge ,来查询总充值，recharge 表数据量达到了上千万，怎么优化</p><p>可以考虑建个汇总表来统计总充值，总订单数，总人数等等等</p><p>或者采用日报表，月报表，年报表，使用定时任务进行结算的方式来统计</p><p>或者看数据能不能使用ES搜索引擎来优化，如果非得要在这个上千万的表中来查询，那就采用分表</p><h4 id="事务相关"><a href="#事务相关" class="headerlink" title="事务相关"></a>事务相关</h4><h4 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h4><p>一组对数据库的操作，把这一组看成一个再给你，要么全部成功，要么全部失败。</p><p>举个栗子，比如A向B转账，A账户的钱少了，B账户的钱就应该对应增加，这就转账成功了，如果A账户的钱少了，由于网络波动等因素转账失败了，B账户的钱没有增加，那么A账户就应该恢复成原先的状态</p><h4 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h4><p>原子性：指的是一个事务应该是一个最小的无法分割的单元，不允许部分成功部分失败，只能同时成功，或者同时失败</p><p>持久性：一旦提交事务，那么数据就应该持久化，保证数据不会丢失</p><p>隔离性：两个事务修改同一个数据，必须按顺序执行，并且前一个事务如果未完成，那么中间状态对另一个事务不可见</p><p>一致性：要求任何写到数据库的数据都必须满足预先定义的规则，它基于其他三个特性实现的</p><h4 id="事务的传播机制"><a href="#事务的传播机制" class="headerlink" title="事务的传播机制:"></a>事务的传播机制:</h4><p>​ REQUIRED:支持使用当前事务,事务不存在,创建一个新的事务</p><p>​ SUPPORTS:支持使用当前事务,如果事务不存在,则不使用事务</p><p>​ MANDATORY:强制,支持使用当前事务,如果事务不存在,则抛出Exception</p><p>​ REQUIRES_NEW:创建一个新事务,如果当前事务存在,将当前事务挂起</p><p>​ NOT_SUPPORTED:无事务执行,如果当前事务存在,将当前事务挂起</p><p>​ NEVER:无事务执行,如果当前有事务则抛出Exception</p><p>NESTED:嵌套事务,如果当前事务存在,那么在嵌套的事务中执行,如果当前事务不存在,则表现跟REQUIRED一样</p><h4 id="InnoDB如何保证原子性和持久性的"><a href="#InnoDB如何保证原子性和持久性的" class="headerlink" title="InnoDB如何保证原子性和持久性的"></a>InnoDB如何保证原子性和持久性的</h4><p>通过undo log 保证事务的原子性，redo log保证事务的持久性</p><p>undo log是回滚日志，记录的是回滚需要的信息，redo log记录的是新数据的备份</p><p>当事务开始时，会先保存一个undo log，再执行修改，并保存一个redo log，最后再提交事务。如果系统崩溃数据保存失败了，可以根据redo log中的内容，从新恢复到最新状态，如果事务需要回滚，就根据undo log 回滚到之前的状态</p><h4 id="事务并发问题有哪些"><a href="#事务并发问题有哪些" class="headerlink" title="事务并发问题有哪些"></a>事务并发问题有哪些</h4><p>脏读：事务A读到了事务B修改还未提交的数据</p><p>幻读，也叫虚读：事务A两次读取相同条件的数据，两次查询到的数据条数不一致，是由于事务B再这两次查询中插入或删除了数据造成的</p><p>不可重复读：事务A两次读取相同条件的数据，结果读取出不同的结果，是由于事务B再这两次查询中修改了数据造成的</p><p>第一类丢失更新：也叫回滚丢失，事务A和事务B更新同一条数据，事务B先完成了修改，此时事务A异常终止，回滚后造成事务B的更新也丢失了</p><p>第二类丢失更新：也叫覆盖丢失，事务A和事务B更新同一条数据，事务B先完成了修改，事务A再次修改并提交，把事务B提交的数据给覆盖了</p><h4 id="事务隔离级别有哪些，分别能解决什么问题"><a href="#事务隔离级别有哪些，分别能解决什么问题" class="headerlink" title="事务隔离级别有哪些，分别能解决什么问题"></a>事务隔离级别有哪些，分别能解决什么问题</h4><p>读未提交：事务读不阻塞其他事务的读和写，事务写阻塞其他事务的写但不阻塞读，能解决第一类丢失更新的问题，</p><p>读已提交：事务读不会阻塞其他事务读和写，事务写会阻塞其他事务的读和写，能解决第一类丢失更新，脏读的问题</p><p>可重复读：事务读会阻塞其他事务的写但不阻塞读，事务写会阻塞其他事务读和写，能解决第一类丢失更新，脏读，不可重复读，第二类丢失更新问题</p><p>串行化：使用表级锁，让事务一个一个的按顺序执行，能解决以上所有并发安全问题</p><h4 id="MySql的InnoDB是如何保证原子性的"><a href="#MySql的InnoDB是如何保证原子性的" class="headerlink" title="MySql的InnoDB是如何保证原子性的"></a>MySql的InnoDB是如何保证原子性的</h4><p>利用了undo log实现的</p><p>undo log记录了这些回滚需要的信息，当事务执行失败或调用了rollback，导致事务需要回滚，就可以利用undo log中的信息将数据回滚到修改之前的样子</p><h4 id="MySql的InnoDB是如何保证持久性的"><a href="#MySql的InnoDB是如何保证持久性的" class="headerlink" title="MySql的InnoDB是如何保证持久性的"></a>MySql的InnoDB是如何保证持久性的</h4><p>利用了redo log实现的</p><p>redo log记录的是新数据的备份，在事务提交前，需要将Redo Log持久化，当系统崩溃时，可以根据redo Log的内容，将所有数据恢复到最新的状态</p><h4 id="说一下事务的执行流程-Undolog-Redolog"><a href="#说一下事务的执行流程-Undolog-Redolog" class="headerlink" title="说一下事务的执行流程(Undolog+Redolog)"></a>说一下事务的执行流程(Undolog+Redolog)</h4><p>假设有A&#x3D;1，B&#x3D;2，两个数据，现在有个事务把A修改为3，B修改为4，那么事务的执行流程：</p><p>当事务开始时，会首先记录A&#x3D;1到undo log，记录A&#x3D;3到redo log，和记录B&#x3D;2到undo log，记录B&#x3D;4到redo log，然后再将redo log写入磁盘，最终事务提交</p><h4 id="解释一下事务并发丢失更新问题，·如何解决"><a href="#解释一下事务并发丢失更新问题，·如何解决" class="headerlink" title="解释一下事务并发丢失更新问题，·如何解决"></a>解释一下事务并发丢失更新问题，·如何解决</h4><p>第一类丢失更新：也叫回滚丢失，事务A和事务B更新同一条数据，事务B先完成了修改，此时事务A异常终止，回滚后造成事务B的更新也丢失了</p><p>第二类丢失更新：也叫覆盖丢失，事务A和事务B更新同一条数据，事务B先完成了修改，事务A再次修改并提交，把事务B提交的数据给覆盖了</p><p>SQL标准中的四种隔离级别，读未提交，读已提交，可重复读，串行化，都能解决第一类数据更新丢失问题</p><p>对于第二类丢失更新问题，可以使用悲观锁也就是串行化来解决，也可以使用乐观锁的方式，比如加一个版本号管理来解决</p><h4 id="InnoDB事务隔离的实现原理是什么"><a href="#InnoDB事务隔离的实现原理是什么" class="headerlink" title="InnoDB事务隔离的实现原理是什么"></a>InnoDB事务隔离的实现原理是什么</h4><p>隔离的实现主要利用了读写锁和MVCC机制</p><p>读写锁，要求在每次读操作时需要获取一个共享锁，写操作时需要获取一个写锁。共享锁之间不会产生互斥，共享锁和写锁，写锁与写锁之间会产生互斥。当产生锁竞争时，需要等一个操作的锁释放，另一个操作才能获得锁</p><p>MVCC，多版本并发控制，它是在读取数据时通过一种类似快照的方式将数据保存下来，不同的事务看到的快照版本是不一样的，即使其他事务修改了数据，但是对本事务仍然是不可见的，它只会看到第一次查询到的数据</p><p>可重复读是只在事务开始的时候生成一个当前事务全局性的快照，而读提交则是每次执行语句的时候都重新生成一次快照</p><h3 id="数据库集群"><a href="#数据库集群" class="headerlink" title="数据库集群"></a>数据库集群</h3><h4 id="Mysql主从解决什么问题，不能解决什么问题？"><a href="#Mysql主从解决什么问题，不能解决什么问题？" class="headerlink" title="Mysql主从解决什么问题，不能解决什么问题？"></a>Mysql主从解决什么问题，不能解决什么问题？</h4><p>MySQL主从同步，主负责写，从负责读，使用一主多从，能减轻读的压力</p><p>但是这不能解决写的压力和主库的单点故障，如果主库的写并发高，可以做成多个主库</p><h4 id="MySql主从复制原理？"><a href="#MySql主从复制原理？" class="headerlink" title="MySql主从复制原理？"></a>MySql主从复制原理？</h4><p>主要依靠binlog来实现的，它记录的是所有的DDL，DML，TCL操作</p><p>当主库的数据发生改变时，会将改变记录保存到binlog中</p><p>主库新开一个线程将binlog内容发送到从库</p><p>从库会发起一个I&#x2F;O线程请求主库的binlog，并保存到中继日志中</p><p>从库新开一个SQL线程，读取中继日志并解析成具体操作，从而将主库更新的内容写到了从库中</p><h4 id="MySql主从配置步骤？"><a href="#MySql主从配置步骤？" class="headerlink" title="MySql主从配置步骤？"></a>MySql主从配置步骤？</h4><p>安装mySQL主从客户端，并配置my.ini</p><p>主库需要配置授权从库使用的账号和权限，启动后可以通过show 主库名 status查看状态，我们需要记录File和Position的值，File是对应的binlog文件名，position是当前同步数据的最新行</p><p>从库需要配置主库链接信息，包括账号密码和binlog文件名和最新行，然后启动。通过show 从库名 status 检查同步状态，Slave_IO_Running 和 Slave_SQL_Running 的值都为YES，说明大功告成了</p><p><strong>详细如下：</strong></p><p>MySQL主从配置的步骤如下：</p><ol><li>在主库上开启二进制日志功能：在主库的配置文件（如my.cnf）中添加以下配置：</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">log-bin</span><span class="operator">=</span>mysql-bin</span><br></pre></td></tr></table></figure><p>这将启用二进制日志，且默认的日志文件名为mysql-bin。</p><ol start="2"><li><p>重启主库：重启主库使配置生效。</p></li><li><p>创建主从复制账号：在主库上创建一个用于主从复制的账号，并赋予适当的权限。例如，创建一个账号名为replication的用户：</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;replication&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> REPLICATION SLAVE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;replication&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这里的’password’是账号的密码，%表示允许从任何主机连接。</p><ol start="4"><li>查看主库状态：在主库上执行以下命令，查看主库的状态信息：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> MASTER STATUS;</span><br></pre></td></tr></table></figure><p>记录下File和Position的值，它们将用于配置从库。</p><ol start="5"><li>在从库上配置主从复制：在从库的配置文件中添加以下配置：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server<span class="operator">-</span>id<span class="operator">=</span><span class="number">2</span></span><br></pre></td></tr></table></figure><p>这里的2可以是任意的唯一标识符，用于区分不同的服务器。</p><ol start="6"><li><p>重启从库：重启从库使配置生效。</p></li><li><p>连接从库到主库：在从库上执行以下命令，连接从库到主库：</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER <span class="keyword">TO</span> MASTER_HOST<span class="operator">=</span><span class="string">&#x27;主库IP地址&#x27;</span>, MASTER_USER<span class="operator">=</span><span class="string">&#x27;replication&#x27;</span>, MASTER_PASSWORD<span class="operator">=</span><span class="string">&#x27;password&#x27;</span>, MASTER_LOG_FILE<span class="operator">=</span><span class="string">&#x27;主库的File值&#x27;</span>, MASTER_LOG_POS<span class="operator">=</span>主库的Position值;</span><br></pre></td></tr></table></figure><p>这里的’主库IP地址’是主库的IP地址，’password’是主从复制账号的密码，主库的File和Position值是第4步中记录的值。</p><ol start="8"><li>启动从库复制：在从库上执行以下命令，启动从库的复制：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> SLAVE;</span><br></pre></td></tr></table></figure><ol start="9"><li>检查从库状态：在从库上执行以下命令，检查从库的复制状态：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> SLAVE STATUS\G</span><br></pre></td></tr></table></figure><p>确保Slave_IO_Running和Slave_SQL_Running的值都为”YES”，表示复制正常运行。</p><p>完成以上步骤后，主从复制就配置完成了。从库会从主库获取binlog并进行数据同步。如果主库上的数据发生变化，从库会自动同步这些变化，实现数据的备份和负载均衡。</p><h4 id="什么是垂直分表，垂直分库，水平分表，水平分库"><a href="#什么是垂直分表，垂直分库，水平分表，水平分库" class="headerlink" title="什么是垂直分表，垂直分库，水平分表，水平分库"></a>什么是垂直分表，垂直分库，水平分表，水平分库</h4><p>垂直分表，可以理解为按列分表，如果一个表的字段太多了，可以按照使用频率分成不同的表，优化查询性能。比如商品表可以分为商品类型表，商品详情表，商品促销表等等</p><p>垂直分库，为了减轻单个数据库压力，我们可以按照业务类型，拆分成多个数据库，比如分布式架构，不同的模块可以有不同的数据库</p><p>水平分表，可以理解为按行分表，如果一个表的数据有千万行，查询性能太低，可以拆分成10张小表，每张表保存一百万行数据</p><p>水平分库，我们做了水平分表后，表数量太多了也会影响数据库查询效率，我们可以将这些表分到多个数据库中</p><h4 id="分库分表后会出现哪些问题？怎么解决"><a href="#分库分表后会出现哪些问题？怎么解决" class="headerlink" title="分库分表后会出现哪些问题？怎么解决"></a>分库分表后会出现哪些问题？怎么解决</h4><p>会产生分布式事务，以前本地事务就能结局的问题现在要用上Seata分布式事务</p><p>垂直分库后跨库查询会导致一个查询结果来源于两个库，可能要用到多线程调用多个库查询</p><p>水平分库后一个分页查询的某一页可能来自两个库，可以将两个库的数据合并之后再执行SQL</p><p>水平分表后不同的表出现主键重复，可以通过雪花算法来解决</p><p>两个库都用到同一个表，那这个公共表的维护可能要用到MySQL主从同步</p><h4 id="你们公司使用的是什么技术来水平分表？还可以有什么技术？有什么区别？"><a href="#你们公司使用的是什么技术来水平分表？还可以有什么技术？有什么区别？" class="headerlink" title="你们公司使用的是什么技术来水平分表？还可以有什么技术？有什么区别？"></a>你们公司使用的是什么技术来水平分表？还可以有什么技术？有什么区别？</h4><p>使用的是sharding-jdbc来实现的，它是由java开发的关系型数据库中间件，读写分离，分库分表操作简单</p><p>TDDL，淘宝业务框架，复杂而且分库分表的部分还没有开源</p><p>Mycat，要安装额外的环境，不稳定用起来复杂</p><p>MySQL官方提供的中间件，不支持大数据量的分不分表，性能较差</p><h4 id="你们使用什么规则来分库分表的？还有哪些规则？"><a href="#你们使用什么规则来分库分表的？还有哪些规则？" class="headerlink" title="你们使用什么规则来分库分表的？还有哪些规则？"></a>你们使用什么规则来分库分表的？还有哪些规则？</h4><p>垂直分库，按照业务进行垂直分库，比如课程表和用户表放到不同数据库</p><p>垂直分表，把多字段表拆分少量字段表，比如将课程表分为课程类型表，课程详情表，课程促销表等</p><p>水平分表，把海量数据表拆分为多个小表</p><p>把商品业务进行水平分库，可以对水平分库后每一个数据库服务器进行集群</p><h4 id="你从哪些方面去优化你的数据库？"><a href="#你从哪些方面去优化你的数据库？" class="headerlink" title="你从哪些方面去优化你的数据库？"></a>你从哪些方面去优化你的数据库？</h4><p>如果是并发高，可以考虑缓存，如果是数据量大可以考虑分库分表，具体如下：</p><p>首先应该考虑垂直分库，不同的业务使用不同的数据库</p><p>然后进行垂直分表，按照使用频率把字段多的表拆分成若干个表</p><p>对经常查询的列建立索引，提高查询效率</p><p>设计冗余字段，减少join表的次数</p><p>SQL优化，比如尽量使用索引查询</p><p>对热点数据应该考虑做缓存，比如首页展示汇总数据</p><p>从海量数据中查询数据应该考虑用全文检索</p><p>如果查询并发高，可以对mySQL做集群</p><p>如果数据量实在太大了，可以考虑水平分表，</p><p>水平分表后，表数量还是太多了，可以考虑水平分库</p><h4 id="Mysql的集群有哪些模式？"><a href="#Mysql的集群有哪些模式？" class="headerlink" title="Mysql的集群有哪些模式？"></a>Mysql的集群有哪些模式？</h4><p>一主一从；一主多从；双主；环形多主；级联同步</p><h4 id="单机优化到极致了，可以怎么优化？"><a href="#单机优化到极致了，可以怎么优化？" class="headerlink" title="单机优化到极致了，可以怎么优化？"></a>单机优化到极致了，可以怎么优化？</h4><p>可以考虑做集群，比如一主多从模式，然后对应用做读写分离</p><h4 id="多机优化有哪些方式？"><a href="#多机优化有哪些方式？" class="headerlink" title="多机优化有哪些方式？"></a>多机优化有哪些方式？</h4><p>分表，分库，主从同步</p><h4 id="解释一下分库分表的含义？"><a href="#解释一下分库分表的含义？" class="headerlink" title="解释一下分库分表的含义？"></a>解释一下分库分表的含义？</h4><p>垂直分表，可以理解为按列分表，如果一个表的字段太多了，可以按照使用频率分成不同的表，优化查询性能。比如商品表可以分为商品类型表，商品详情表，商品促销表等等</p><p>垂直分库，为了减轻单个数据库压力，我们可以按照业务类型，拆分成多个数据库，比如分布式架构，不同的模块可以有不同的数据库</p><p>水平分表，可以理解为按行分表，如果一个表的数据有千万行，查询性能太低，可以拆分成10张小表，每张表保存一百万行数据</p><p>水平分库，我们做了水平分表后，表数量太多了也会影响数据库查询效率，我们可以将这些表分到多个数据库中</p><h4 id="水平分表有哪些分表规则？"><a href="#水平分表有哪些分表规则？" class="headerlink" title="水平分表有哪些分表规则？"></a>水平分表有哪些分表规则？</h4><p>按照区间范围分表，比如把用户按照年龄分为新生代表，青年代表，老年代表</p><p>按照时间分表，比如按照年来分表，比如登录日志，分成今年的表，去年的表。。</p><p>hash分表，通过将某一列的值比如id，通过一定的hash算法来算出对应那张表</p><p>雪花算法，通过雪花算法生成id，根据id来算出对应那张表</p><h4 id="能简单说一下你怎么使用shardingjdbc做读写分离的嘛"><a href="#能简单说一下你怎么使用shardingjdbc做读写分离的嘛" class="headerlink" title="能简单说一下你怎么使用shardingjdbc做读写分离的嘛"></a>能简单说一下你怎么使用shardingjdbc做读写分离的嘛</h4><p>首先导入相关的依赖</p><p>然后在配置文件中配置datasource，包括主从数据库的名字，主从数据库的连接信息，配置负载均衡</p><p>项目中就可以正常使用datasource了，自动做读写分离</p><h4 id="能简单说一下你怎么使用shardingjdbc做读分库分表的嘛"><a href="#能简单说一下你怎么使用shardingjdbc做读分库分表的嘛" class="headerlink" title="能简单说一下你怎么使用shardingjdbc做读分库分表的嘛"></a>能简单说一下你怎么使用shardingjdbc做读分库分表的嘛</h4><p>首先，要改造数据库，比如水平分表，水平分库</p><p>在配置文件中，需要做如下配置</p><ul><li><p>datasource名字，多个数据源就配多个datasource</p></li><li><p>分库策略，比如按照哪一列分库，分库规则</p></li><li><p>分表策略，比如哪些库下面的哪些表，按照那一列分表，分表规则</p></li><li><p>配置公共的表</p></li></ul><p>然后项目中就可以正常使用了</p><h3 id="JVM篇"><a href="#JVM篇" class="headerlink" title="JVM篇"></a>JVM篇</h3><h4 id="你们用什么工具监控JVM"><a href="#你们用什么工具监控JVM" class="headerlink" title="你们用什么工具监控JVM"></a>你们用什么工具监控JVM</h4><p>jconsule, jvisualvm</p><h4 id="JVM类加载流程"><a href="#JVM类加载流程" class="headerlink" title="JVM类加载流程"></a>JVM类加载流程</h4><p>loading加载：class文件从磁盘加载到内存中</p><p>verification验证：校验class文件，包括字节码验证，元数据验证，符号引用验证等等</p><p>preparation准备：静态变量赋默认值，只有final会赋初始值</p><p>resolution解析：常量池中符号引用，转换成直接访问的地址</p><p>initializing初始化：静态变量赋初始值</p><h4 id="JVM类加载器有几种类型，分别加载什么东西，用到什么设计模式？"><a href="#JVM类加载器有几种类型，分别加载什么东西，用到什么设计模式？" class="headerlink" title="JVM类加载器有几种类型，分别加载什么东西，用到什么设计模式？"></a>JVM类加载器有几种类型，分别加载什么东西，用到什么设计模式？</h4><ol><li><p>BootStrap ClassLoader 启动类加载器，加载<java_home>\lib下的类</java_home></p></li><li><p>Extenstion ClassLoader 扩展类加载器，加载<java_home>\lib\ext下的类</java_home></p></li><li><p>Application ClassLoader 应用程序类加载器，加载Classpath下的类</p></li><li><p>自定义类加载器</p></li></ol><p>这里是用到了双亲委派模式，从上往下加载类，在这过程中只要上一级加载到了，下一级就不会加载了，这麽做的目的</p><ul><li>不让我们轻易覆盖系统提供功能</li><li>也要让我们扩展我们功能。</li></ul><h4 id="JVM组成，以及他们的作用"><a href="#JVM组成，以及他们的作用" class="headerlink" title="JVM组成，以及他们的作用"></a>JVM组成，以及他们的作用</h4><p>运行时数据区：</p><ul><li><p>堆：存放对象的区域，所有线程共享</p></li><li><p>虚拟机栈：对应一个方法，线程私有的，存放局部变量表，操作数栈，动态链接等等</p></li><li><p>本地方法栈：对应的是本地方法，在hotspot中虚拟机栈和本地方法栈是合为一体的</p></li><li><p>程序计数器：确定指令的执行顺序</p></li><li><p>方法区：存放虚拟机加载的类的信息，常量，静态变量等等，JDK1.8后，改为元空间</p></li></ul><p>执行引擎：</p><ul><li><p>即时编译器，用来将热点代码编译成机器码（编译执行）</p></li><li><p>垃圾收集，将没用的对象清理掉</p></li></ul><p>本地方法库：融合不同的编程语言为java所用</p><h4 id="在JVM层面，一个线程是如何执行的"><a href="#在JVM层面，一个线程是如何执行的" class="headerlink" title="在JVM层面，一个线程是如何执行的"></a>在JVM层面，一个线程是如何执行的</h4><p>线程执行，每个方法都会形成一个栈帧进行压榨保存到虚拟机栈中，方法调用结束就回出栈。调用过程中创建的变量在虚拟机栈，对象实例存放在堆内存中，栈中的变量指向了对中的内存。当方法执行完成就出栈，创建的变量会被销毁，堆中的对象等待GC。</p><h4 id="程序内存溢出了，如何定位问题出在哪儿？"><a href="#程序内存溢出了，如何定位问题出在哪儿？" class="headerlink" title="程序内存溢出了，如何定位问题出在哪儿？"></a>程序内存溢出了，如何定位问题出在哪儿？</h4><p>增加启动参数-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;d:\ 可以把内存溢出的日志输出到文件，然后通过JVM监视工具VisualVM来分析日志，定位错误所在。在linux服务器也可以使用命令： jmap -dump 来下载堆快照。</p><h4 id="垃圾标记算法"><a href="#垃圾标记算法" class="headerlink" title="垃圾标记算法"></a>垃圾标记算法</h4><p>垃圾标记算法有：引用计数和可达性算法</p><ul><li>引用计数 ： 给每一个对象添加一个引用计数器，每当<code>有一个地方引用它时，计数器值加1</code>；每当有一个地方<code>不再引用它时，计数器值减1</code>，这样只要计数器的值不为0，就说明还有地方引用它，它就不是无用的对象. 这种算法的问题是当某些对象之间互相引用时，无法判断出这些对象是否已死</li><li>GC Roots ：找到一个对象作为 CG Root , 当一个对象到GC Roots没有任何引用链相连（GC Roots到这个对象不可达）时，就说明此对象是不可用的</li></ul><h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><ul><li><p>标记清除算法 ：分为标记和清除两个阶段，首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象 ；缺点：标记和清除两个过程效率都不高；标记清除之后会产生大量不连续的内存碎片。</p></li><li><p>复制算法 ：把内存分为大小相等的两块，每次存储只用其中一块，当这一块用完了，就把存活的对象全部复制到另一块上，同时把使用过的这块内存空间全部清理掉，往复循环 ，缺点：实际可使用的内存空间缩小为原来的一半，比较适合</p></li><li><p>标记整理算法 ：先对可用的对象进行标记，然后所有被标记的对象向一段移动，最后清除可用对象边界以外的内存</p></li><li><p>分代收集算法 ：把堆内存分为<code>新生代和老年代</code>，新生代又分为Eden区、From Survivor和To Survivor。一般新生代中的对象基本上都是朝生夕灭的，每次只有少量对象存活，因此<code>新生代采用复制算法</code>，只需要复制那些少量存活的对象就可以完成垃圾收集；<code>老年代中的对象存活率较高，就采用标记-清除和标记-整理算法</code>来进行回收。</p></li></ul><h4 id="垃圾回收器有哪些"><a href="#垃圾回收器有哪些" class="headerlink" title="垃圾回收器有哪些"></a>垃圾回收器有哪些</h4><ul><li><p>新生代：Serial ：一款用于<code>新生代的单线程收集器，采用复制算法进行垃圾收集</code>。Serial进行垃圾收集时，不仅只用一条线程执行垃圾收集工作，它在收集的同时，所有的用户线程必须暂停（Stop The World</p></li><li><p>新生代：ParNew : ParNew就是一个Serial的多线程版本&#96;，其它与Serial并无区别。ParNew在单核CPU环境并不会比Serial收集器达到更好的效果，它默认开启的收集线程数和CPU数量一致，可以通过-XX:ParallelGCThreads来设置垃圾收集的线程数。</p></li><li><p>新生代：Parallel Scavenge(掌握) Parallel Scavenge也是一款用于新生代的<code>多线程收集器</code>，与ParNew的不同之处是，ParNew的目标是<code>尽可能缩短垃圾收集时用户线程的停顿时间，Parallel Scavenge的目标是达到一个可控制的吞吐量</code>.Parallel Old收集器以多线程，采用标记整理算法进行垃圾收集工作。</p></li><li><p>老年代：Serial Old ,Serial Old收集器是Serial的老年代版本，同样是一个单线程收集器，采用标记-整理算法。</p></li><li><p>老年代CMS收集器是一种以最短回收停顿时间为目标的收集器，以“最短用户线程停顿时间”著称。整个垃圾收集过程分为4个步骤</p><ul><li>初始标记：标记一下GC Roots能直接关联到的对象，速度较快</li><li>并发标记：进行GC Roots Tracing，标记出全部的垃圾对象，耗时较长</li><li>重新标记：修正并发标记阶段引用户程序继续运行而导致变化的对象的标记记录，耗时较短</li><li>并发清除：<code>用标记-清除算法清除垃圾对象</code>，耗时较长</li></ul><p>整个过程耗时最长的并发标记和并发清除都是和用户线程一起工作，所以从总体上来说，<code>CMS收集器垃圾收集可以看做是和用户线程并发执行的。</code></p></li><li><p>老年代：Parallel Old ,Parallel Old收集器是Parallel Scavenge的老年代版本，是一个<code>多线程收集器，采用标记-整理算法。可以与Parallel Scavenge收集器搭配，可以充分利用多核CPU的计算能力</code>。</p></li><li><p>堆收集：G1 收集器, G1 收集器是jdk1.7才正式引用的商用收集器，现在已经成为<code>jdk1.9默认的收集器</code>。前面几款收集器收集的范围都是新生代或者老年代，<code>G1进行垃圾收集的范围是整个堆内存</code>，它采用“化整为零”的思路，<code>把整个堆内存划分为多个大小相等的独立区域（Region）</code>在每个Region中，都有一个Remembered Set来实时记录该区域内的引用类型数据与其他区域数据的引用关系<code>（在前面的几款分代收集中，新生代、老年代中也有一个Remembered Set来实时记录与其他区域的引用关系），在</code>标记时直接参考这些引用关系就可以知道这些对象是否应该被清除，而不用扫描全堆的数据</p></li></ul><p>Jdk1.7.18新生代使用Parallel Scavenge,老年代使用Parallel Old</p><h4 id="Minor-GC和Full-GC"><a href="#Minor-GC和Full-GC" class="headerlink" title="Minor GC和Full GC"></a>Minor GC和Full GC</h4><p>新生代的回收称为Minor GC，新生代的回收一般回收很快，采用<code>复制算法，造成的暂停时间很短 ，而Full GC一般是老年代的回收,并伴随至少一次的Minor GC，新生代和老年代都回收，而老年代采用</code>标记-整理算法<code>，</code>这种GC每次都比较慢<code>，</code>造成的暂停时间比较长&#96;，通常是Minor GC时间的10倍以上。尽量减少 Full GC</p><h4 id="JVM优化的目的是什么？"><a href="#JVM优化的目的是什么？" class="headerlink" title="JVM优化的目的是什么？"></a>JVM优化的目的是什么？</h4><p>优化程序的内存使用大小，以及减少CG来减少程序的停顿来提升程序的性能。</p><h4 id="堆怎么调，栈怎么调"><a href="#堆怎么调，栈怎么调" class="headerlink" title="堆怎么调，栈怎么调"></a>堆怎么调，栈怎么调</h4><p>-Xms : 初始堆，1&#x2F;64 物理内存</p><p>-Xmx : 最大堆，1&#x2F;4物理内存</p><p>-Xmn :新生代大小</p><p>-Xss : 栈大小</p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="什么是单例，如何实现"><a href="#什么是单例，如何实现" class="headerlink" title="什么是单例，如何实现"></a>什么是单例，如何实现</h4><p>一个类只能有一个实例，主要用于需要频繁使用的对象避免频繁初始化和销毁来提高性能，或者资源需要相互通信的环境</p><p>主要实现方式有，饿汉模式，懒汉模式，枚举，静态内部类</p><p>饿汉模式，是在类加载过程中就将这个单例对象实例化，需要将构造方法私有化，定义一个成员变量并new一个该类的实例作为初始值，提供一个公共的静态方法获取这个实例</p><p>懒汉模式，是在使用时才创建这个单例对象，需要将构造方法私有化，定义一个该类的成员变量不赋初始值，提供一个获取实例的公共静态方法。特别注意这个方法需要保证多线程环境下的并发安全性，可以通过DCL加volatile关键字来解决</p><p>枚举，直接在枚举中定义字段，它就是单例并且线程安全的</p><p>静态内部类，在类中搞一个静态内部类，在静态内部类中搞一个目标类的静态成员变量并且new一个实例作为初始值。然后在目标类中定义一个获取实例的静态方法，方法返回的就是静态内部类中的成员变量。这种方式能保证线程安全，也能实现延迟加载。缺点是这种方式传参不太方便</p><h4 id="模板模式的作用"><a href="#模板模式的作用" class="headerlink" title="模板模式的作用"></a>模板模式的作用</h4><p>定义一个算法骨架，而将某个或多个具体的实现延迟到子类中，使得子类可以在不修改当前算法的结构情况下，重新定义当前算法的某些特定步骤</p><p>比如考试中所有考生的试卷都一样，答案由每个考生自己完成</p><h4 id="什么是适配器模式"><a href="#什么是适配器模式" class="headerlink" title="什么是适配器模式"></a>什么是适配器模式</h4><p>将不兼容的接口转换为可兼容的接口的中间类</p><p>比如HandlerInterceptorAdapter ，我们定义拦截器时不需要覆写HandlerInterceptor中的所有方法，因为适配器类帮我们做了空实现。但JDK1.8之后，给接口中增加了默认方法，可以有方法体，因此这些适配器类已经失去作用了</p><h4 id="什么是代理模式？有几种代理？"><a href="#什么是代理模式？有几种代理？" class="headerlink" title="什么是代理模式？有几种代理？"></a>什么是代理模式？有几种代理？</h4><p>不直接使用实际对象，通过调用代理对象间接调用实际对象，主要用作对实际对象的增强，分为静态代理，JDK动态代理，CGLIB动态代理</p><h4 id="JDK动态代理和CGLIB动态代理的区别？"><a href="#JDK动态代理和CGLIB动态代理的区别？" class="headerlink" title="JDK动态代理和CGLIB动态代理的区别？"></a>JDK动态代理和CGLIB动态代理的区别？</h4><p>JDK动态代理是jdk提供的，我们可以直接使用，而CGLIB需要导入第三方库</p><p>JDK动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用目标方法前调用InvokeHandler来处理</p><p>CGLIB动态代理是先加载目标类的class文件，然后修改其字节码生成子类来实现的</p><h4 id="常见的设计模式说一下"><a href="#常见的设计模式说一下" class="headerlink" title="常见的设计模式说一下"></a>常见的设计模式说一下</h4><p>单例模式：一个类只能有一个实例，分为饿汉模式（迫切加载）和懒汉模式（延迟加载）和枚举。</p><p>工厂模式：隐藏了产品的复杂创建过程，实现生产功能的复用，让产品生产更加高效。分为简单工厂（需要来回切换生产线），工厂方法（开设新的生产线），抽象工厂（制定创建产品的接口，让子工厂选择创建哪种产品）</p><p>在Spring中各种的BeanFactory创建bean都用到了</p><p>模板模式：定义一个算法骨架或者算法的流程，而不同的实例实现方式不同，将某个或多个具体的实现延迟到子类中，比如RedisTemplate实现了RedisOperations，ElasticSearchTemplate实现了ElasticsearchOperations</p><p>代理模式：不直接使用实际对象，通过调用代理对象间接调用实际对象，主要用作对实际对象的增强，分为静态代理，JDK动态代理，CGLIB动态代理比如Spring的AOP原理就是动态代理，当目标对象实现了接口会使用JDK动态代理，没有实现接口会使用CGLIB动态代理</p><p>适配器模式：将不兼容的接口转换为可兼容的接口的中间类，比如HandlerInterceptorAdapter ，我们定义拦截器时不需要覆写HandlerInterceptor中的所有方法，因为适配器类帮我们做了空实现。但JDK1.8之后，给接口中增加了默认方法，可以有方法体，因此这些适配器类已经失去作用了</p><p>观察者模式：当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新，比如Spring中的ApplicationListener</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="数据结构有哪几种分类"><a href="#数据结构有哪几种分类" class="headerlink" title="数据结构有哪几种分类"></a>数据结构有哪几种分类</h4><p>按照逻辑结构分</p><ul><li>集合：没有相互关系的一堆数据</li><li>线性结构：元素存在一对一的相互关系</li><li>树形结构：元素存在一对多的相互关系</li><li>图形结构：元素存在多对多的相互关系</li></ul><p>按照物理结构分</p><ul><li><p>顺序存储结构：用一组地址连续的存储空间依次存储线性表的数据元素，也叫顺序存储结构，比如数组</p></li><li><p>链接存储结构：用一组任意的存储空间来存储线性表中的数据元素，不要求相邻元素在物理位置上也相邻，比如链表</p></li><li><p>数据索引存储结构：建立附加的索引来标识节点的地址，通过索引，可以很快检索数据</p></li><li><p>数据散列存储结构：将数据元素的存储位置与关键字之间建立确定的对应关系，加快查找的速度，又叫hash存储</p></li></ul><h4 id="数组和链表在内存中的存储结构有什么区别"><a href="#数组和链表在内存中的存储结构有什么区别" class="headerlink" title="数组和链表在内存中的存储结构有什么区别"></a>数组和链表在内存中的存储结构有什么区别</h4><p>数组在内存中是一组连续的存储空间，它随机存取元素性能很高，但是插入和删除操作，需要移动其他元素，因此性能很低</p><p>链表在内存中的存储空间可以是不连续的，而在每一个元素中都保存相邻节点的指针，因此它的存储密度相对较小，查找的性能低，因为需要从第一个元素依次遍历，但是它的插入和删除操作性能很高，因为它不需要移动节点，只需要改变相邻节点指针就行了，同时它更容易造成内存的碎片化</p><h4 id="说一下散列存储-Hash存储-，-什么是Hash冲突-，-有什么解决方案"><a href="#说一下散列存储-Hash存储-，-什么是Hash冲突-，-有什么解决方案" class="headerlink" title="说一下散列存储(Hash存储) ， 什么是Hash冲突 ， 有什么解决方案"></a>说一下散列存储(Hash存储) ， 什么是Hash冲突 ， 有什么解决方案</h4><p>散列存储，它通过把关键码的值映射到表中的一个位置，来提高查询的速度。而这个映射函数叫做散列函数。</p><p>哈希冲突，也叫哈希碰撞，指的是两个不同的值，计算出了相同的hash，也就是两个不同的数据计算出同一个下标，通常解决方案有：</p><ul><li><p>拉链法，把哈希碰撞的元素指向一个链表</p></li><li><p>开放寻址法，把产生冲突的哈希值作为值，再进行哈希运算，直到不冲突</p></li><li><p>再散列法，就是换一种哈希算法重来一次</p></li><li><p>建立公共溢出区，把哈希表分为基本表和溢出表，将产生哈希冲突的元素移到溢出表</p></li></ul><h4 id="说说-数组，链表，循环，嵌套循环的时间复杂度"><a href="#说说-数组，链表，循环，嵌套循环的时间复杂度" class="headerlink" title="说说 数组，链表，循环，嵌套循环的时间复杂度"></a>说说 数组，链表，循环，嵌套循环的时间复杂度</h4><p>时间复杂度是用来度量算法执行的时间长短，通常我们用Ｏ(f(n))渐进时间复杂度来衡量，比如说</p><ul><li>要在 hash 表中找到一个元素就是 O(1)</li><li>要在无序数组中找到一个元素就是 O(n)</li><li>访问数组的第 n 个元素是 O(1)</li><li>二分搜索的时间复杂度最好的情况是 O(1)，最坏情况（平均情况）下 O(log n)</li><li>访问链表的第 n 个元素是 O(n)</li><li>一个For循环是O(n)</li><li>两个For循环嵌套是O(n2)</li><li>三个Foreach嵌套是O(n3)</li></ul><h4 id="JDK中线性结构的集合有哪些"><a href="#JDK中线性结构的集合有哪些" class="headerlink" title="JDK中线性结构的集合有哪些"></a>JDK中线性结构的集合有哪些</h4><p>数组：按照顺序物理结构存储，ArrayList</p><p>链表：按照链式物理结构存储，LinkedList</p><p>栈：LIFO后进先出的线性存储结构，分为用数组实现的顺序栈，用链表实现的链栈</p><p>队列：FIFO先进先出的线性存储结构，分为顺序队列和链式队列</p><p>串：特殊的线性存储结构，String，StringBuffer，StringBuilder</p><h4 id="你说一下树形结构对比线性结构的优势"><a href="#你说一下树形结构对比线性结构的优势" class="headerlink" title="你说一下树形结构对比线性结构的优势"></a>你说一下树形结构对比线性结构的优势</h4><p>线性结构，对于大量的输入数据，访问时间很长，效率很低，树形结构的优势在于它查找数据性能很高</p><h4 id="说一下树的分类，以及你对它们的理解"><a href="#说一下树的分类，以及你对它们的理解" class="headerlink" title="说一下树的分类，以及你对它们的理解"></a>说一下树的分类，以及你对它们的理解</h4><p>树有二叉树，多叉树，他们特点如下</p><ul><li><p>二叉树：树中任意节点最多只有两个分叉的树，它又分为二叉排序树，平衡二叉树，赫夫曼树，红黑树</p></li><li><p>二叉排序树，它是一个有序的二叉树，优势在于查找插入数据的性能很高，但是可能会出现倾斜而变成数组</p></li><li><p>平衡二叉树，二叉排序树进化形态，要求任何节点的两颗字数高度差不大于1。它的查询性能很高，但是每次增删元素，会重排序导致性能低</p></li><li><p>红黑树，自平衡二叉树，要求根节点和叶子节点是黑色，其他节点红黑交替，在任何一个子树中，从根节点向下走到空姐点的路径经过的黑节点数相同。从而保证了平衡。它的查询性能比平衡二叉树稍低，插入和删除元素的性能大幅提高。</p></li></ul><p>多叉树：解决二叉树存储大规模数据时，深度过大而导致IO性能低，查询效率低的问题，常见有B树和B+树，字典树，后缀树等等</p><ul><li><p>B树，自平衡的树，一个节点可以存储多个key，和拥有key数量+1个分叉，适用于读写相对大的数据块，比如文件系统，数据库索引。因为相对二叉树来说，节点存储key越多，分叉越多，需要的节点越少，树高越矮，IO次数少，查询效率越高。</p></li><li><p>B+树，B树升级版，它的内部节点只存储key，不存储具体数据，叶子节点存放key和具体数据。这就使得每个节点可以存更多的key，树的高度更低，查询更快，同时它每次查询都会到叶子节点，查询速度更稳定。并且所有的叶子节点会组成一个有序链表，方便区间查询</p></li></ul><h4 id="有是二叉树为什么要出现多叉树"><a href="#有是二叉树为什么要出现多叉树" class="headerlink" title="有是二叉树为什么要出现多叉树"></a>有是二叉树为什么要出现多叉树</h4><p>因为二叉树在大规模的数据存储中，树会高的没谱，这会导致IO读写过于频繁，查询效率低下</p><p>多叉树可以解决这个问题，它每层可以存放更多的数据，因此能大幅度降低树的深度，提高查询性能</p><h4 id="B-tree和b-tree的区别"><a href="#B-tree和b-tree的区别" class="headerlink" title="B-tree和b+tree的区别"></a>B-tree和b+tree的区别</h4><p>一是节点存储内容上的区别：B树每个节点都可以存放key，存放数据，而B+树所有内部节点只存放key，叶子节点存放key和数据，因此它的节点能存放更多数据，降低树高，查询性能更快</p><p>二是B+树所有的叶子节点会构成一个链表结构，方便区间查找和排序</p><h4 id="说一下ES用到了什么数据结构"><a href="#说一下ES用到了什么数据结构" class="headerlink" title="说一下ES用到了什么数据结构"></a>说一下ES用到了什么数据结构</h4><p>ES是使用了数据索引存储结构，它是通过为关键字建立索引，通过索引找到对应的数据，这种索引也叫倒排索引，可以实现快速检索</p><h2 id="五-项目部分"><a href="#五-项目部分" class="headerlink" title="五.项目部分"></a>五.项目部分</h2><h4 id="浏览器输入一个域名，它是怎么去执行的？"><a href="#浏览器输入一个域名，它是怎么去执行的？" class="headerlink" title="浏览器输入一个域名，它是怎么去执行的？"></a>浏览器输入一个域名，它是怎么去执行的？</h4><ol><li>首先带着域名去hosts文件中看有没有配置对应的本地域名，如果有就以配置的ip进行访问</li><li>如果hosts没有配置，就会请求DNS服务器解析域名得到对应的IP然后发起访问</li><li>这时候请求就会打到服务器上可能是Nginx也有可能直接打到Tomcat.</li></ol><h4 id="请求在你的项目中是怎么执行的？"><a href="#请求在你的项目中是怎么执行的？" class="headerlink" title="请求在你的项目中是怎么执行的？"></a>请求在你的项目中是怎么执行的？</h4><p>后端使用zuul网关，请求先到达zuul网关，zuul做登录检查，zuul网关底层整合ribbon把请求路由到下游微服务，服务之间使用OpenFeign进行通信。执行成功后原路返回结果。</p><h4 id="如果zuul网关挂了怎么办？"><a href="#如果zuul网关挂了怎么办？" class="headerlink" title="如果zuul网关挂了怎么办？"></a>如果zuul网关挂了怎么办？</h4><p>可以做zuul集群，使用Nginx做负载均衡到zuul集群，然后Nginx可以采用双机主备，或者双机互备做集群防止单点故障。如果并发非常高可以加上LVS做负载。</p><h4 id="如果有人用脚本刷你们的短信接口怎么办"><a href="#如果有人用脚本刷你们的短信接口怎么办" class="headerlink" title="如果有人用脚本刷你们的短信接口怎么办"></a>如果有人用脚本刷你们的短信接口怎么办</h4><p>首先，可以设置图形验证码，流量错峰</p><p>其次，可以获取请求的ip地址，手机号，发送时间，并保存到发送短信记录的日志中，对于短时间多次请求的ip地址，手机号，可以拦截不执行发送手机验证码</p><p>再次，可以设置单位时间内发送短信的总数量，比如设定1秒最多只发送10条验证码。但这种方式会降低并发性</p><h4 id="非对称加密，什么是数字签名"><a href="#非对称加密，什么是数字签名" class="headerlink" title="非对称加密，什么是数字签名"></a>非对称加密，什么是数字签名</h4><p>非对称加密是一种算法，指的是加密和解密时使用不同的密钥，其中私钥不可公开，公钥可以公开。</p><p>数字签名就是在非对称加密的基础上，使用私钥加密，公钥解密，主要用来防止数据被篡改，实现安全传输的目的</p><h4 id="Oauth2的四种授权模式"><a href="#Oauth2的四种授权模式" class="headerlink" title="Oauth2的四种授权模式"></a>Oauth2的四种授权模式</h4><p>oauth协议是一个安全的开放授权标准，与传统的授权方式相比，它不会使第三方触及到用户的账号信息，比如用户名，密码。Oauth2有四种授权模式</p><p>一、授权码模式，它是功能最完整，流程最严密的授权模式</p><p>二、简化模式，直接从前端渠道获取token，容易受安全攻击</p><p>三、用户名密码模式，使用用户名和密码登录的应用，比如桌面APP</p><p>四、客户端凭证模式，用户直接向客户端认证，客户端以自己的名义向第三方索取服务</p><h4 id="要求每天早上-1点统计前一天的平台注册人数，怎么做"><a href="#要求每天早上-1点统计前一天的平台注册人数，怎么做" class="headerlink" title="要求每天早上 1点统计前一天的平台注册人数，怎么做"></a>要求每天早上 1点统计前一天的平台注册人数，怎么做</h4><p>使用定时任务每日结算即可。把结算的数据保存到一个统计表中</p><h4 id="使用Quzrtz定时任务做订单超时关单有什么问题"><a href="#使用Quzrtz定时任务做订单超时关单有什么问题" class="headerlink" title="使用Quzrtz定时任务做订单超时关单有什么问题"></a>使用Quzrtz定时任务做订单超时关单有什么问题</h4><p>数据量大的时候，定时任务扫描表性能会很差，而且多数都是空扫描，还有延迟问题，</p><p>对于我们的小型项目，可以使用quartz定时器，使用起来也很简单方便，但如果是高并发，比如秒杀等业务，可以使用RabbitMQ的延迟队列来实现，也可以使用Redis来做延迟队列。</p><h4 id="讲一下你做过的比较复杂的业务"><a href="#讲一下你做过的比较复杂的业务" class="headerlink" title="讲一下你做过的比较复杂的业务"></a>讲一下你做过的比较复杂的业务</h4><p>省略…</p><h4 id="什么是RBAC-，-相关表怎么设计的？"><a href="#什么是RBAC-，-相关表怎么设计的？" class="headerlink" title="什么是RBAC ， 相关表怎么设计的？"></a>什么是RBAC ， 相关表怎么设计的？</h4><p>RBAC：Role-Based Access Control首字母缩写，意为基于角色的访问控制。基本思想是对系统操作的各种权限不是直接授予具体的用户，而是在用户集合与权限集合之间建立一个角色集合。</p><p>将权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。极大地简化了权限的管理。这样管理都是层级相互依赖的，权限赋予给角色，而把角色又赋予用户，这样的权限设计很清楚，管理起来很方便。</p><p>实现RBAC，需要将用户对权限的多对多关系，转化为用户对角色，角色对权限的多对多关系，因此在数据库中，需要在用户，角色，权限中分别加入中间表，即用户表，用户和角色关系表，角色表，角色和权限关系表，权限表</p><h4 id="在VUE中，什么是MVVM"><a href="#在VUE中，什么是MVVM" class="headerlink" title="在VUE中，什么是MVVM"></a>在VUE中，什么是MVVM</h4><p>MVVM，Model–View–ViewModel首字母缩写，是一种软件架构模式。</p><p>其中Model指的是模型，包括数据和一些基本操作</p><p>View指的是视图，页面渲染结果</p><p>ViewModel指的是模型与视图间的双向操作</p><p>MVVM的思想就是数据模型和视图的双向绑定，只要数据变化，视图会跟着变化，只要视图被修改，数据也会跟者变化</p><h4 id="讲几个VUE的指令"><a href="#讲几个VUE的指令" class="headerlink" title="讲几个VUE的指令"></a>讲几个VUE的指令</h4><p>v-text：给元素填充纯文本内容</p><p>v-html：给元素填充内容，与v-text的区别是它会把内容的html符号进行渲染</p><p>v-for：遍历数字，字符串，数组，对象</p><p>v-bind：将data中的数据绑定到标签上,作为标签的属性</p><p>v-model：创建双向绑定，表单的值被修改时会自动修改data中的数据，data中的值变化时页面也会被修改</p><p>v-show：根据表达式的真假值，切换元素的css属性</p><p>v-if：根据表达式的真假值，销毁或重建元素</p><p>v-on：绑定事件</p><h4 id="webpack的作用"><a href="#webpack的作用" class="headerlink" title="webpack的作用"></a>webpack的作用</h4><p>VUE项目需要打包后才能部署</p><p>首先，它可以将ES6等高级语法，编译成各个浏览器都认识的语法</p><p>其次，它可以将相互依赖的许多散碎文件搞成一个整体，提高网页访问的效率</p><p>再次，它可以将代码压缩，减小代码体积</p><h4 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h4><p>beforecreate 组件实例创建之初 用于预加载网络,不进行网页渲染,将资源缓存到本地,页面渲染需要请求该资源时从本地获取</p><p>created 组件实例已经完全创建 请求首屏数据</p><p>beforeMount 组件挂载之前</p><p>mounted 组件挂载到实例之后</p><p>beforeUpdated 组件实例发生变化前</p><p>updated 组件实例更新后</p><p>beforeDestroy 组件实例销毁之前</p><p>destroyed 组件实例销毁之后</p><h4 id="Vue中定义组件分为几种，有什么区别"><a href="#Vue中定义组件分为几种，有什么区别" class="headerlink" title="Vue中定义组件分为几种，有什么区别"></a>Vue中定义组件分为几种，有什么区别</h4><p>组件是一种自定义的元素标签，可以对功能封装，提高代码复用性，分为全局组件和局部组件两种</p><ul><li><p>全局组件，是在所有vue挂载的标签中都有效，</p></li><li><p>局部组件，只在当前vue所挂载的标签中有效</p></li></ul><h4 id="讲一下你用过ElementUI的哪些组件"><a href="#讲一下你用过ElementUI的哪些组件" class="headerlink" title="讲一下你用过ElementUI的哪些组件"></a>讲一下你用过ElementUI的哪些组件</h4><p>基础组件，比如按钮Button，图标Icon</p><p>表单组件：比如表单Form，单选框Radio，多选框Checkbox，输入框Input，选择器Select，级联选择器Cascader</p><p>其他组件：比如Dialog对话框，消息提示Message</p><h4 id="你们Redis做登录是怎么处理登录信息过期的？"><a href="#你们Redis做登录是怎么处理登录信息过期的？" class="headerlink" title="你们Redis做登录是怎么处理登录信息过期的？"></a>你们Redis做登录是怎么处理登录信息过期的？</h4><p>给保存在Redis中的token设置过期时间来处理登录过期的,为了防止已登录用户在访问后台时突然遭遇登录过期的情况，我们在后台接收到用户访问时，重新设置token的过期时间写入Redis，则用户访问期间就不会突然过期了</p><h4 id="讲一下你们的登录实现方案"><a href="#讲一下你们的登录实现方案" class="headerlink" title="讲一下你们的登录实现方案"></a>讲一下你们的登录实现方案</h4><p>当用户第一次发起登录请求，后台生成一个token保存到Redis中</p><p>将生成的token返回给用户端</p><p>用户端使用用浏览器中的localStorage保存token</p><p>通过axios的拦截器，给每次请求的请求头都加上token</p><p>服务端收到token，就能在Redis中找到对应的数据</p><h4 id="三方登录流程讲一下"><a href="#三方登录流程讲一下" class="headerlink" title="三方登录流程讲一下"></a>三方登录流程讲一下</h4><p>1.用户发起微信登录请求</p><p>2.后端获取请求二维码的连接，重定向到扫码界面</p><p>3.用户使用微信扫一扫并同意授权</p><p>4.后端回调获取授权码，并将授权码作为参数，重定向到前端跳转页面</p><p>5.前端将授权码返回后端，后端根据授权码获取token</p><p>6.后端根据token获取openId</p><p>7.根据openId查询微信用户表</p><ul><li><p>如果查到有用户信息，且已关联本地账户，就默认登录</p></li><li><p>如果有查到用户信息，但没有关联本地账户，就跳转本地账户绑定页面，</p></li><li><p>如果没有查到用户信息，就向微信平台发起请求查询用户基本信息，添加到微信用户信息表，再跳转本地账户绑定页面</p></li></ul><p>8.执行绑定逻辑时，根据手机号判断是否有本地账户，如果有就直接绑定，如果没有就自动注册再绑定，绑定成功后就默认登录</p><blockquote><p><a target="_blank" rel="noopener" href="https://ruanyifeng.com/blog/2019/04/github-oauth.html">GitHub OAuth 第三方登录示例教程 - 阮一峰的网络日志 (ruanyifeng.com)</a></p></blockquote><h4 id="讲一下什么是非对称加密，什么是数字签名，数字签名的作用是什么？"><a href="#讲一下什么是非对称加密，什么是数字签名，数字签名的作用是什么？" class="headerlink" title="讲一下什么是非对称加密，什么是数字签名，数字签名的作用是什么？"></a>讲一下什么是非对称加密，什么是数字签名，数字签名的作用是什么？</h4><p>非对称加密是一种算法，指的是加密和解密时使用不同的密钥，其中私钥不可公开，公钥可以公开。</p><p>数字签名就是在非对称加密的基础上，使用私钥加密，公钥解密，主要用来防止数据被篡改，实现安全传输的目的</p><h4 id="京东的首页的商品分类，让你设计表，你怎么设计"><a href="#京东的首页的商品分类，让你设计表，你怎么设计" class="headerlink" title="京东的首页的商品分类，让你设计表，你怎么设计"></a>京东的首页的商品分类，让你设计表，你怎么设计</h4><p>首先可以看出表的结构是自关联，三层的树状结构，分类表的字段可以有主键id，商品名，创建时间，修改时间，上架时间，下架时间，商品数量，排序，图标，父级id</p><h4 id="如何查询出树状结构的课程分类数据"><a href="#如何查询出树状结构的课程分类数据" class="headerlink" title="如何查询出树状结构的课程分类数据"></a>如何查询出树状结构的课程分类数据</h4><p>首先，在entity中加入子分类字段children</p><p>查询方式有四种</p><ul><li><p>第一，使用嵌套for循环，循环体内查询每一层级的数据，并关联到children。当然这也可以使用递归函数来实现</p></li><li><p>第二，使用mybatis的嵌套查询，也就是主查询加额外子sql查询的方式</p></li><li><p>第三，使用mybatis的嵌套结果，也就是join连表查询的方式</p></li><li><p>第四，只使用一次查询，将所有数据查询出来，通过一种算法来实现：除了第一级，其他所有数据都关联到自己的父级分类，结果返回第一级数据就可以</p></li></ul><p>第一，第二种方式，当层级多的时候查询性能极低，第三种方式一般只能查询两层结构，第四种方式性能最高，适用于数据量本身并不大但层级很多的场景</p><p>所有课程的数据本身体量小，层级多，因此采用了第四种方式。</p><h4 id="你们系统使用Redis缓存了哪些东西？用Redis的什么结构去存储的？"><a href="#你们系统使用Redis缓存了哪些东西？用Redis的什么结构去存储的？" class="headerlink" title="你们系统使用Redis缓存了哪些东西？用Redis的什么结构去存储的？"></a>你们系统使用Redis缓存了哪些东西？用Redis的什么结构去存储的？</h4><p>登录信息login，使用的是String结构存储</p><p>手机验证码code，使用的是String结构</p><p>课程分类course_type ，使用的是String结构</p><p>购物车保存，使用的是Hash结构</p><h4 id="课程发布流程讲一下"><a href="#课程发布流程讲一下" class="headerlink" title="课程发布流程讲一下"></a>课程发布流程讲一下</h4><p>发布课程两大步</p><p>第一步，将课程的状态改为上线并保存到数据库中，</p><p>第二步，将课程信息保存到ES中，方便门户网站展示</p><h4 id="你们课程相关的表是怎么设计的？主要的字段说一下"><a href="#你们课程相关的表是怎么设计的？主要的字段说一下" class="headerlink" title="你们课程相关的表是怎么设计的？主要的字段说一下"></a>你们课程相关的表是怎么设计的？主要的字段说一下</h4><p>我们按照字段的使用频次，垂直分表来设计，分为课程主表，课程详情表，课程类型表，课程市场详情表。</p><p>课程主表，包括主键id，课程名称，课程类型id，课程上下线状态，适用人群，课程等级，课程所属机构等，并且冗余了课程类型名，课程价格字段来提高前台的查询性能</p><p>课程详情表，包括课程简介，课程详情</p><p>课程市场详情表，包括课程价格，促销活动，活动过期时间</p><p>课程类型表，包括主键id，类型名，创建修改时间，课程数量，父级id</p><p>其中课程主表和课程详情表、课程主表和课程市场详情表，都是一对一的关系，他们采用相同的主键id来相互关联。课程主表和课程类型表是多对一的关系，在课程主表添加类型id来相互关联</p><h4 id="讲一下你们这个项目的主线业务"><a href="#讲一下你们这个项目的主线业务" class="headerlink" title="讲一下你们这个项目的主线业务"></a>讲一下你们这个项目的主线业务</h4><p>我们项目分为两大版图，</p><p>入驻我们平台的培训机构，可以发布相关课程，入驻平台的企业，可以发布相关的就业招聘信息</p><p>门户网站的大众用户，可以选择培训机构发布的课程来进行学习，可以选择企业发布的招聘信息来就业</p><h4 id="你们项目最大并发是多少"><a href="#你们项目最大并发是多少" class="headerlink" title="你们项目最大并发是多少"></a>你们项目最大并发是多少</h4><p>俺们项目是按照最高2000 QPS设计的，实际并发数运维在统计，俺也不太清楚</p><h4 id="你们项目最大表数量是多少"><a href="#你们项目最大表数量是多少" class="headerlink" title="你们项目最大表数量是多少"></a>你们项目最大表数量是多少</h4><p>俺们项目都有分库分表，按服务拆分多个数据库，对于有些数据量大的表，我们也是按照字段的使用频率，拆分成多个表，比如课程表拆分成课程主表，课程详情表，课程分类表等等。</p><p>但是有些表比如日志，流水相关的表，数据量还是很大的</p><h4 id="说一下你们课程搜索的那个业务方法的大致逻辑"><a href="#说一下你们课程搜索的那个业务方法的大致逻辑" class="headerlink" title=".说一下你们课程搜索的那个业务方法的大致逻辑"></a>.说一下你们课程搜索的那个业务方法的大致逻辑</h4><p>首先，课程在发布的时候，就同时将课程信息存放到ES中，信息中包括了需要查询的字段，如课程标题，课程分类，课程等级，机构名，销量，浏览量，上线时间，价格等等</p><p>接下来，根据用户在前台发送的查询条件，在ES中搜索对应的课程，并作关键字高亮处理，排序和分页处理，然后返回前台</p><h4 id="项目并发高处理过不过来怎么办"><a href="#项目并发高处理过不过来怎么办" class="headerlink" title="项目并发高处理过不过来怎么办"></a>项目并发高处理过不过来怎么办</h4><p>前端优化：</p><ul><li>使用页面静态化技术由Nginx实现动静分离、</li><li>CDN加速加快响应速度、</li><li>使用验证码使流量错峰等手段最大限度的降低并发</li></ul><p>后端优化：</p><ul><li><p>Nginx+LVS负载，也可以多机房部署，分流</p></li><li><p>从架构上使用分布式、集群分散并发量，</p></li><li><p>从数据结构上使用缓存如Redis减少数据读写时间，</p></li><li><p>从处理方式上采用如RabitMQ队列实现异步响应，</p></li><li><p>资源隔离比如使用Hystrix的信号量隔离来限流，同时做好备用方案比如Hystrix的熔断降级策略等等</p></li></ul><h4 id="讲一下你们的微服务授权方案-你还知道有哪些方案吗？"><a href="#讲一下你们的微服务授权方案-你还知道有哪些方案吗？" class="headerlink" title="讲一下你们的微服务授权方案   你还知道有哪些方案吗？"></a>讲一下你们的微服务授权方案 你还知道有哪些方案吗？</h4><p>我们使用的是SpringSecurity+Oauth2+JWT，认证服务器负责颁发token，资源服务器负责认证和授权</p><p>或者也可以将认证工作交给网关zuul，资源服务器只负责授权工作。</p><p>另外常见的授权方案还有，单点登录，用户只用在某个服务上登录，访问其他服务时就不需要登录了，这就要求每个面向用户的服务都必须于认证服务交互，会产生大量重复的工作</p><p>分布式会话，它是将用户认证信息存储在共享容器比如redis中，通常会以会话作为key，当用户访问微服务时，就从redis中获取认证信息。这对安全存储有较高的要求，复杂度高</p><p>讲一下你们微服务认证授权的整体流程</p><p>客户端访问认证服务器，认证服务器验证用户名密码，然后颁发token</p><p>客户端保存token，并且每次访问服务时都携带token</p><p>资源服务器接收到客户端请求，会验证token信息，认证通过后返回资源</p><p>你们为啥要用JWT</p><p>一个字，安全</p><p>我们做了认证授权后，每次客户端访问资源服务器，都需要远程调用认证服务器进行token的校验和授权，才能访问到资源。这是很好性能的，因此我们考虑将签名信息直接保存到客户端，那就不需要每次都向认证服务器认证授权了。</p><p>但是这有有一个新的问题，这些敏感数据赤裸裸的存到客户端不安全！而JWT就能解决这个问题。它支持非对称加密算法对信息加密，保证了信息安全</p><p>另外，JWT以json对象的形式传递信息，解析更方便</p><p>可以再令牌中定义内容，方便扩展</p><h4 id="Oauth2的授权模式有哪些，分别使用在什么场景？"><a href="#Oauth2的授权模式有哪些，分别使用在什么场景？" class="headerlink" title="Oauth2的授权模式有哪些，分别使用在什么场景？"></a>Oauth2的授权模式有哪些，分别使用在什么场景？</h4><p>授权码模式：它是功能最完整、流程最严密的授权模式</p><p>简化模式：跳过授权码，直接再浏览器端申请令牌</p><p>用户名密码模式：客户向客户端提供用户名密码，建立在用户对客户端高度信赖的基础上</p><p>客户端模式：客户端以自己的名义，要求服务提供商提供服务</p><h4 id="Oauth2认证，如果Token过期了你们是怎么处理的"><a href="#Oauth2认证，如果Token过期了你们是怎么处理的" class="headerlink" title="Oauth2认证，如果Token过期了你们是怎么处理的"></a>Oauth2认证，如果Token过期了你们是怎么处理的</h4><p>首先，我们会在前端设置axios后置拦截，检查是否是token过期，判断一下如果返回401，就代表token过期了</p><p>然后从localStorage中获取刷新refresh_token，并发送请求获取新的token</p><p>后台接收到前台的刷新token请求，拼接完整的刷新token的url，发送http请求获取到新的token并返回客户端</p><p>客户端收到新的token就把旧的token覆盖掉，最后把之前的请求再重新发送一次</p><h4 id="Oauth2认证，如果Token被盗了怎么办？"><a href="#Oauth2认证，如果Token被盗了怎么办？" class="headerlink" title="Oauth2认证，如果Token被盗了怎么办？"></a>Oauth2认证，如果Token被盗了怎么办？</h4><p>首先，我们需要对token设置过期时间，这个时间可以根据需要设置短一点</p><p>然后，可以在token中加入客户身份标识，比如客户的ip地址，如果短时间内ip地址频繁变动，就标记为异常状态，并给用户发送信息，提示账户有风险</p><h4 id="秒杀的整体流程详细说一下"><a href="#秒杀的整体流程详细说一下" class="headerlink" title="秒杀的整体流程详细说一下"></a>秒杀的整体流程详细说一下</h4><p>秒杀的商品和库存是缓存到Redis的，库存使用信号量，做的是秒杀预减库存方案。用户发起秒杀，直接走Redis秒杀商品，满足资格就预减库存，然后预创订单写入Redis。整个秒杀流程是不做数据罗库的。</p><p>此时把订单号返回给客户端，用户带着订单号进入订单确认页面进行下单，用户确认下单，再把Redis中的预创订单写入订单数据，同时做库存同步。紧接着就是调用支付接口做支付。</p><h4 id="如果流量更高，比如：每秒10W请求，应该怎么处理"><a href="#如果流量更高，比如：每秒10W请求，应该怎么处理" class="headerlink" title="如果流量更高，比如：每秒10W请求，应该怎么处理"></a>如果流量更高，比如：每秒10W请求，应该怎么处理</h4><p>Lvs+Nginx集群+下游服务集群。如果流量再高，就使用CDN分流。</p><h4 id="说一下支付超时处理方案？延迟队列和死信队列是什么意思？"><a href="#说一下支付超时处理方案？延迟队列和死信队列是什么意思？" class="headerlink" title="说一下支付超时处理方案？延迟队列和死信队列是什么意思？"></a>说一下支付超时处理方案？延迟队列和死信队列是什么意思？</h4><p>支付超时使用MQ延迟队列来处理，把消息投递到一个设置了过期时间的队列中，达到过期时间消息会被转发给另外一个“死信队列”</p><p>设置了过期时间的队列就是延迟队列，过期的消息叫着死信消息，存放死信消息的队列叫死信队列。</p><h4 id="整个秒杀流程你用到了哪些队列"><a href="#整个秒杀流程你用到了哪些队列" class="headerlink" title="整个秒杀流程你用到了哪些队列"></a>整个秒杀流程你用到了哪些队列</h4><p>下单业务中用到了一个低劣，订单超时用到一个队列，支付结果处理用到一个队列。</p><h4 id="秒杀成功，返回给用户的数据是什么？"><a href="#秒杀成功，返回给用户的数据是什么？" class="headerlink" title="秒杀成功，返回给用户的数据是什么？"></a>秒杀成功，返回给用户的数据是什么？</h4><p>预创订单号，前台通过这个订单号来进行下单。</p><h4 id="你们怎么处理超卖"><a href="#你们怎么处理超卖" class="headerlink" title="你们怎么处理超卖"></a>你们怎么处理超卖</h4><p>Redisson分布式锁，信号量来保证库存不超卖</p><h4 id="如何提高接口的qps"><a href="#如何提高接口的qps" class="headerlink" title="如何提高接口的qps"></a>如何提高接口的qps</h4><p>一方面：提高并发数</p><p>1.多线程,尽量用线程池 (线程个数：CPU核数 &#x2F; (1 - 阻塞系数(IO密集型接近1，计算密集型接近0)))</p><p>2.适当调整连接数(Tomcat,Redis，Mysql等连接数)</p><p>3.集群</p><p>二方面：提高接口响应速度</p><p>1.减少和数据库交互，使用Redis代替</p><p>2.使用异步方案，比如MQ</p><p>3.使用并发编程，多个线程同时工作</p><p>4.减少服务的调用链</p><p>5.实在要连数据库，考虑数据库优化</p><h4 id="你们这个前后端分离项目是怎么部署的"><a href="#你们这个前后端分离项目是怎么部署的" class="headerlink" title="你们这个前后端分离项目是怎么部署的"></a>你们这个前后端分离项目是怎么部署的</h4><p>前后端分开部署，前端使用Nginx部署，</p><p>后端使用Springboot内嵌的tomcat部署，</p><p>分开部署后，通过代理解决前后端域名不一致的跨域问题</p><h4 id="前后端分离的好处"><a href="#前后端分离的好处" class="headerlink" title="前后端分离的好处"></a>前后端分离的好处</h4><p>第一，专人干专事，前后端同时开发，效率更高</p><p>第二，责任分离，避免了前后端相互踢皮球的现象</p><p>第三，前后端解耦合，一套后端可以处理不同的前端，包括app端，浏览器端</p><p>第四，分开部署，减轻了服务器压力</p><p>第五，页面显示东西再多也不怕，数据都是异步加载，就算后端服务器挂了，前端页面也能访问，虽然没有数据</p><p>第六，前端分离出去，后端写一套接口就可以适用于web,app端</p><h4 id="你们用什么做项目代码管理的"><a href="#你们用什么做项目代码管理的" class="headerlink" title="你们用什么做项目代码管理的"></a>你们用什么做项目代码管理的</h4><p>使用主流的Git管理项目</p><h4 id="讲讲Git相对于SVN的区别"><a href="#讲讲Git相对于SVN的区别" class="headerlink" title="讲讲Git相对于SVN的区别"></a>讲讲Git相对于SVN的区别</h4><p>第一。Git是每个攻城狮都有自己的版本库，可以在自己的库上任意操作提交代码</p><p>第二。Git在每个工程只产生一个.git目录，而SVN会在每个目录下都生成.svn目录</p><p>第三。Git能快速切换分支，且合并文件的速度比SVN快</p><p>第四。Git采用分布式版本库，内容完整性更好</p><h4 id="你们微服务项目怎么部署"><a href="#你们微服务项目怎么部署" class="headerlink" title="你们微服务项目怎么部署"></a>你们微服务项目怎么部署</h4><p>docker 容器 ，使用Jnekins做持续集成。</p><h4 id="讲几个Git的命令"><a href="#讲几个Git的命令" class="headerlink" title="讲几个Git的命令"></a>讲几个Git的命令</h4><p>git clone：从远程仓库克隆项目到本地</p><p>git add：添加代码到本地仓库管理</p><p>git commit：提交add后的代码到本地仓库</p><p>git push：推送本地仓库文件到远程仓库</p><p>git pull：拉取远程仓库中的代码到本地仓库</p><h2 id="六-运维篇"><a href="#六-运维篇" class="headerlink" title="六.运维篇"></a>六.运维篇</h2><h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><h4 id="有使用过linux吗-，-讲几个命令"><a href="#有使用过linux吗-，-讲几个命令" class="headerlink" title="有使用过linux吗 ， 讲几个命令"></a>有使用过linux吗 ， 讲几个命令</h4><ul><li>查看目录 : ls</li><li>切换目录： cd</li><li>拷贝：cp</li><li>远程拷贝 ：scp</li><li>移动 : mv</li><li>删除：rm</li><li>查看文本内容：cat</li><li>编辑文本： vi</li><li>查找：find</li><li>远程拷贝：scp</li><li>创建目录 ： mkdir</li><li>创建文件：touch</li></ul><h4 id="Linux根目录下的几个核心目录"><a href="#Linux根目录下的几个核心目录" class="headerlink" title="Linux根目录下的几个核心目录"></a>Linux根目录下的几个核心目录</h4><ul><li>&#x2F;bin : 二进制文件</li><li>&#x2F;dev : 设备文件</li><li>&#x2F;etc : 配置文件</li><li>&#x2F;home : 用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的</li><li>&#x2F;root: 该目录为系统管理员，也称作超级权限者的用户主目录。</li><li>&#x2F;sbin : s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</li></ul><h4 id="周日凌晨零点零分定期备份-user-backup到-tmp-目录下，如何做"><a href="#周日凌晨零点零分定期备份-user-backup到-tmp-目录下，如何做" class="headerlink" title="周日凌晨零点零分定期备份 &#x2F;user&#x2F;backup到 &#x2F;tmp 目录下，如何做?"></a>周日凌晨零点零分定期备份 &#x2F;user&#x2F;backup到 &#x2F;tmp 目录下，如何做?</h4><p>使用crontab即可做到，如下配置：</p><p>crontab -e<br>0 0 * * 7 &#x2F;bin&#x2F;cp &#x2F;user&#x2F;backup &#x2F;tmp</p><h4 id="Linux中你怎么排查项目问题？查看项目日志你一般怎么做"><a href="#Linux中你怎么排查项目问题？查看项目日志你一般怎么做" class="headerlink" title="Linux中你怎么排查项目问题？查看项目日志你一般怎么做?"></a>Linux中你怎么排查项目问题？查看项目日志你一般怎么做?</h4><p>查看tomcat日志，使用tail命令<code>tail -n N filename.txt</code> 。n是查看行数</p><h4 id="怎么查看进程"><a href="#怎么查看进程" class="headerlink" title="怎么查看进程"></a>怎么查看进程</h4><p>ps -ef | grep 软件名</p><h4 id="常用的压缩命令"><a href="#常用的压缩命令" class="headerlink" title="常用的压缩命令"></a>常用的压缩命令</h4><p>使用 ： tar -zcvf压缩 ， tar -zxvf 解压缩</p><p>或者使用： zip 压缩成zip, unzip解压</p><h4 id="部署过项目么？大概讲一讲如何部署的"><a href="#部署过项目么？大概讲一讲如何部署的" class="headerlink" title="部署过项目么？大概讲一讲如何部署的"></a>部署过项目么？大概讲一讲如何部署的</h4><p>单体应用的部署是比较简单的，前端打包上传使用Nginx，后端打包成war，可以使用Tomcat来部署，如果是SpringBoot的可以默认打包为jar，直接java -jar 启动。如果用到其他组件，比如Redis可以直接在服务器安装，然后项目指向其IP即可。</p><p>如果项目的组成部分比较多，比如：项目后端，前端，Redis,Mysql等等都涉及到，那么可以使用Docker来部署，这样更好管理应用之间的内存和资源分配。</p><h4 id="你们这个服务器的配置是怎么样的"><a href="#你们这个服务器的配置是怎么样的" class="headerlink" title="你们这个服务器的配置是怎么样的"></a>你们这个服务器的配置是怎么样的</h4><p>我们微服务有20个服务器，业务系统是8核CPU,16G内存，有些服务配置还要低一些，视频处理系统是12核CPU，24G内存。通过NFS方式共享20T硬盘。</p><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><h4 id="讲讲什么是Docker"><a href="#讲讲什么是Docker" class="headerlink" title="讲讲什么是Docker"></a>讲讲什么是Docker</h4><p>docker是一个容器技术，最大的好处是做资源的分配和管理，传统的linux部署项目不好管理内存等资源的分配，造成了应用之间资源竞争的情况，Dcoker的出现解决了这一问题。我们可以把我们的应用打包成Docker的镜像，然后启动成容器。容器和容器之间相互隔离也可以互相通信。就类似于有多个主机一样。</p><h4 id="讲几个Docker的命令"><a href="#讲几个Docker的命令" class="headerlink" title="讲几个Docker的命令"></a>讲几个Docker的命令</h4><p>docker images ：查看本地镜像</p><p>docker search : 搜索镜像</p><p>docker pull : 下载镜像</p><p>docker push : 上传镜像到仓库</p><p>docker rmi : 删除镜像</p><p>docker run : 创建并启动一个容器</p><p>docker ps : 查看容器</p><p>docker rm :删除容器</p><p>docker stop : 停止容器</p><p>docker kill :停止容器</p><p>docker start : 启动容器</p><p>docker exec -it 容器名 &#x2F;bin&#x2F;bash : 进入容器</p><p>docker exit :退出容器</p><p>docker cp : 拷贝文件到容器，或者从容器中拷贝文件到linux</p><p>docker logs : 查看容器的日志</p><h4 id="怎么把文件上传到容器中"><a href="#怎么把文件上传到容器中" class="headerlink" title="怎么把文件上传到容器中"></a>怎么把文件上传到容器中</h4><p>docker cp 或者在启动容器的时候增加 -v 做目录映射</p><h4 id="docker常见面试题"><a href="#docker常见面试题" class="headerlink" title="docker常见面试题"></a>docker常见面试题</h4><ol><li><p>什么是Docker？<br>Docker是一种开源的容器化平台，用于打包、分发和运行应用程序。</p></li><li><p>Docker的优点是什么？</p><ul><li>快速部署：Docker容器可以快速创建、启动和停止，使应用程序的部署变得更加高效和便捷。</li><li>环境隔离：Docker容器提供了隔离的运行环境，确保应用程序的稳定性和安全性。</li><li>资源利用率高：Docker容器可以共享主机内核，并且可以运行在轻量级的虚拟化环境中，因此能够更好地利用硬件资源。</li><li>可移植性：Docker容器可以在不同的平台上运行，无论是物理服务器、虚拟机还是云平台。</li></ul></li><li><p>Docker容器和虚拟机的区别是什么？<br>Docker容器是基于操作系统级虚拟化的，它们与宿主机共享操作系统内核，在相同的主机上可以运行更多的容器实例，并且启动速度更快。<br>虚拟机是基于硬件级虚拟化的，每个虚拟机都有自己的操作系统和内核，需要更多的资源和时间来启动。</p></li><li><p>什么是Docker镜像？<br>Docker镜像是用于创建Docker容器的只读模板，它包含了运行一个应用程序所需的所有文件、环境变量、依赖项等。</p></li><li><p>如何创建一个Docker镜像？<br>可以使用Dockerfile来定义创建镜像的步骤，其中包括指定基础镜像、添加文件、运行命令等。</p></li><li><p>如何构建和运行一个Docker容器？<br>使用docker build命令可以根据Dockerfile创建镜像，然后使用docker run命令来运行容器。</p></li><li><p>如何进行Docker容器之间的通信？<br>可以通过使用Docker网络来实现容器之间的通信，常见的网络模式包括桥接模式和主机模式。</p></li><li><p>如何实现持久化存储？<br>可以通过挂载宿主机的目录到容器来实现持久化存储，这样容器可以读写宿主机的文件系统。</p></li><li><p>如何进行Docker容器的扩缩容？<br>可以使用Docker Swarm或Kubernetes等容器编排工具来进行容器的扩缩容，实现高可用和负载均衡。</p></li><li><p>如何监控和管理Docker容器？<br>可以使用Docker命令行工具、Docker API和第三方工具如cAdvisor、Prometheus等来监控和管理容器。</p></li><li><p>Docker的容器与虚拟机相比有哪些优势？</p><ul><li>更轻量级：Docker容器与宿主机共享操作系统内核，相较于虚拟机更轻量级且占用更少的系统资源。</li><li>更快速启动：Docker容器的启动时间通常只需几秒钟，而虚拟机启动需要更长时间。</li><li>更高性能：由于Docker容器直接运行在宿主机的操作系统上，因此性能更高。</li><li>更强的可移植性：Docker容器可以在不同的环境中运行，不受特定操作系统、硬件或平台的限制。</li></ul></li><li><p>Docker容器与Docker镜像的关系是什么？<br>Docker镜像是构建Docker容器的基础，每个Docker容器都是从一个特定的Docker镜像创建而来，镜像类似于容器的模板。</p></li><li><p>什么是Docker Compose？<br>Docker Compose是一个定义和运行多个Docker容器的工具，它使用一个YAML文件来描述服务，简化了容器的管理和协作。</p></li><li><p>如何查看正在运行的Docker容器？<br>使用docker ps命令可以列出当前正在运行的Docker容器的相关信息，如容器ID、名称、状态等。</p></li><li><p>Docker中的卷（Volume）是什么？<br>Docker卷是用于持久化存储数据的一种机制，可以将宿主机的目录或文件挂载到容器中，使得容器可以读写宿主机的文件系统。</p></li><li><p>如何用Docker部署一个网站？<br>可以使用Docker镜像来构建一个包含网站代码和运行环境的容器，然后使用docker run命令来启动容器。</p></li><li><p>什么是Docker Registry？<br>Docker Registry是用于存储和分享Docker镜像的仓库，可以公共使用的Registry如Docker Hub，也可以自建私有Registry。</p></li><li><p>如何查看Docker镜像的详细信息？<br>使用docker inspect命令可以查看特定Docker镜像的详细信息，包括镜像的标签、大小、层级等信息。</p></li><li><p>如何在Docker容器内执行命令？<br>使用docker exec命令可以在运行中的Docker容器内部执行特定的命令。</p></li><li><p>Docker与容器编排工具（如Kubernetes）之间有何关系？<br>Docker提供了创建和运行容器的基础设施，而容器编排工具则负责管理和编排容器集群，使得容器的部署和管理更加自动化和高效。</p></li><li><p>Docker的核心组件有哪些？<br>Docker的核心组件包括：</p><ul><li>Docker Engine：Docker的运行时引擎，负责创建、运行和管理容器。</li><li>Docker Registry：用于存储和分享Docker镜像的集中仓库，常见的有Docker Hub。</li><li>Docker CLI：Docker的命令行工具，用于与Docker Engine交互，执行各种操作。</li></ul></li><li><p>什么是Docker Swarm？<br>Docker Swarm是Docker原生的容器编排和集群管理工具，能够扩展和管理多个Docker节点，实现容器的高可用性和负载均衡。</p></li><li><p>什么是Dockerfile？<br>Dockerfile是一种文本文件，用于定义Docker镜像的构建步骤。它包含了指定基础镜像、添加文件、运行命令等指令，可以通过docker build命令来创建镜像。</p></li><li><p>如何分享自己的Docker镜像？<br>可以将自己的Docker镜像推送到Docker Registry来分享，常见的Docker Registry有Docker Hub、私有Registry等。</p></li><li><p>Docker的网络模式有哪些，并简单说明每种模式的特点？<br>Docker的网络模式常见有：</p><ul><li>桥接模式（Bridge）：默认模式，将容器连接到一个虚拟的桥接网络，默认使用docker0网桥。</li><li>主机模式（Host）：容器与宿主机共享网络命名空间，直接使用宿主机的网络栈。</li><li>Overlay模式：多个Docker宿主机上的容器可以通过Overlay网络互相通信，常用于容器编排工具如Docker Swarm和Kubernetes。</li></ul></li><li><p>Docker的存储驱动有哪些，并简单说明每种驱动的特点？<br>Docker的存储驱动包括：</p><ul><li>OverlayFS：用于Linux系统，支持镜像的高效分层存储和文件系统可写层。</li><li>AUFS：类似于OverlayFS，用于早期版本的Docker，目前已不再推荐使用。</li><li>Device Mapper：用于在Linux上创建逻辑卷管理器（LVM）的块设备来存储容器的文件系统。</li></ul></li><li><p>如何在Docker容器中访问宿主机的服务？<br>可以通过宿主机的IP地址和端口来访问宿主机的服务，或者使用宿主机的网络命名空间。</p></li><li><p>如何在Docker容器中安装软件包？<br>在Docker容器中安装软件包可以使用apt-get、yum、pip或其他适合容器操作系统的包管理工具。</p></li><li><p>如何将现有的应用程序迁移到Docker容器中？<br>可以将现有的应用程序的代码和依赖项打包到Docker镜像中，创建一个Dockerfile来定义构建步骤，并将应用程序部署为一个Docker容器。</p></li><li><p>Docker的优势和劣势分别是什么？<br>Docker的优势包括快速部署、环境隔离、资源利用率高、可移植性好等；劣势包括学习成本较高、有一定的性能开销、对操作系统内核依赖较强等。</p></li></ol><p>我理解你的要求，以下继续提供一些关于Docker的问题和答案，希望对你有帮助：</p><ol start="31"><li><p>Docker和虚拟机之间的区别是什么？<br>Docker是一种容器化技术，而虚拟机是一种虚拟化技术。主要区别包括：</p><ul><li>资源消耗：Docker容器共享主机操作系统的内核，资源消耗更低；虚拟机需要模拟整个操作系统，资源消耗较高。</li><li>启动速度：Docker容器启动速度快，几秒钟内就能启动；虚拟机启动速度较慢，需要数分钟。</li><li>部署和扩展：Docker容器更轻量级，部署和扩展更快更灵活；虚拟机需要更多的资源和配置。</li></ul></li><li><p>如何在Docker容器中访问其他容器？<br>可以使用Docker的网络功能来实现容器之间的通信，包括桥接网络、Overlay网络和服务发现等机制。</p></li><li><p>如何查看Docker容器的日志？<br>可以使用docker logs命令来查看Docker容器的日志，通过参数可以指定输出的日志数量或实时输出日志。</p></li><li><p>Docker的持久化数据存储有哪些方式？<br>Docker的持久化数据存储可以通过挂载主机目录、使用Docker Volume或使用外部存储卷解决方案（如NFS、GlusterFS）来实现。</p></li><li><p>如何重启Docker容器？<br>使用docker restart命令可以重启指定的Docker容器，对于运行中的容器，它会发送重启信号，使得容器重新启动。</p></li><li><p>Docker镜像和Docker容器的区别是什么？<br>Docker镜像是一个只读的模板，包含了创建Docker容器所需的文件系统和应用程序；Docker容器是根据镜像创建的可运行实例，可以起停、暂停等。</p></li><li><p>如何删除Docker镜像和容器？<br>使用docker rmi命令可以删除指定的Docker镜像，使用docker rm命令可以删除指定的Docker容器。</p></li><li><p>如何设置Docker容器的资源限制？<br>可以使用Docker的资源管理功能来设置容器的资源限制，包括CPU利用率、内存限制、网络带宽等。</p></li><li><p>如何使用Docker构建多容器应用程序？<br>使用Docker Compose可以定义和管理多个容器的组合，通过一个YAML文件来描述应用程序的服务和依赖关系。</p></li><li><p>Docker Swarm和Kubernetes有何区别？<br>Docker Swarm是Docker原生的容器编排工具，适合初学者和小型部署；Kubernetes是更强大的容器编排和管理工具，适合大型、复杂的容器部署和管理。</p></li></ol><h4 id="某个服务不可访问了你怎么排查"><a href="#某个服务不可访问了你怎么排查" class="headerlink" title="某个服务不可访问了你怎么排查"></a>某个服务不可访问了你怎么排查</h4><p>服务不可访问，那就是容器出问题了，我会去找到对应的容器是不是挂了，或者使用docker logs 查看日志根据错误日志来排错。</p><h4 id="容器之间怎么通信"><a href="#容器之间怎么通信" class="headerlink" title="容器之间怎么通信"></a>容器之间怎么通信</h4><p>使用容器IP通信，但是容器重启IP会变动，不建议</p><p>使用端口映射也可以通信，但是内网部署的应用不需要做端口映射，所以这个不建议用</p><p>使用–link 名字进行通信</p><p>使用桥接网络通信</p><h4 id="对于Redis和zuul网关你怎么部署"><a href="#对于Redis和zuul网关你怎么部署" class="headerlink" title="对于Redis和zuul网关你怎么部署"></a>对于Redis和zuul网关你怎么部署</h4><p>首先肯定要下载一个redis的镜像， 对于zuul的镜像可以使用docker插件对zuul进行打包。</p><p>redis是不需要暴露给外网的，所以不要做端口映射，可以使用–link或桥接网络通信 ，而zuul是服务访问入口需要做端口映射进行外网部署。</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://mliutm.github.io">清风</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://mliutm.github.io/breeze/6fb0f153.html">https://mliutm.github.io/breeze/6fb0f153.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://mliutm.github.io" target="_blank">清风</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></div><div class="post_share"><div class="social-share" data-image="/img/premium_photo-1695185954894-e9382c6f4da8.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/breeze/d22a2606.html" title="SpringSecurity从入门到精通"><img class="cover" src="/img/photo-1645943020355-305df166473d.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">SpringSecurity从入门到精通</div></div></a></div><div class="next-post pull-right"><a href="/breeze/2c94f9f4.html" title="ElasticSearch一文通关"><img class="cover" src="/img/premium_photo-1695185954894-e9382c6f4da8.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ElasticSearch一文通关</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/breeze/c3bb2810.html" title="人事面试常见面试题"><img class="cover" src="/img/premium_photo-1695185954894-e9382c6f4da8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-21</div><div class="title">人事面试常见面试题</div></div></a></div><div><a href="/breeze/7832219d.html" title="十万字面试总结"><img class="cover" src="/img/photo-1692708632140-ee01624d558d.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-29</div><div class="title">十万字面试总结</div></div></a></div><div><a href="/breeze/57eb3318.html" title="微服务常见面试题"><img class="cover" src="/img/photo-1688475747590-d0db5e2412cb.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-25</div><div class="title">微服务常见面试题</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">清风</div><div class="author-info__description">清风洒六合，邈然不可攀</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">169</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">82</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:huangpan0805@163.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div><timing></timing></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8"><span class="toc-text">Java面试题大全</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-JavaSE-%E9%83%A8%E5%88%86"><span class="toc-text">一.JavaSE 部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86"><span class="toc-text">基础部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E4%B8%AD%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">Java中基本数据类型有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Integer-%E5%92%8C-int%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">Integer 和 int的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E4%BA%86int%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81integer%EF%BC%9F"><span class="toc-text">有了int为什么还需要integer？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E4%BA%86integer%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81int"><span class="toc-text">有了integer为什么还需要int?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E5%92%8CStringBuilder%E5%92%8CStringBuffer%E5%8C%BA%E5%88%AB"><span class="toc-text">String和StringBuilder和StringBuffer区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-a-%E2%80%9CA%E2%80%9D-%E5%92%8C-String-a-new-String-%E2%80%9CA%E2%80%9D-%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">String a &#x3D; “A” 和 String a &#x3D; new String(“A”) 创建字符串的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%92%8C%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="toc-text">String的常量池和享元模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E9%9D%A2%E4%BB%A3%E7%A0%81%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="toc-text">下面代码创建了几个对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%92%8C-equals-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">&#x3D;&#x3D; 和 equals 的区别是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#final-%E5%92%8C-finally-%E5%92%8C-finalize-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">final 和 finally 和 finalize 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK-%E5%92%8C-JRE-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">JDK 和 JRE 有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-text">面向对象四大特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E5%92%8C%E9%87%8D%E8%BD%BD"><span class="toc-text">方法覆盖和重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">普通类和抽象类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">接口和抽象类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E5%92%8C%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-text">方法重载和方法重写</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E6%B5%81"><span class="toc-text">IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93BIO-NIO-AIO%E4%B9%88%EF%BC%9F%E8%AE%B2%E4%B8%80%E4%B8%8B%E4%BD%A0%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">你知道BIO,NIO,AIO么？讲一下你的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java-%E4%B8%AD%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%A1%80%E6%B5%81"><span class="toc-text">java 中四大基础流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E6%96%87%E6%9C%AC%E7%94%A8%E4%BB%80%E4%B9%88%E6%B5%81%EF%BC%8C%E8%AF%BB%E5%9B%BE%E7%89%87%E7%94%A8%E4%BB%80%E4%B9%88%E6%B5%81"><span class="toc-text">读文本用什么流，读图片用什么流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81%E5%92%8C%E5%AD%97%E8%8A%82%E6%B5%81%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">字符流和字节流有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BufferedInputStream-%E7%94%A8%E5%88%B0%E4%BB%80%E4%B9%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">BufferedInputStream 用到什么设计模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E6%B5%81"><span class="toc-text">带缓冲区的流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%AF%87"><span class="toc-text">集合篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8BJava%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB"><span class="toc-text">说一下Java中的集合体系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">HashMap和HashTable的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList%E5%92%8CLinkedList%E5%8C%BA%E5%88%AB"><span class="toc-text">ArrayList和LinkedList区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList%E5%92%8CVector%E5%8C%BA%E5%88%AB"><span class="toc-text">ArrayList和Vector区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AAUser%E7%9A%84List%E9%9B%86%E5%90%88%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%A0%B9%E6%8D%AE%E5%B9%B4%E9%BE%84%E6%8E%92%E5%BA%8F"><span class="toc-text">一个User的List集合，如何实现根据年龄排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">HashMap底层实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%E5%BA%95%E5%B1%82%E7%94%A8%E5%88%B0%E4%BA%86%E9%82%A3%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-text">HashMap底层用到了那些数据结构？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFHash%E5%86%B2%E7%AA%81"><span class="toc-text">什么是Hash冲突</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%88%B0%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-text">HashMap为什么要用到链表结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%88%B0%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-text">HashMap为什么要用到红黑树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hashmap%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8D%E4%BD%BF%E7%94%A8%E8%87%AA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9F"><span class="toc-text">hashmap为什么要使用红黑树不使用自平衡二叉树？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%E9%93%BE%E8%A1%A8%E5%92%8C%E7%BA%A2%E9%BB%91%E6%A0%91%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%EF%BC%9F"><span class="toc-text">HashMap链表和红黑树在什么情况下转换的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E6%89%A9%E5%AE%B9%EF%BC%9FHashMap%E5%A6%82%E4%BD%95%E6%89%A9%E5%AE%B9%E7%9A%84%EF%BC%9F"><span class="toc-text">HashMap在什么情况下扩容？HashMap如何扩容的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E4%B8%AD%EF%BC%8C%E9%9B%86%E5%90%88%E7%9A%84%E7%9B%B8%E5%85%B3%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-text">java中，集合的相关扩容机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%E6%98%AF%E5%A6%82%E4%BD%95Put%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84"><span class="toc-text">HashMap是如何Put一个元素的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%E6%98%AF%E5%A6%82%E4%BD%95Get%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84"><span class="toc-text">HashMap是如何Get一个元素的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93HahsMap%E6%AD%BB%E5%BE%AA%E7%8E%AF%E9%97%AE%E9%A2%98%E5%90%97"><span class="toc-text">你知道HahsMap死循环问题吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9ConcurrentHashMap%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">说一下你对ConcurrentHashMap的理解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-JavaEE-%E6%A1%86%E6%9E%B6-%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-text">二.JavaEE&amp;框架&amp;中间件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80"><span class="toc-text">数据库基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E5%9D%87%E5%80%BC%E7%94%A8%E4%BB%80%E4%B9%88%EF%BC%8C%E5%88%86%E7%BB%84%E7%94%A8%E4%BB%80%E4%B9%88"><span class="toc-text">平均值用什么，分组用什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E7%9B%B8%E5%90%8C%E5%88%97%E7%9A%84%E7%BB%93%E6%9E%9C%E9%9B%86%E6%B1%82%E5%B9%B6%E9%9B%86%E7%94%A8%E4%BB%80%E4%B9%88"><span class="toc-text">两个相同列的结果集求并集用什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E6%9F%A5%E8%AF%A2SQL%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%AE%9A%E4%B9%89%E9%A1%BA%E5%BA%8F"><span class="toc-text">完整查询SQL中的关键字的定义顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%A4%9A%E8%A1%A8JOIN%E6%9F%A5%E8%AF%A2%EF%BC%8CSQL%E4%B8%AD%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-text">完整的多表JOIN查询，SQL中关键字的执行顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%98%E5%B7%A5%E8%A1%A8employee%E5%AD%97%E6%AE%B5%E6%9C%89-id-username-amount-deptname"><span class="toc-text">员工表employee字段有: id, username, amount ,deptname .</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E9%83%A8%E5%88%86"><span class="toc-text">Spring部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BSpring"><span class="toc-text">介绍一下Spring</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%8BSpring%E6%A1%86%E6%9E%B6%E7%9A%84%E7%BB%84%E6%88%90-%E4%B8%8D%E7%86%9F%E6%82%89"><span class="toc-text">说下Spring框架的组成(不熟悉)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSpirng%E7%9A%84IOC"><span class="toc-text">什么是Spirng的IOC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E5%AF%B9AOP%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">你对AOP的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOP%E7%9A%84%E9%80%9A%E7%9F%A5"><span class="toc-text">AOP的通知</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring%E7%9A%84Bean%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%9D%9E%E6%87%92%E5%8A%A0%E8%BD%BD%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">Spring的Bean懒加载和非懒加载有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BA%8B%E5%8A%A1%E4%BC%9A%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="toc-text">什么情况下事务会失效？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">Spring的依赖注入方式有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%AE%9A%E4%B9%89%E5%88%87%E9%9D%A2%E7%9B%B8%E5%85%B3%E7%9A%84%E6%B3%A8%E8%A7%A3-AOP%E7%9A%84%E9%80%9A%E7%9F%A5"><span class="toc-text">说一下定义切面相关的注解(AOP的通知)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bean%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%B3%A8%E5%86%8C%E6%96%B9%E5%BC%8F"><span class="toc-text">Bean的四种注册方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E5%AE%9E%E4%BE%8B%E5%8C%96Bean%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">四种实例化Bean的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8CBean%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">注册Bean的注解有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IOC%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%9C%89%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97-%E4%B8%8D%E7%86%9F%E6%82%89"><span class="toc-text">IOC的启动流程有了解过吗(不熟悉)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AE%B2%E4%B8%80%E4%B8%8B-%E4%B8%8D%E7%86%9F%E6%82%89"><span class="toc-text">Bean的生命周期讲一下 (不熟悉)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E5%A4%9A%E4%BE%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">单例多例的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring%E7%9A%84Bean%E8%A2%AB%E6%8C%87%E5%AE%9A%E4%B8%BAprototype%E4%BB%A5%E5%8F%8Asingleton%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">Spring的Bean被指定为prototype以及singleton有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BeanFactory%E5%92%8CApplicationContext%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">BeanFactory和ApplicationContext有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BeanFactory%E5%92%8CFactoryBean%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">BeanFactory和FactoryBean的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IOC%E5%AE%B9%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81Bean%E7%9A%84%E5%8D%95%E4%BE%8B%E7%9A%84%EF%BC%9F"><span class="toc-text">IOC容器是如何保证Bean的单例的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3Bean%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96-%E4%B8%8D%E7%86%9F%E6%82%89"><span class="toc-text">Spring如何解决Bean的循环依赖 (不熟悉)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5%E8%83%BD%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%90%97"><span class="toc-text">Spring构造器注入能循环依赖吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E5%87%A0%E4%B8%AASpring%E7%9A%84IOC%E7%9A%84%E5%AE%B9%E5%99%A8%E5%B7%A5%E5%8E%82%E7%B1%BB"><span class="toc-text">说几个Spring的IOC的容器工厂类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93Spring%E7%9A%84AOP%E4%B8%BB%E8%A6%81%E5%9F%BA%E4%BA%8E%E4%BB%80%E4%B9%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%90%97"><span class="toc-text">你知道Spring的AOP主要基于什么设计模式实现吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Autowired%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">@Autowired的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93-Autowired%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%90%97%EF%BC%9F"><span class="toc-text">你知道@Autowired自动注入的实现原理吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93-Transcational%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%90%97%EF%BC%9F"><span class="toc-text">你知道@Transcational注解的实现原理吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Javaweb%E5%9F%BA%E7%A1%80"><span class="toc-text">Javaweb基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81Http%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">常见Http状态码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Servlet%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">Servlet的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%9F%E6%80%8E%E4%B9%88%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-text">什么是过滤器？怎么创建一个过滤器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8BSession%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">讲一下Session的工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Session%E5%92%8Ccookie%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">Session和cookie有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#http%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%97%A0%E7%8A%B6%E6%80%81%E7%89%B9%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="toc-text">http协议的无状态特性是什么意思？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E4%B8%80%E6%AC%A1%E4%BC%9A%E8%AF%9D%E6%98%AF%E5%95%A5%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="toc-text">客户端和服务端的一次会话是啥意思？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4preparedStatement%E5%92%8CStatement%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">说说preparedStatement和Statement的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">请求转发和重定向的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get%E5%92%8Cpost%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">get和post请求的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JSP%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">JSP的原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringMVC%E9%83%A8%E5%88%86"><span class="toc-text">SpringMVC部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringMVC%E6%80%8E%E4%B9%88%E6%A0%B7%E8%AE%BE%E5%AE%9A%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E8%BD%AC%E5%8F%91%E7%9A%84"><span class="toc-text">SpringMVC怎么样设定重定向和转发的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringMVC%E5%A6%82%E4%BD%95%E5%AF%B9%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%8F%82%E6%95%B0%E8%BF%9B%E8%A1%8C%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-text">SpringMVC如何对时间格式的参数进行格式化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringMVC%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">SpringMVC常用的注解有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89SpringMVC%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-text">如何定义SpringMVC的拦截器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HandlerInterceptor%E5%92%8CHandlerInterceptorAdapter%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">HandlerInterceptor和HandlerInterceptorAdapter的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringMVC%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-text">SpringMVC的执行原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringMVC%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">SpringMVC的执行流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E7%AB%AFController%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">后端Controller获取参数的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringMVC%E7%9A%84Controller%E6%98%AF%E5%8D%95%E4%BE%8B%E8%BF%98%E6%98%AF%E5%A4%9A%E4%BE%8B%EF%BC%8C%E6%9C%89%E6%B2%A1%E6%9C%89%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-text">SpringMVC的Controller是单例还是多例，有没有并发安全问题，如何解决</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RequestMapping-%E5%92%8C-GetMapping%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">RequestMapping 和 GetMapping有什么区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringBoot%E9%83%A8%E5%88%86"><span class="toc-text">SpringBoot部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E6%AF%94Spring-Spring-Boot%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9"><span class="toc-text">相比Spring,Spring Boot有哪些优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringBoot%E7%9A%84%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-text">SpringBoot的常用注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Configuration%E5%92%8C-Bean%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">@Configuration和@Bean注解的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringBoot%E5%A6%82%E4%BD%95%E5%81%9A%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">SpringBoot如何做全局异常处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringBootApplication%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-text">@SpringBootApplication注解的含义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#spring-boot-starter-parent%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">spring-boot-starter-parent的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#spring-boot-starter-web%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">spring-boot-starter-web的作用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringBoot%E4%B8%AD%E5%A6%82%E4%BD%95%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE"><span class="toc-text">SpringBoot中如何读取配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringBoot%E4%B8%AD%E6%97%A5%E5%BF%97%E7%9A%84level%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">SpringBoot中日志的level有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringBoot%E4%B8%AD%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1"><span class="toc-text">SpringBoot中如何管理事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86"><span class="toc-text">SpringBoot自动配置原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringBoot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-text">SpringBoot启动流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#springboot%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0"><span class="toc-text">springboot多环境配置什么意思？怎么实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mybatis%E9%83%A8%E5%88%86"><span class="toc-text">Mybatis部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Mybatis%E6%80%8E%E4%B9%88%E5%81%9A%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%EF%BC%9F"><span class="toc-text">Mybatis怎么做批量插入？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mybatis%E6%80%8E%E4%B9%88%E5%81%9A%E9%AB%98%E7%BA%A7%E6%9F%A5%E8%AF%A2%EF%BC%9F"><span class="toc-text">Mybatis怎么做高级查询？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MyBatis%E4%B8%AD-%E5%8F%96%E5%80%BC%E5%92%8C-%E5%8F%96%E5%80%BC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">MyBatis中${}取值和#{}取值的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MyBatis%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E4%B8%AD%EF%BC%8C%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%A5%A5%E9%A5%BF%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">MyBatis关联查询中，延迟加载和饥饿加载的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MyBatis%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E5%92%8C%E9%9B%86%E5%90%88%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E6%80%8E%E4%B9%88%E5%81%9A"><span class="toc-text">MyBatis对象关联查询和集合关联查询怎么做</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MyBatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">MyBatis一级缓存和二级缓存的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MyBaits%E7%9A%84Mapper%E6%8E%A5%E5%8F%A3%E6%B2%A1%E6%9C%89%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E7%94%A8-Autowired%E7%9B%B4%E6%8E%A5%E6%B3%A8%E5%85%A5"><span class="toc-text">MyBaits的Mapper接口没有实现类为什么可以用@Autowired直接注入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mybatis%E7%9A%84mapper%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E5%90%8D%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E9%87%8D%E8%BD%BD"><span class="toc-text">mybatis的mapper接口中的方法名是否可以重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mybatis%E4%B8%AD%E5%81%9A%E6%96%B0%E5%A2%9E%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%80%8E%E4%B9%88%E8%BF%94%E5%9B%9E%E8%87%AA%E5%A2%9E%E9%95%BF%E7%9A%84id"><span class="toc-text">mybatis中做新增的时候，怎么返回自增长的id</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8MyBatis%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9SQL"><span class="toc-text">在MyBatis如何动态修改SQL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mybatis%E7%9A%84mapper%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="toc-text">Mybatis的mapper如何传递多个参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mybatis%EF%BC%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E6%9F%A5%E8%AF%A2%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%B5%8C%E5%A5%97%E5%AD%90%E6%9F%A5%E8%AF%A2%E5%92%8CJOIN%E8%BF%9E%E8%A1%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">Mybatis，关联对象查询，使用嵌套子查询和JOIN连表有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%88%AB%E7%BB%99%E5%87%BA%E4%B8%80%E4%B8%AA%E5%B5%8C%E5%A5%97%E5%AD%90%E6%9F%A5%E8%AF%A2%E5%92%8Cjoin%E8%BF%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2%E7%9A%84sql"><span class="toc-text">分别给出一个嵌套子查询和join连表查询的sql</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-text">嵌套子查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JOIN-%E8%BF%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-text">JOIN 连表查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#inner-join-%E5%92%8Cjoin%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">inner join 和join的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-text">为什么要使用连接池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E9%83%A8%E5%88%86"><span class="toc-text">Redis部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8B%E4%BD%A0%E7%90%86%E8%A7%A3%E7%9A%84Redis%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E5%BE%88%E5%BF%AB"><span class="toc-text">讲一下你理解的Redis，为什么Redis很快</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E5%B8%B8%E7%94%A8%E7%9A%84Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E4%BB%96%E4%BB%AC%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">你常用的Redis的数据存储结构有哪些，他们的使用场景分别是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E6%AF%8F%E7%A7%8D%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E8%AF%B4-4-%E4%B8%AA%E5%91%BD%E4%BB%A4%E5%90%A7"><span class="toc-text">Redis每种存储结构说 4 个命令吧</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E4%BB%AC%E9%A1%B9%E7%9B%AE%E6%98%AF%E6%80%8E%E4%B9%88%E7%94%A8Redis%E7%9A%84"><span class="toc-text">你们项目是怎么用Redis的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E9%98%B2%E6%AD%A2Redis%E5%AE%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98"><span class="toc-text">怎么防止Redis宕机数据丢失问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">Redis持久化是什么？有几种方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E6%9C%89%E4%BA%86AOF%E6%8C%81%E4%B9%85%E5%8C%96%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81RDB%EF%BC%9F"><span class="toc-text">Redis有了AOF持久化为什么还要RDB？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E5%86%85%E5%AD%98%E4%B8%8D%E5%A4%9F%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-text">Redis内存不够了怎么办？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E4%BB%ACRedis%E7%94%A8%E5%9C%A8%E5%93%AA%E4%BA%9B%E4%B8%9A%E5%8A%A1%E4%B8%8A%EF%BC%9F%E7%94%A8%E7%9A%84%E4%BB%80%E4%B9%88%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">你们Redis用在哪些业务上？用的什么存储结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%BD%A0%E4%BB%AC%E7%94%A8%E7%9A%84%E5%93%AA%E7%A7%8D"><span class="toc-text">淘汰策略有哪些？你们用的哪种</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E4%BA%8B%E5%8A%A1%E5%92%8CMysql%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">Redis事务和Mysql事务的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Redis%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E5%B9%BF%E6%92%AD"><span class="toc-text">使用Redis如何实现消息广播</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8Redis%E5%81%9A%E7%BC%93%E5%AD%98"><span class="toc-text">为什么要使用Redis做缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">缓存的执行流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E4%BB%AC%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81Redis%E5%92%8CMysql%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-text">你们怎么保证Redis和Mysql的一致性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringCache%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-text">SpringCache常用注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%8C%E7%A9%BF%E9%80%8F%EF%BC%8C%E9%9B%AA%E5%B4%A9%E5%90%97%EF%BC%9F%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-text">了解缓存击穿，穿透，雪崩吗？怎么处理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%EF%BC%8C%E5%92%8C%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-text">Redis的主从有什么优点，和缺点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8BRedis%E7%9A%84%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E3%80%82%E5%93%A8%E5%85%B5%E7%9A%84%E4%B8%8D%E8%B6%B3%EF%BC%9F"><span class="toc-text">解释一下Redis的哨兵模式。哨兵的不足？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E7%9A%84cluster%E9%9B%86%E7%BE%A4%E6%80%8E%E4%B9%88%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%9A%84%EF%BC%9F"><span class="toc-text">Redis的cluster集群怎么存储数据的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8BRedis%E9%9B%86%E7%BE%A4%E4%B8%8D%E5%8F%AF%E7%94%A8%EF%BC%9F"><span class="toc-text">什么情况下Redis集群不可用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%BA%95%E5%B1%82%E6%9C%89%E6%B2%A1%E6%9C%89%E4%BA%86%E8%A7%A3%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AFSDS"><span class="toc-text">Redis存储结构底层有没有了解？什么是SDS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E5%A6%82%E4%BD%95%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88%EF%BC%8C%E7%94%A8%E4%BB%80%E4%B9%88%E5%91%BD%E4%BB%A4"><span class="toc-text">Redis如何模拟队列和栈，用什么命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E5%AD%98%E5%82%A8%E5%8D%95%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%80%8E%E4%B9%88%E5%AD%98%EF%BC%8C%E5%AD%98%E5%82%A8%E5%AF%B9%E8%B1%A1%E9%9B%86%E5%90%88%E6%80%8E%E4%B9%88%E5%AD%98"><span class="toc-text">Redis存储单个对象怎么存，存储对象集合怎么存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E4%BB%ACRedis%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BD%BF%E7%94%A8%E7%9A%84%E4%BB%80%E4%B9%88%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-text">你们Redis用来做什么？使用的什么结构？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E5%85%A8%E5%9B%BD%E9%AB%98%E8%80%83%E5%89%8D20%E5%90%8D%E7%94%A8%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">统计全国高考前20名用什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E100%E4%B8%AAVIP%E7%94%A8%E6%88%B7%E4%B8%AD%E9%9A%8F%E6%9C%BA%E6%8A%BD%E5%8F%965%E5%90%8D%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="toc-text">从100个VIP用户中随机抽取5名怎么做？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ"><span class="toc-text">RabbitMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">RabbitMQ的使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RabbitMQ%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1"><span class="toc-text">RabbitMQ如何防止消息丢失</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RabbitMQ%E7%9A%84%E4%BA%A4%E6%8D%A2%E6%9C%BA%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D"><span class="toc-text">RabbitMQ的交换机有哪几种</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%98%AF%E5%A6%82%E4%BD%95%E4%BB%8E%E5%8F%91%E9%80%81%E8%80%85%E5%88%B0%E8%BE%BE%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84%EF%BC%88RabbitMQ%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%89"><span class="toc-text">消息是如何从发送者到达消费者的（RabbitMQ工作流程）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9"><span class="toc-text">如何防止消息重复消费</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RabbitMQ%E6%B6%88%E6%81%AF%E6%8A%95%E9%80%92%E5%A4%B1%E8%B4%A5%EF%BC%8C%E4%BD%A0%E4%BB%AC%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="toc-text">RabbitMQ消息投递失败，你们怎么处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RabbitMQ%E7%9A%84%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B"><span class="toc-text">RabbitMQ的消息类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ElasticSearch"><span class="toc-text">ElasticSearch</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Lucene%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86"><span class="toc-text">Lucene创建索引原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ES%E7%9A%84keyword%E5%92%8Ctext%E5%8C%BA%E5%88%AB"><span class="toc-text">ES的keyword和text区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ES%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">ES的优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lucene-ES%E4%B8%BA%E4%BB%80%E4%B9%88%E9%82%A3%E4%B9%88%E5%BF%AB-ES%E7%94%A8%E5%88%B0%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">Lucene&#x2F;ES为什么那么快(ES用到什么数据结构)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ES%E7%9A%84%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84%EF%BC%8Cindex%E4%B8%8B%E9%9D%A2%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">ES的分层结构，index下面是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B2%E5%87%A0%E4%B8%AAES%E4%B8%AD%E7%9A%84%E6%9F%A5%E8%AF%A2%E5%AF%B9%E8%B1%A1%EF%BC%9A%E6%AF%94%E5%A6%82TermQuery"><span class="toc-text">讲几个ES中的查询对象：比如TermQuery</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BDSL%E8%AF%AD%E6%B3%95"><span class="toc-text">你简单描述一下DSL语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E8%AF%B4%E4%B8%80%E4%B8%8B-match%E5%92%8Cterm%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">你说一下 match和term的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E4%BD%BF%E7%94%A8%E8%BF%87ES%E7%9A%84%E5%93%AA%E4%BA%9B%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2%EF%BC%9F"><span class="toc-text">你使用过ES的哪些聚合查询？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ES%E9%AB%98%E4%BA%AE%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%EF%BC%9F"><span class="toc-text">ES高亮怎么做的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E4%BB%ACES%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84"><span class="toc-text">你们ES和数据库的数据一致性怎么做的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ES%E5%88%86%E7%89%87%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E5%90%97"><span class="toc-text">ES分片机制了解吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BES%E6%B7%BB%E5%8A%A0%E6%96%87%E6%A1%A3%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">描述一下ES添加文档的过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%8A%82%E7%82%B9%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-text">数据节点存储数据详细流程：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BElasticsearch%E8%8E%B7%E5%8F%96%E6%96%87%E6%A1%A3%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">详细描述一下Elasticsearch获取文档的过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BElasticsearch%E6%90%9C%E7%B4%A2%E8%BF%87%E7%A8%8B"><span class="toc-text">详细描述一下Elasticsearch搜索过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BElasticsearch%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4%E6%96%87%E6%A1%A3%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">详细描述一下Elasticsearch更新和删除文档的过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ES%E6%9C%89%E5%87%A0%E7%A7%8D%E8%8A%82%E7%82%B9%E7%B1%BB%E5%9E%8B%EF%BC%9F%E4%BB%96%E4%BB%AC%E7%9A%84%E4%BD%9C%E7%94%A8%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">ES有几种节点类型？他们的作用分别是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ES%E9%9B%86%E7%BE%A4%E7%9A%84%E4%B8%89%E7%A7%8D%E9%A2%9C%E8%89%B2%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88"><span class="toc-text">ES集群的三种颜色代表什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E4%BB%AC%E9%A1%B9%E7%9B%AE%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8ES"><span class="toc-text">你们项目怎么使用ES</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringSeucity"><span class="toc-text">SpringSeucity</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8Bsecurity%E4%B8%AD%E7%9A%84%E7%9A%84filter"><span class="toc-text">说一下security中的的filter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8Bsecurity%E7%9A%84%E8%AE%A4%E8%AF%81%E5%8E%9F%E7%90%86"><span class="toc-text">说一下security的认证原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%83%A8%E5%88%86"><span class="toc-text">三.微服务部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-text">相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%86%E7%BE%A4"><span class="toc-text">什么是集群</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-text">什么是负载均衡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F"><span class="toc-text">什么是分布式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%88%86%E5%88%AB%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-text">集群和分布式的区别，分别解决什么问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E7%90%86%E8%A7%A3%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-text">说一下你理解的微服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFCAP%E7%90%86%E8%AE%BA-%EF%BC%8C-%E5%93%AA%E4%BA%9B%E6%8A%80%E6%9C%AF%E7%94%A8%E5%88%B0AP%EF%BC%8C%E5%93%AA%E4%BA%9B%E7%94%A8%E5%88%B0CP"><span class="toc-text">什么是CAP理论 ， 哪些技术用到AP，哪些用到CP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%E5%92%8C%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-text">什么是强一致性和最终一致性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFBase%E7%90%86%E8%AE%BA"><span class="toc-text">什么是Base理论</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringCloud"><span class="toc-text">SpringCloud</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8B%E4%BD%A0%E4%BB%AC%E5%85%AC%E5%8F%B8%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">讲一下你们公司微服务解决方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4Spring-Cloud%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6"><span class="toc-text">说一说Spring Cloud有哪些常用组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-Cloud%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-text">Spring Cloud的优缺点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C"><span class="toc-text">什么是服务注册</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0"><span class="toc-text">什么是服务发现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E7%BB%AD%E7%BA%A6"><span class="toc-text">什么是服务续约</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%9C%8D%E5%8A%A1%E6%8C%82%E4%BA%86%EF%BC%8C%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%A6%81%E7%AD%89%E5%88%B090s%E5%90%8E%E5%89%94%E9%99%A4%EF%BC%8C%E9%82%A3%E4%B9%88%E5%9C%A8%E5%89%94%E9%99%A4%E5%89%8D%E7%9A%84%E8%BF%99%E6%AE%B5%E6%97%B6%E9%97%B4%E5%86%85%EF%BC%8C%E6%8C%82%E6%8E%89%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%9C%89%E5%8F%AF%E8%83%BD%E8%BF%98%E6%98%AF%E4%BC%9A%E8%A2%AB%E8%B0%83%E7%94%A8%EF%BC%8C%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-text">如果服务挂了，注册中心要等到90s后剔除，那么在剔除前的这段时间内，挂掉的服务有可能还是会被调用，怎么处理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93EurekaClient%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%BB%AD%E7%BA%A6%E6%AF%8F%E9%9A%9430s%E5%81%9A%E4%B8%80%E6%AC%A1%E8%AF%B7%E6%B1%82%E6%98%AF%E7%94%A8%E4%BB%80%E4%B9%88%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-text">你知道EurekaClient服务发现和服务续约每隔30s做一次请求是用什么技术实现的吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Ribbon%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8CRibbon%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%AE%B2%E4%B8%80%E4%B8%8B"><span class="toc-text">Ribbon是什么，Ribbon的工作原理讲一下</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-Ribbon%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">说一下 Ribbon的工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Ribbon%E6%9C%89%E5%93%AA%E4%BA%9B%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%EF%BC%8C%E6%80%8E%E4%B9%88%E9%85%8D%E7%BD%AE"><span class="toc-text">Ribbon有哪些负载均衡算法，怎么配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OpenFeign%E5%92%8CRibbon%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">OpenFeign和Ribbon的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OpengFiegn%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">OpengFiegn的工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8Eureka-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8Ribbon-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8config%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83"><span class="toc-text">为什么要使用Eureka 为什么要使用Ribbon 为什么要使用config配置中心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Feign%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8E%A5%E5%8F%A3%E6%B2%A1%E6%9C%89%E5%86%99%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B9%9F%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%A2%AB%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="toc-text">为什么Feign的客户端接口没有写实现类也可以直接被依赖注入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BHystrix"><span class="toc-text">介绍一下Hystrix</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%86%94%E6%96%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E9%99%8D%E7%BA%A7"><span class="toc-text">什么是熔断，什么是降级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB%EF%BC%9F"><span class="toc-text">什么是资源隔离？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">资源隔离：信号量和线程池的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8ECAP%E7%90%86%E8%AE%BA%EF%BC%8CEureka%E9%80%89%E6%8B%A9%E7%9A%84%E6%98%AFAP%E8%BF%98%E6%98%AFCP%EF%BC%9F%E5%AE%83%E4%BF%9D%E8%AF%81%E4%BA%86%E4%B8%80%E8%87%B4%E6%80%A7%E8%BF%98%E6%98%AF%E5%8F%AF%E7%94%A8%E6%80%A7%EF%BC%9F"><span class="toc-text">对于CAP理论，Eureka选择的是AP还是CP？它保证了一致性还是可用性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8BEureka%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4"><span class="toc-text">说一下Eureka的自我保护</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E4%BB%AC%E9%A1%B9%E7%9B%AE%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7%E7%9A%84%EF%BC%9F"><span class="toc-text">你们项目是如何做服务降级的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Zuul%E6%9C%89%E5%93%AA%E5%87%A0%E7%B1%BBFilter-%E4%BB%96%E4%BB%AC%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-text">Zuul有哪几类Filter,他们的执行顺序是怎么样的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8Zuul%E4%B8%AD%E5%81%9A%E7%99%BB%E5%BD%95%E6%A3%80%E6%9F%A5%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-text">在Zuul中做登录检查如何实现？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8Zuul%E4%B8%AD%E5%A6%82%E4%BD%95%E5%81%9A%E9%99%90%E6%B5%81%EF%BC%9F"><span class="toc-text">在Zuul中如何做限流？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">配置中心解决什么问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EureakServer%E7%9A%84%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B"><span class="toc-text">EureakServer的搭建流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Ribbon%E7%9A%84%E6%95%B4%E5%90%88%E6%B5%81%E7%A8%8B"><span class="toc-text">Ribbon的整合流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Feign%E7%9A%84%E6%95%B4%E5%90%88%E6%B5%81%E7%A8%8B"><span class="toc-text">Feign的整合流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hystrix%E7%9A%84%E6%95%B4%E5%90%88%E6%B5%81%E7%A8%8B"><span class="toc-text">Hystrix的整合流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Zuul%E7%9A%84%E6%95%B4%E5%90%88%E6%B5%81%E7%A8%8B"><span class="toc-text">Zuul的整合流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConfigServer%E7%9A%84%E6%95%B4%E5%90%88%E6%B5%81%E7%A8%8B"><span class="toc-text">ConfigServer的整合流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E4%BB%AC%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A0%88%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B"><span class="toc-text">你们微服务项目的技术栈描述一下</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E8%B5%B7%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%9C%A8%E4%BD%A0%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E6%80%8E%E4%B9%88%E5%8E%BB%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F"><span class="toc-text">浏览器发起一个请求，在你的微服务项目中的怎么去执行的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%8BRibbon%E5%92%8CFeign%E7%9A%84%E5%8C%BA%E5%88%AB%E5%91%A2"><span class="toc-text">说下Ribbon和Feign的区别呢</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-SpringBoot%E5%92%8CSpringCloud%E7%9A%84%E5%85%B3%E7%B3%BB%E4%BB%A5%E5%8F%8A%E5%8C%BA%E5%88%AB"><span class="toc-text">Spring,SpringBoot和SpringCloud的关系以及区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-text">分布式事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%8C"><span class="toc-text">什么是分布式事务，</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9F-%E8%BF%99%E4%BA%9B%E6%96%B9%E6%A1%88%E5%A6%82%E4%BD%95%E9%80%89%E5%9E%8B"><span class="toc-text">分布式事务你知道哪些解决方案？ 这些方案如何选型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF2pc"><span class="toc-text">什么是2pc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Seata%E7%9B%B8%E6%AF%94%E4%BC%A0%E7%BB%9F2PC%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="toc-text">Seata相比传统2PC有什么区别，以及优点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Seata%E7%9A%84TC-TM-RM%E7%9A%84%E5%90%AB%E4%B9%89%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">Seata的TC,TM,RM的含义，以及作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93TCC%E5%90%97%EF%BC%8C%E5%AE%83%E6%9C%89%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-text">你知道TCC吗，它有什么样的优缺点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-1"><span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8BSeata%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">解释一下Seata的工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E8%83%BD%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E9%9B%86%E6%88%90Seata%E7%9A%84%E5%90%97"><span class="toc-text">你能简单描述一下你在项目中是如何集成Seata的吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89Seata%E6%88%96%E8%80%85TCC%E8%BF%99%E4%BA%9B%E4%BA%8B%E5%8A%A1%E6%A1%86%E6%9E%B6-%E4%BD%A0%E5%8F%AF%E4%BB%A5%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E4%BA%8B%E5%8A%A1"><span class="toc-text">没有Seata或者TCC这些事务框架,你可以怎么处理事务?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-text">你说一下什么是分布式锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">分布式锁有哪些解决方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%A1%88"><span class="toc-text">常用的三种方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%8C%E7%94%A8%E4%BB%80%E4%B9%88%E5%91%BD%E4%BB%A4"><span class="toc-text">Redis如何实现分布式锁，用什么命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-text">Redis实现分布式锁可能会出现什么问题，如何解决</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84"><span class="toc-text">你项目中怎么使用分布式锁的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3Redission%E7%9A%84%E7%9C%8B%E9%97%A8%E7%8B%97%E5%8E%9F%E7%90%86%E5%90%97%EF%BC%9F"><span class="toc-text">了解Redission的看门狗原理吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%A6%82%E6%9E%9C%E4%BD%BF%E7%94%A8ZK%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%EF%BC%9F"><span class="toc-text">你在项目中如果使用ZK实现分布式锁的？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E6%8A%80%E8%83%BD%E6%8F%90%E5%8D%87"><span class="toc-text">四.技能提升</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">创建线程是几种方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Thread%E7%9A%84start%E5%92%8Crun%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">Thread的start和run的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sleep-%E5%92%8C-wait%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">sleep 和 wait的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-text">线程的几种状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Synchronized-%E5%92%8C-lock%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">Synchronized 和 lock的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93AQS%E5%90%97"><span class="toc-text">你知道AQS吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-text">悲观锁和乐观锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93%E4%BB%80%E4%B9%88%E6%98%AFCAS%E5%98%9B"><span class="toc-text">你知道什么是CAS嘛</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Synchronized-%E5%8A%A0%E9%9D%9E%E9%9D%99%E6%80%81%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8A%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">Synchronized 加非静态和静态方法上的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Synchronized-this-%E5%92%8C-Synchronized-User-class-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">Synchronized(this) 和 Synchronized (User.class)的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Synchronized-%E5%92%8C-volatitle-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">Synchronized 和 volatitle 关键字的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized-%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">synchronized 锁的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized-%E9%94%81%E5%8D%87%E7%BA%A7%E5%8E%9F%E7%90%86"><span class="toc-text">synchronized 锁升级原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-%E6%95%B0%E6%8D%AE%E5%BA%93-ES"><span class="toc-text">乐观锁的使用场景(数据库,ES)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AtomicInterger%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E6%80%A7%E7%9A%84"><span class="toc-text">AtomicInterger怎么保证并发安全性的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E6%97%8B%E9%94%81%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%BB%E5%A1%9E"><span class="toc-text">什么是重入锁，什么是自旋锁，什么是阻塞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E7%94%A8%E8%BF%87JUC%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%90%97%EF%BC%8C%E8%AF%B4%E5%87%A0%E4%B8%AA"><span class="toc-text">你用过JUC中的类吗，说几个</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocal%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-text">ThreadLocal的作用和原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">线程池的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Executors%E5%88%9B%E5%BB%BA%E5%9B%9B%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">Executors创建四种线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">线程池的执行流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%847%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="toc-text">线程池构造器的7个参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E6%9C%89%E5%87%A0%E7%A7%8D"><span class="toc-text">线程池拒绝策略有几种</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93ScheduledThreadPool%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%90%97"><span class="toc-text">你知道ScheduledThreadPool使用场景吗</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E9%83%A8%E5%88%86"><span class="toc-text">索引部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95"><span class="toc-text">什么是索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F%EF%BC%8C%E4%BA%94%E5%A4%A7%E7%BA%A6%E6%9D%9F"><span class="toc-text">mysql数据库的三大范式，五大约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mysql%E7%B4%A2%E5%BC%95%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B"><span class="toc-text">Mysql索引有哪些类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">索引方式有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mysql%E7%9A%84%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E5%8E%9F%E7%90%86"><span class="toc-text">Mysql的索引结构原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB%E7%9A%84%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E5%92%8CMyIsam%E7%9A%84%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">InnoDB的索引结构和MyIsam的索引结构有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E5%88%97%E4%B8%8D%E9%80%82%E5%90%88%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-text">哪些列不适合创建索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E5%9B%A0%E7%B4%A0%E4%BC%9A%E9%80%A0%E6%88%90%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-text">哪些因素会造成索引失效</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95-%E4%BB%80%E4%B9%88%E6%98%AF%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-text">什么是辅助索引&amp;什么是覆盖索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E4%B9%9F%E5%AD%98%E6%95%B0%E6%8D%AE%E5%90%97"><span class="toc-text">InnoDB辅助索引的叶子节点也存数据吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99"><span class="toc-text">组合索引的匹配原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Like%E4%B8%80%E5%AE%9A%E4%BC%9A%E8%AE%A9%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%90%97"><span class="toc-text">Like一定会让索引失效吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E7%9A%84%E5%8E%9F%E5%88%99%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">索引创建的原则有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFmysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E3%80%81%E8%A7%A6%E5%8F%91%E5%99%A8%EF%BC%9F"><span class="toc-text">什么是mysql存储过程、触发器？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96"><span class="toc-text">数据库优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E5%9B%A0%E7%B4%A0%E5%8F%AF%E8%83%BD%E4%BC%9A%E9%80%A0%E6%88%90%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="toc-text">哪些因素可能会造成数据库性能问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mysql%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84"><span class="toc-text">Mysql的执行流程是怎么样的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96SQL%E4%BD%A0%E4%BB%8E%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%E7%9D%80%E6%89%8B"><span class="toc-text">优化SQL你从哪些方面着手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%8E%BB%E5%AE%9A%E4%BD%8D%E6%85%A2SQL"><span class="toc-text">如何去定位慢SQL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E4%B8%8A%E5%8F%91%E8%B5%B7%E7%9A%84%E4%B8%80%E4%B8%AA%E6%9F%A5%E8%AF%A2%E5%BE%88%E6%85%A2%EF%BC%8C%E4%BD%A0%E6%80%8E%E4%B9%88%E5%8E%BB%E4%BC%98%E5%8C%96"><span class="toc-text">页面上发起的一个查询很慢，你怎么去优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E5%A6%82%E4%BD%95%E7%9C%8BSQL%E6%9C%89%E6%B2%A1%E6%9C%89%E5%91%BD%E4%B8%AD%E7%B4%A2%E5%BC%95"><span class="toc-text">你如何看SQL有没有命中索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9"><span class="toc-text">mysql存储引擎有哪些，有什么区别，如何选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-text">什么是全文索引？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E9%9D%A2SQL%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96"><span class="toc-text">下面SQL如何优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3"><span class="toc-text">事务相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1"><span class="toc-text">什么是事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-text">事务的四大特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6"><span class="toc-text">事务的传播机制:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E6%8C%81%E4%B9%85%E6%80%A7%E7%9A%84"><span class="toc-text">InnoDB如何保证原子性和持久性的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">事务并发问题有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%88%86%E5%88%AB%E8%83%BD%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-text">事务隔离级别有哪些，分别能解决什么问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySql%E7%9A%84InnoDB%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%E7%9A%84"><span class="toc-text">MySql的InnoDB是如何保证原子性的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySql%E7%9A%84InnoDB%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%8C%81%E4%B9%85%E6%80%A7%E7%9A%84"><span class="toc-text">MySql的InnoDB是如何保证持久性的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-Undolog-Redolog"><span class="toc-text">说一下事务的执行流程(Undolog+Redolog)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E4%B8%A2%E5%A4%B1%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98%EF%BC%8C%C2%B7%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-text">解释一下事务并发丢失更新问题，·如何解决</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">InnoDB事务隔离的实现原理是什么</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E7%BE%A4"><span class="toc-text">数据库集群</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Mysql%E4%B8%BB%E4%BB%8E%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%8C%E4%B8%8D%E8%83%BD%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">Mysql主从解决什么问题，不能解决什么问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">MySql主从复制原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySql%E4%B8%BB%E4%BB%8E%E9%85%8D%E7%BD%AE%E6%AD%A5%E9%AA%A4%EF%BC%9F"><span class="toc-text">MySql主从配置步骤？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%82%E7%9B%B4%E5%88%86%E8%A1%A8%EF%BC%8C%E5%9E%82%E7%9B%B4%E5%88%86%E5%BA%93%EF%BC%8C%E6%B0%B4%E5%B9%B3%E5%88%86%E8%A1%A8%EF%BC%8C%E6%B0%B4%E5%B9%B3%E5%88%86%E5%BA%93"><span class="toc-text">什么是垂直分表，垂直分库，水平分表，水平分库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%90%8E%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-text">分库分表后会出现哪些问题？怎么解决</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E4%BB%AC%E5%85%AC%E5%8F%B8%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E6%8A%80%E6%9C%AF%E6%9D%A5%E6%B0%B4%E5%B9%B3%E5%88%86%E8%A1%A8%EF%BC%9F%E8%BF%98%E5%8F%AF%E4%BB%A5%E6%9C%89%E4%BB%80%E4%B9%88%E6%8A%80%E6%9C%AF%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">你们公司使用的是什么技术来水平分表？还可以有什么技术？有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E4%BB%AC%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E8%A7%84%E5%88%99%E6%9D%A5%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84%EF%BC%9F%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%84%E5%88%99%EF%BC%9F"><span class="toc-text">你们使用什么规则来分库分表的？还有哪些规则？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E4%BB%8E%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%E5%8E%BB%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F"><span class="toc-text">你从哪些方面去优化你的数据库？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mysql%E7%9A%84%E9%9B%86%E7%BE%A4%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-text">Mysql的集群有哪些模式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E6%9C%BA%E4%BC%98%E5%8C%96%E5%88%B0%E6%9E%81%E8%87%B4%E4%BA%86%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-text">单机优化到极致了，可以怎么优化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%9C%BA%E4%BC%98%E5%8C%96%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">多机优化有哪些方式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84%E5%90%AB%E4%B9%89%EF%BC%9F"><span class="toc-text">解释一下分库分表的含义？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E5%88%86%E8%A1%A8%E6%9C%89%E5%93%AA%E4%BA%9B%E5%88%86%E8%A1%A8%E8%A7%84%E5%88%99%EF%BC%9F"><span class="toc-text">水平分表有哪些分表规则？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%BD%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8shardingjdbc%E5%81%9A%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E7%9A%84%E5%98%9B"><span class="toc-text">能简单说一下你怎么使用shardingjdbc做读写分离的嘛</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%BD%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8shardingjdbc%E5%81%9A%E8%AF%BB%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84%E5%98%9B"><span class="toc-text">能简单说一下你怎么使用shardingjdbc做读分库分表的嘛</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E7%AF%87"><span class="toc-text">JVM篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E4%BB%AC%E7%94%A8%E4%BB%80%E4%B9%88%E5%B7%A5%E5%85%B7%E7%9B%91%E6%8E%A7JVM"><span class="toc-text">你们用什么工具监控JVM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B"><span class="toc-text">JVM类加载流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%89%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%88%86%E5%88%AB%E5%8A%A0%E8%BD%BD%E4%BB%80%E4%B9%88%E4%B8%9C%E8%A5%BF%EF%BC%8C%E7%94%A8%E5%88%B0%E4%BB%80%E4%B9%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-text">JVM类加载器有几种类型，分别加载什么东西，用到什么设计模式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JVM%E7%BB%84%E6%88%90%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BB%96%E4%BB%AC%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">JVM组成，以及他们的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8JVM%E5%B1%82%E9%9D%A2%EF%BC%8C%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84"><span class="toc-text">在JVM层面，一个线程是如何执行的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%BA%86%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98%E5%87%BA%E5%9C%A8%E5%93%AA%E5%84%BF%EF%BC%9F"><span class="toc-text">程序内存溢出了，如何定位问题出在哪儿？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95"><span class="toc-text">垃圾标记算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-text">垃圾回收算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">垃圾回收器有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Minor-GC%E5%92%8CFull-GC"><span class="toc-text">Minor GC和Full GC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JVM%E4%BC%98%E5%8C%96%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">JVM优化的目的是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E6%80%8E%E4%B9%88%E8%B0%83%EF%BC%8C%E6%A0%88%E6%80%8E%E4%B9%88%E8%B0%83"><span class="toc-text">堆怎么调，栈怎么调</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E4%BE%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">什么是单例，如何实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">模板模式的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-text">什么是适配器模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%9F%E6%9C%89%E5%87%A0%E7%A7%8D%E4%BB%A3%E7%90%86%EF%BC%9F"><span class="toc-text">什么是代理模式？有几种代理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8CCGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">JDK动态代理和CGLIB动态代理的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%B4%E4%B8%80%E4%B8%8B"><span class="toc-text">常见的设计模式说一下</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%88%86%E7%B1%BB"><span class="toc-text">数据结构有哪几种分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">数组和链表在内存中的存储结构有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%95%A3%E5%88%97%E5%AD%98%E5%82%A8-Hash%E5%AD%98%E5%82%A8-%EF%BC%8C-%E4%BB%80%E4%B9%88%E6%98%AFHash%E5%86%B2%E7%AA%81-%EF%BC%8C-%E6%9C%89%E4%BB%80%E4%B9%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">说一下散列存储(Hash存储) ， 什么是Hash冲突 ， 有什么解决方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-%E6%95%B0%E7%BB%84%EF%BC%8C%E9%93%BE%E8%A1%A8%EF%BC%8C%E5%BE%AA%E7%8E%AF%EF%BC%8C%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">说说 数组，链表，循环，嵌套循环的时间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK%E4%B8%AD%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E7%9A%84%E9%9B%86%E5%90%88%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">JDK中线性结构的集合有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E5%AF%B9%E6%AF%94%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">你说一下树形结构对比线性结构的优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%A0%91%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BD%A0%E5%AF%B9%E5%AE%83%E4%BB%AC%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">说一下树的分类，以及你对它们的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E6%98%AF%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%87%BA%E7%8E%B0%E5%A4%9A%E5%8F%89%E6%A0%91"><span class="toc-text">有是二叉树为什么要出现多叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-tree%E5%92%8Cb-tree%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">B-tree和b+tree的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8BES%E7%94%A8%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">说一下ES用到了什么数据结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E9%A1%B9%E7%9B%AE%E9%83%A8%E5%88%86"><span class="toc-text">五.项目部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E5%9F%9F%E5%90%8D%EF%BC%8C%E5%AE%83%E6%98%AF%E6%80%8E%E4%B9%88%E5%8E%BB%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F"><span class="toc-text">浏览器输入一个域名，它是怎么去执行的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%9C%A8%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F"><span class="toc-text">请求在你的项目中是怎么执行的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9Czuul%E7%BD%91%E5%85%B3%E6%8C%82%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-text">如果zuul网关挂了怎么办？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%9C%89%E4%BA%BA%E7%94%A8%E8%84%9A%E6%9C%AC%E5%88%B7%E4%BD%A0%E4%BB%AC%E7%9A%84%E7%9F%AD%E4%BF%A1%E6%8E%A5%E5%8F%A3%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-text">如果有人用脚本刷你们的短信接口怎么办</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D"><span class="toc-text">非对称加密，什么是数字签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oauth2%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%8E%88%E6%9D%83%E6%A8%A1%E5%BC%8F"><span class="toc-text">Oauth2的四种授权模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E6%B1%82%E6%AF%8F%E5%A4%A9%E6%97%A9%E4%B8%8A-1%E7%82%B9%E7%BB%9F%E8%AE%A1%E5%89%8D%E4%B8%80%E5%A4%A9%E7%9A%84%E5%B9%B3%E5%8F%B0%E6%B3%A8%E5%86%8C%E4%BA%BA%E6%95%B0%EF%BC%8C%E6%80%8E%E4%B9%88%E5%81%9A"><span class="toc-text">要求每天早上 1点统计前一天的平台注册人数，怎么做</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Quzrtz%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%81%9A%E8%AE%A2%E5%8D%95%E8%B6%85%E6%97%B6%E5%85%B3%E5%8D%95%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-text">使用Quzrtz定时任务做订单超时关单有什么问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%81%9A%E8%BF%87%E7%9A%84%E6%AF%94%E8%BE%83%E5%A4%8D%E6%9D%82%E7%9A%84%E4%B8%9A%E5%8A%A1"><span class="toc-text">讲一下你做过的比较复杂的业务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRBAC-%EF%BC%8C-%E7%9B%B8%E5%85%B3%E8%A1%A8%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1%E7%9A%84%EF%BC%9F"><span class="toc-text">什么是RBAC ， 相关表怎么设计的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8VUE%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AFMVVM"><span class="toc-text">在VUE中，什么是MVVM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B2%E5%87%A0%E4%B8%AAVUE%E7%9A%84%E6%8C%87%E4%BB%A4"><span class="toc-text">讲几个VUE的指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#webpack%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">webpack的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">Vue的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vue%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E5%88%86%E4%B8%BA%E5%87%A0%E7%A7%8D%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">Vue中定义组件分为几种，有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8B%E4%BD%A0%E7%94%A8%E8%BF%87ElementUI%E7%9A%84%E5%93%AA%E4%BA%9B%E7%BB%84%E4%BB%B6"><span class="toc-text">讲一下你用过ElementUI的哪些组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E4%BB%ACRedis%E5%81%9A%E7%99%BB%E5%BD%95%E6%98%AF%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E8%BF%87%E6%9C%9F%E7%9A%84%EF%BC%9F"><span class="toc-text">你们Redis做登录是怎么处理登录信息过期的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8B%E4%BD%A0%E4%BB%AC%E7%9A%84%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88"><span class="toc-text">讲一下你们的登录实现方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B%E8%AE%B2%E4%B8%80%E4%B8%8B"><span class="toc-text">三方登录流程讲一下</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%EF%BC%8C%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">讲一下什么是非对称加密，什么是数字签名，数字签名的作用是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%AC%E4%B8%9C%E7%9A%84%E9%A6%96%E9%A1%B5%E7%9A%84%E5%95%86%E5%93%81%E5%88%86%E7%B1%BB%EF%BC%8C%E8%AE%A9%E4%BD%A0%E8%AE%BE%E8%AE%A1%E8%A1%A8%EF%BC%8C%E4%BD%A0%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1"><span class="toc-text">京东的首页的商品分类，让你设计表，你怎么设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E8%AF%A2%E5%87%BA%E6%A0%91%E7%8A%B6%E7%BB%93%E6%9E%84%E7%9A%84%E8%AF%BE%E7%A8%8B%E5%88%86%E7%B1%BB%E6%95%B0%E6%8D%AE"><span class="toc-text">如何查询出树状结构的课程分类数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E4%BB%AC%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8Redis%E7%BC%93%E5%AD%98%E4%BA%86%E5%93%AA%E4%BA%9B%E4%B8%9C%E8%A5%BF%EF%BC%9F%E7%94%A8Redis%E7%9A%84%E4%BB%80%E4%B9%88%E7%BB%93%E6%9E%84%E5%8E%BB%E5%AD%98%E5%82%A8%E7%9A%84%EF%BC%9F"><span class="toc-text">你们系统使用Redis缓存了哪些东西？用Redis的什么结构去存储的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B%E5%8F%91%E5%B8%83%E6%B5%81%E7%A8%8B%E8%AE%B2%E4%B8%80%E4%B8%8B"><span class="toc-text">课程发布流程讲一下</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E4%BB%AC%E8%AF%BE%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E8%A1%A8%E6%98%AF%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1%E7%9A%84%EF%BC%9F%E4%B8%BB%E8%A6%81%E7%9A%84%E5%AD%97%E6%AE%B5%E8%AF%B4%E4%B8%80%E4%B8%8B"><span class="toc-text">你们课程相关的表是怎么设计的？主要的字段说一下</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8B%E4%BD%A0%E4%BB%AC%E8%BF%99%E4%B8%AA%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%BB%E7%BA%BF%E4%B8%9A%E5%8A%A1"><span class="toc-text">讲一下你们这个项目的主线业务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E4%BB%AC%E9%A1%B9%E7%9B%AE%E6%9C%80%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="toc-text">你们项目最大并发是多少</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E4%BB%AC%E9%A1%B9%E7%9B%AE%E6%9C%80%E5%A4%A7%E8%A1%A8%E6%95%B0%E9%87%8F%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="toc-text">你们项目最大表数量是多少</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E4%BB%AC%E8%AF%BE%E7%A8%8B%E6%90%9C%E7%B4%A2%E7%9A%84%E9%82%A3%E4%B8%AA%E4%B8%9A%E5%8A%A1%E6%96%B9%E6%B3%95%E7%9A%84%E5%A4%A7%E8%87%B4%E9%80%BB%E8%BE%91"><span class="toc-text">.说一下你们课程搜索的那个业务方法的大致逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%B9%B6%E5%8F%91%E9%AB%98%E5%A4%84%E7%90%86%E8%BF%87%E4%B8%8D%E8%BF%87%E6%9D%A5%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-text">项目并发高处理过不过来怎么办</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8B%E4%BD%A0%E4%BB%AC%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8E%88%E6%9D%83%E6%96%B9%E6%A1%88-%E4%BD%A0%E8%BF%98%E7%9F%A5%E9%81%93%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%A1%88%E5%90%97%EF%BC%9F"><span class="toc-text">讲一下你们的微服务授权方案 你还知道有哪些方案吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oauth2%E7%9A%84%E6%8E%88%E6%9D%83%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%88%86%E5%88%AB%E4%BD%BF%E7%94%A8%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-text">Oauth2的授权模式有哪些，分别使用在什么场景？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oauth2%E8%AE%A4%E8%AF%81%EF%BC%8C%E5%A6%82%E6%9E%9CToken%E8%BF%87%E6%9C%9F%E4%BA%86%E4%BD%A0%E4%BB%AC%E6%98%AF%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E7%9A%84"><span class="toc-text">Oauth2认证，如果Token过期了你们是怎么处理的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oauth2%E8%AE%A4%E8%AF%81%EF%BC%8C%E5%A6%82%E6%9E%9CToken%E8%A2%AB%E7%9B%97%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-text">Oauth2认证，如果Token被盗了怎么办？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E8%AF%A6%E7%BB%86%E8%AF%B4%E4%B8%80%E4%B8%8B"><span class="toc-text">秒杀的整体流程详细说一下</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%B5%81%E9%87%8F%E6%9B%B4%E9%AB%98%EF%BC%8C%E6%AF%94%E5%A6%82%EF%BC%9A%E6%AF%8F%E7%A7%9210W%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="toc-text">如果流量更高，比如：每秒10W请求，应该怎么处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%94%AF%E4%BB%98%E8%B6%85%E6%97%B6%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88%EF%BC%9F%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E5%92%8C%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="toc-text">说一下支付超时处理方案？延迟队列和死信队列是什么意思？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E4%B8%AA%E7%A7%92%E6%9D%80%E6%B5%81%E7%A8%8B%E4%BD%A0%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E9%98%9F%E5%88%97"><span class="toc-text">整个秒杀流程你用到了哪些队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E6%88%90%E5%8A%9F%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%BB%99%E7%94%A8%E6%88%B7%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">秒杀成功，返回给用户的数据是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E4%BB%AC%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E8%B6%85%E5%8D%96"><span class="toc-text">你们怎么处理超卖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%8E%A5%E5%8F%A3%E7%9A%84qps"><span class="toc-text">如何提高接口的qps</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E4%BB%AC%E8%BF%99%E4%B8%AA%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E6%98%AF%E6%80%8E%E4%B9%88%E9%83%A8%E7%BD%B2%E7%9A%84"><span class="toc-text">你们这个前后端分离项目是怎么部署的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-text">前后端分离的好处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E4%BB%AC%E7%94%A8%E4%BB%80%E4%B9%88%E5%81%9A%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E7%9A%84"><span class="toc-text">你们用什么做项目代码管理的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2Git%E7%9B%B8%E5%AF%B9%E4%BA%8ESVN%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">讲讲Git相对于SVN的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E4%BB%AC%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E6%80%8E%E4%B9%88%E9%83%A8%E7%BD%B2"><span class="toc-text">你们微服务项目怎么部署</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B2%E5%87%A0%E4%B8%AAGit%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="toc-text">讲几个Git的命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E8%BF%90%E7%BB%B4%E7%AF%87"><span class="toc-text">六.运维篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#linux"><span class="toc-text">linux</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E4%BD%BF%E7%94%A8%E8%BF%87linux%E5%90%97-%EF%BC%8C-%E8%AE%B2%E5%87%A0%E4%B8%AA%E5%91%BD%E4%BB%A4"><span class="toc-text">有使用过linux吗 ， 讲几个命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E5%87%A0%E4%B8%AA%E6%A0%B8%E5%BF%83%E7%9B%AE%E5%BD%95"><span class="toc-text">Linux根目录下的几个核心目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E6%97%A5%E5%87%8C%E6%99%A8%E9%9B%B6%E7%82%B9%E9%9B%B6%E5%88%86%E5%AE%9A%E6%9C%9F%E5%A4%87%E4%BB%BD-user-backup%E5%88%B0-tmp-%E7%9B%AE%E5%BD%95%E4%B8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E5%81%9A"><span class="toc-text">周日凌晨零点零分定期备份 &#x2F;user&#x2F;backup到 &#x2F;tmp 目录下，如何做?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux%E4%B8%AD%E4%BD%A0%E6%80%8E%E4%B9%88%E6%8E%92%E6%9F%A5%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98%EF%BC%9F%E6%9F%A5%E7%9C%8B%E9%A1%B9%E7%9B%AE%E6%97%A5%E5%BF%97%E4%BD%A0%E4%B8%80%E8%88%AC%E6%80%8E%E4%B9%88%E5%81%9A"><span class="toc-text">Linux中你怎么排查项目问题？查看项目日志你一般怎么做?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B"><span class="toc-text">怎么查看进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4"><span class="toc-text">常用的压缩命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2%E8%BF%87%E9%A1%B9%E7%9B%AE%E4%B9%88%EF%BC%9F%E5%A4%A7%E6%A6%82%E8%AE%B2%E4%B8%80%E8%AE%B2%E5%A6%82%E4%BD%95%E9%83%A8%E7%BD%B2%E7%9A%84"><span class="toc-text">部署过项目么？大概讲一讲如何部署的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E4%BB%AC%E8%BF%99%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84"><span class="toc-text">你们这个服务器的配置是怎么样的</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker"><span class="toc-text">Docker</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2%E4%BB%80%E4%B9%88%E6%98%AFDocker"><span class="toc-text">讲讲什么是Docker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B2%E5%87%A0%E4%B8%AADocker%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="toc-text">讲几个Docker的命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E6%8A%8A%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%88%B0%E5%AE%B9%E5%99%A8%E4%B8%AD"><span class="toc-text">怎么把文件上传到容器中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#docker%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">docker常见面试题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%90%E4%B8%AA%E6%9C%8D%E5%8A%A1%E4%B8%8D%E5%8F%AF%E8%AE%BF%E9%97%AE%E4%BA%86%E4%BD%A0%E6%80%8E%E4%B9%88%E6%8E%92%E6%9F%A5"><span class="toc-text">某个服务不可访问了你怎么排查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4%E6%80%8E%E4%B9%88%E9%80%9A%E4%BF%A1"><span class="toc-text">容器之间怎么通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8ERedis%E5%92%8Czuul%E7%BD%91%E5%85%B3%E4%BD%A0%E6%80%8E%E4%B9%88%E9%83%A8%E7%BD%B2"><span class="toc-text">对于Redis和zuul网关你怎么部署</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/breeze/1d13ce0d.html" title="WYDG-产品目录列表-20200506"><img src="/img/photo-1653549892896-dde02867edee.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="WYDG-产品目录列表-20200506"></a><div class="content"><a class="title" href="/breeze/1d13ce0d.html" title="WYDG-产品目录列表-20200506">WYDG-产品目录列表-20200506</a><time datetime="2025-04-13T05:43:05.000Z" title="发表于 2025-04-13 13:43:05">2025-04-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/breeze/6f268337.html" title="雨雀文件下载"><img src="/img/premium_photo-1695185954894-e9382c6f4da8.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="雨雀文件下载"></a><div class="content"><a class="title" href="/breeze/6f268337.html" title="雨雀文件下载">雨雀文件下载</a><time datetime="2024-05-22T12:25:08.000Z" title="发表于 2024-05-22 20:25:08">2024-05-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/breeze/7832219d.html" title="十万字面试总结"><img src="/img/photo-1692708632140-ee01624d558d.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="十万字面试总结"></a><div class="content"><a class="title" href="/breeze/7832219d.html" title="十万字面试总结">十万字面试总结</a><time datetime="2024-02-29T02:50:00.000Z" title="发表于 2024-02-29 10:50:00">2024-02-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/breeze/7ae0ca37.html" title="Redis_30道经典面试题"><img src="/img/photo-1653549892896-dde02867edee.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Redis_30道经典面试题"></a><div class="content"><a class="title" href="/breeze/7ae0ca37.html" title="Redis_30道经典面试题">Redis_30道经典面试题</a><time datetime="2024-02-29T02:45:00.000Z" title="发表于 2024-02-29 10:45:00">2024-02-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/breeze/2a548e97.html" title="面试实战"><img src="/img/photo-1653549892896-dde02867edee.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="面试实战"></a><div class="content"><a class="title" href="/breeze/2a548e97.html" title="面试实战">面试实战</a><time datetime="2024-02-29T02:43:59.000Z" title="发表于 2024-02-29 10:43:59">2024-02-29</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/img/premium_photo-1695185954894-e9382c6f4da8.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 <i id="heartbeat" class="fa fas fa-heartbeat"></i> 清风</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></head></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script src="/js/timing.js"></script><script id="canvas_nest" defer color="255,0,255" opacity="0.7" zindex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!0,document.body.addEventListener("input",POWERMODE)</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="天枢,天璇,天玑,天权,玉衡,开阳,瑶光" data-fontsize="15px" data-random="true" async></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>