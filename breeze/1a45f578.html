<!DOCTYPE html><html class="hide-aside" lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>JVM优化 | 清风</title><meta name="author" content="清风"><meta name="copyright" content="清风"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JVM优化内容– jvm概述  结构  有问题  优化 jvm概述  Jvm组成(概要)   对组成部分进行优化  垃圾回收  jvm优化实战   一.JVM组成1.JVM概述1.1.什么是JVM​	与JVM的初次见面,是在我们Java SE课程的开始,讲解Java跨平台原理的时候.时隔多日,我们先来回顾一下. Java的广告语是,”编写一次,到处运行”,而它凭借的就是JVM(Java Virtu"><meta property="og:type" content="article"><meta property="og:title" content="JVM优化"><meta property="og:url" content="https://mliutm.github.io/breeze/1a45f578.html"><meta property="og:site_name" content="清风"><meta property="og:description" content="JVM优化内容– jvm概述  结构  有问题  优化 jvm概述  Jvm组成(概要)   对组成部分进行优化  垃圾回收  jvm优化实战   一.JVM组成1.JVM概述1.1.什么是JVM​	与JVM的初次见面,是在我们Java SE课程的开始,讲解Java跨平台原理的时候.时隔多日,我们先来回顾一下. Java的广告语是,”编写一次,到处运行”,而它凭借的就是JVM(Java Virtu"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://mliutm.github.io/img/photo-1645943020355-305df166473d.jpg"><meta property="article:published_time" content="2024-01-14T07:33:00.000Z"><meta property="article:modified_time" content="2024-01-15T08:20:33.515Z"><meta property="article:author" content="清风"><meta property="article:tag" content="JVM优化"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://mliutm.github.io/img/photo-1645943020355-305df166473d.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://mliutm.github.io/breeze/1a45f578.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,top_n_per_article:1,unescape:!1,languages:{hits_empty:"找不到您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!1,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"JVM优化",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-01-15 16:20:33"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,a){0!==a&&(a=864e5*a,t={value:t,expiry:(new Date).getTime()+a},localStorage.setItem(e,JSON.stringify(t)))},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!((new Date).getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=o=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.getCSS=(o,n=!1)=>new Promise((t,e)=>{const a=document.createElement("link");a.rel="stylesheet",a.href=o,n&&(a.id=n),a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">153</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">76</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/img/photo-1645943020355-305df166473d.jpg)"><nav id="nav"><span id="blog-info"><a href="/" title="清风"><span class="site-name">清风</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JVM优化</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-14T07:33:00.000Z" title="发表于 2024-01-14 15:33:00">2024-01-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-15T08:20:33.515Z" title="更新于 2024-01-15 16:20:33">2024-01-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E8%83%BD%E6%8F%90%E5%8D%87/">技能提升</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>45分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="JVM优化"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="JVM优化"><a href="#JVM优化" class="headerlink" title="JVM优化"></a>JVM优化</h1><h2 id="内容–-jvm概述-结构-有问题-优化"><a href="#内容–-jvm概述-结构-有问题-优化" class="headerlink" title="内容– jvm概述  结构  有问题  优化"></a>内容– jvm概述 结构 有问题 优化</h2><ul><li><p>jvm概述</p></li><li><p>Jvm组成(概要)</p></li><li><p>对组成部分进行优化</p></li><li><p>垃圾回收</p></li><li><p>jvm优化实战</p></li></ul><h2 id="一-JVM组成"><a href="#一-JVM组成" class="headerlink" title="一.JVM组成"></a>一.JVM组成</h2><h3 id="1-JVM概述"><a href="#1-JVM概述" class="headerlink" title="1.JVM概述"></a>1.JVM概述</h3><h4 id="1-1-什么是JVM"><a href="#1-1-什么是JVM" class="headerlink" title="1.1.什么是JVM"></a>1.1.什么是JVM</h4><p>​	与JVM的初次见面,是在我们Java SE课程的开始,讲解Java跨平台原理的时候.时隔多日,我们先来回顾一下.</p><p><strong>Java的广告语是,”编写一次,到处运行”,而它凭借的就是JVM(Java Virtual Machine).而对于不同的平台Windows,Linux,Mac OS等,有具体不同的JVM版本.这些JVM屏蔽了平台的不同,提供了统一的运行环境,让Java代码无需考虑平台的差异,运行在不同的环境中.</strong></p><p>而至于JRE和JDK,就不再赘述了,包含关系应该很清楚的,而今天我们的重点就在于对JVM的进一步认识以及对它进行优化调整.</p><p>jvm–&gt;jre—&gt;jdk</p><p><img src="/breeze/1a45f578/1679882371562.png" alt="1679882371562"></p><p>java跨平台原理??</p><p>​ java为各平台提供jvm,通过jvm屏蔽系统差异,进而我们可以编写统一代码. 到时候如果我们想要把字节码(java代理编译后得到的)运行到某平台,,也就是要在对应的平台先安装对应jvm,再在jvm上面运行我们的java程序.</p><p>​ <strong>统一java配合各平台jvm,就可以让我们代码在各平台运行!!!!</strong></p><p>​ 简单说一下jvm?</p><p>​ jvm叫做java虚拟机,我们的java程序需要运行在jvm上.是实现跨平台关键. java为各平台提供jvm,通过jvm屏蔽系统差异,进而我们可以编写统一代码. 到时候如果我们想要把字节码(java代理编译后得到的)运行到某平台,,也就是要在对应的平台先安装对应jvm,再在jvm上面运行我们的java程序.</p><p>你是怎么用spring? 用spring其实就是用spring两大核心,ioc,aop</p><h4 id="1-2-为什么要优化JVM"><a href="#1-2-为什么要优化JVM" class="headerlink" title="1.2.为什么要优化JVM"></a>1.2.为什么要优化JVM</h4><p>​	正如前面我们所回顾的,我们的<strong>Java代码都是运行在JVM中的</strong>,而部署的硬件及应用场景有所不同时,仍然采用默认的配置不见得能起到最好的效果,甚至可能会导致运行效率更差,又或者面临高并发情况下,想让程序平稳顺畅的运行,所以我们需要针对实际的需要来进行优化.</p><p>​	<strong>所谓优化就是配置一些jvm参数，让jvm运行时使用这些参数，让在jvm运行的程序更加良好的运行。</strong></p><p><strong>如果使用默认配置,资源得不到最优分配.</strong></p><p><img src="/breeze/1a45f578/1679882878502.png" alt="1679882878502"></p><p>人—-&gt;房子(适合这个居住)</p><h3 id="2-JVM分析的常用工具"><a href="#2-JVM分析的常用工具" class="headerlink" title="2.JVM分析的常用工具"></a>2.JVM分析的常用工具</h3><p>jps : 查看java的进程 ps:查看进程</p><p>jconsole:java控制台,可以看到jvm的一些信息</p><p>jvisualvm: java可视化虚拟机</p><h4 id="2-1-分析工具"><a href="#2-1-分析工具" class="headerlink" title="2.1.分析工具"></a>2.1.分析工具</h4><p>我们只知道有JVM的存在,但它的运行对于我们来说感觉像是摸不着看不见的,所以我们需要借助工具来监控它的一个实时状态,就像Windows的性能监视器一样,JDK也有自己的可视化工具.Java提供了2个监视工具：</p><ul><li><p>D:\opensource\jdk1.8\bin\jconsole.exe</p></li><li><p>D:\opensource\jdk1.8\bin\jvisualvm.exe</p></li></ul><p>我们以管理员身份运行DOS ，输入<strong>jvisualvm</strong>,将Java VisualVM启动</p><p><img src="/breeze/1a45f578/1635927573561.png" alt="1635927573561"></p><p>本地列表中有多个条目,而一眼也可以看到我们SpringBoot项目的main方法,直接双击，经过短时间的加载后,得到这样一个界面</p><p><img src="/breeze/1a45f578/1635927666177.png" alt="1635927666177"></p><h4 id="2-2-jvisualvm安装GC插件"><a href="#2-2-jvisualvm安装GC插件" class="headerlink" title="2.2.jvisualvm安装GC插件"></a>2.2.jvisualvm安装GC插件</h4><p>自带的jvisualvm没有监视GC垃圾回收功能，我们需要额外安装插件：</p><p>打开工具 -&gt; 插件 -&gt; 选择“可用插件”页 : 我们在这里安装一个Visual GC，方便我们看到内存回收以及各个分代的情况 . 打上勾之后点击安装，就是常规的next以及同意协议等 ，网络不是很稳定，有时候可能需要多尝试几次。可以在设置中修改插件中心地址：</p><p><img src="/breeze/1a45f578/wps3516.tmp.jpg" alt="img"></p><p>根据如下步骤修改地址：找到插件中心</p><p><a target="_blank" rel="noopener" href="http://visualvm.github.io/pluginscenters.html">http://visualvm.github.io/pluginscenters.html</a></p><p><img src="/breeze/1a45f578/wps3517.tmp.jpg" alt="img"></p><p>找到对应的JDK版本：</p><p><a target="_blank" rel="noopener" href="http://visualvm.github.io/pluginscenters.html">http://visualvm.github.io/pluginscenters.html</a></p><p>复制插件地址：</p><p><img src="/breeze/1a45f578/1679884033783.png" alt="1679884033783"></p><p>安装插件：</p><p><img src="/breeze/1a45f578/1679884094416.png" alt="1679884094416"></p><p>然后再 可用插件中 找到 Visual GC</p><p>安装完成后我们将当前监控页关掉，再次打开，就可以看到Profiler后面多了一个Visual GC页。</p><p><img src="/breeze/1a45f578/1679884110135.png" alt="1679884110135"></p><p>在这里我们可以看到JIT活动时间，类加载活动时间，GC活动时间以及各个分代的情况。</p><p>需要注意的是,当前课件使用的JDK版本为1.8,仍然自带了VisualVM,从1.9开始的版本是没有自带的,需要额外下载,下载的github地址:</p><p><a target="_blank" rel="noopener" href="https://visualvm.github.io/download.html">https://visualvm.github.io/download.html</a></p><p>另外,如果开发工具使用的是Intellij IDEA的话,可以下载一个插件,VisualVM Launcher,通过插件启动可以直接到上述页面,不用在左边的条目中寻找自己的项目.</p><p>当然也有其他的工具,但这个在可预见的未来都会是主力发展的多合一故障处理工具.所以我们后面将会使用这个工具来分析我们的JVM运行情况,进而优化.而需要优化我们还需要对JVM的组成有进一步的了解.接下来我们来看一下JVM的组成</p><h3 id="3-JVM组成"><a href="#3-JVM组成" class="headerlink" title="3.JVM组成"></a>3.JVM组成</h3><h4 id="3-1-JVM组成图-重点"><a href="#3-1-JVM组成图-重点" class="headerlink" title="3.1.JVM组成图  重点"></a>3.1.JVM组成图 重点</h4><p><img src="/breeze/1a45f578/1635927881021.png" alt="1635927881021"></p><p>从图上可以看到,大致分为以下组件:</p><ul><li><p>类加载器子系统 ：字节码加载</p></li><li><p>运行时数据区 : java程序运行涉及到的区域 <strong>jvm内存结构</strong></p></li><li><p>执行引擎 ：程序执行的引擎 即时编译器 垃圾回收</p></li><li><p>本地方法接口 ：接入其他语言lib库</p></li></ul><p>而本地库接口也就是用于调用本地方法的接口,在此我们不细说,主要关注的是上述的3个组件</p><h4 id="3-2-类加载子系统-重点"><a href="#3-2-类加载子系统-重点" class="headerlink" title="3.2.类加载子系统  重点"></a>3.2.类加载子系统 重点</h4><p>java中一切皆对象! 对象的创建依赖于类,也就是程序在运行时,要把相关的类的字节码(.class)加载进去.这时候就要用到类加载子系统.</p><h5 id="3-2-1类加载过程-面试题"><a href="#3-2-1类加载过程-面试题" class="headerlink" title="3.2.1类加载过程[面试题]"></a>3.2.1类加载过程[面试题]</h5><p>说一下类加载的过程</p><p>类加载的过程包括了加载,验证,准备,解析和初始化这5个步骤</p><ol><li><p>加载:<strong>找到字节码文件,读取到内存中</strong>.类的加载方式分为隐式加载和显示加载两种。隐式加载指的是程序在使用new关键词创建对象时，会隐式的调用类的加载器把对应的类加载到jvm中。显示加载指的是通过直接调用class.forName（）方法来把所需的类加载到jvm中。</p></li><li><p>验证:<strong>验证此字节码文件是不是真的是一个字节码文件</strong>,毕竟后缀名可以随便改,而内在的身份标识是不会变的.在确认是一个字节码文件后,还会检查一系列的是否可运行验证,元数据验证,字节码验证,符号引用验证等.Java虚拟机规范对此要求很严格,在Java 7的规范中,已经有130页的描述验证过程的内容.</p></li><li><p>准备:**为类中static修饰的变量分配内存空间并设置其初始值为0或null.**可能会有人感觉奇怪,在类中定义一个static修饰的int,并赋值了123,为什么这里还是赋值0.因为这个int的123是在初始化阶段的时候才赋值的,这里只是先把内存分配好.但如果你的static修饰还加上了final,那么就会在准备阶段就会赋值.</p><p>static: 定义时赋值 static{} 构造函数</p></li><li><p>解析:<strong>解析阶段会将java代码中的符号引用替换为直接引用</strong>.比如引用的是一个类,我们在代码中只有全限定名来标识它,在这个阶段会找到这个类加载到内存中的地址.</p></li><li><p><strong>初始化:如刚才准备阶段所说的,这个阶段就是对变量的赋初始值的阶段.</strong></p><p>static初始化:初始化语句(&#x3D;)或者初始化代码快(static)</p></li></ol><p>如上过程都是在JVM执行的过程中自己完成的，我们无需干涉。</p><p>非静态:</p><p><img src="/breeze/1a45f578/1679889088718.png" alt="1679889088718"></p><h5 id="3-2-2类加载机制"><a href="#3-2-2类加载机制" class="headerlink" title="3.2.2类加载机制"></a>3.2.2类加载机制</h5><p>​ 类的加载是由类加载器加载,先了解类加载器有哪些,再看他们是怎么协作加载.</p><p><strong>1.JVM中内置的类加载器：</strong></p><p><img src="/breeze/1a45f578/1635928028185.png" alt="1635928028185"></p><p>​	每一个类,都需要和它的类加载器一起确定其在JVM中的唯一性.换句话来说,不同类加载器加载的同一个字节码文件,得到的类都不相等.我们可以通过默认加载器去加载一个类,然后new一个对象,再通过自己定义的一个类加载器,去加载同一个字节码文件,拿前面得到的对象去instanceof,会得到的结果是false.</p><p>类加载器一般有4种,其中前3种是必然存在的</p><ul><li><p>启动类加载器:加载<jre_home>\lib下的</jre_home></p></li><li><p>扩展类加载器:加载<jre_home>\lib\ext下的</jre_home></p></li><li><p>应用程序类加载器:加载Classpath下的 ,<strong>我们的代码</strong>,<strong>还有依赖jar都是在classpat</strong>h,都是被它所加载</p></li><li><p>自定义类加载器</p></li></ul><p>1.类加载时使用了<strong>双亲</strong>委派模式：</p><p>加载规则，优先使用爷爷加载，如果没有加载到再使用它爹加载，如果他爹也没有加载到，才到自己加载，如果自己也没有加载到才报ClassNotFountException。在这过程中只要上一级加载到了，下一级就不会加载了，这麽做的目的：</p><ul><li><p>不让我们轻易覆盖java提供的类。 lib lib\ext不能改</p></li><li><p>也要让我们扩展三方功能。 可以修改三方jar里面class，写一个和他一样！改一下就行</p></li></ul><p><strong>2.而双亲委派机制是如何运作的呢?</strong></p><p>我们以应用程序类加载器举例,它在需要加载一个类的时候,不会直接去尝试加载,而是委托上级的扩展类加载器去加载,而扩展类加载器也是委托启动类加载器去加载.</p><p>​ 启动类加载器在自己的搜索范围内没有找到这么一个类,表示自己无法加载,就再让扩展类加载器去加载,同样的,扩展类加载器在自己的搜索范围内找一遍,如果还是没有找到,就委托应用程序类加载器去加载.如果最终还是没找到,那就会直接抛出异常了.</p><p><strong>3.而为什么要这么麻烦的从下到上,再从上到下呢?</strong></p><p>​	这是为了安全着想,保证按照优先级加载.如果用户自己编写一个名为java.lang.Object的类,放到自己的Classpath中,没有这种优先级保证,应用程序类加载器就把这个当做Object加载到了内存中,从而会引发一片混乱.而凭借这种双亲委派机制,先一路向上委托,启动类加载器去找的时候,就把正确的Object加载到了内存中,后面再加载自行编写的Object的时候,是不会加载运行的.</p><p><strong>总结: jvm类加载子系统是用来加载类的,类的加载要使用类加载器来加载.java提供种了多种类加载器,它使用双亲委派机制进行协调加载,主要有应用,扩展,启动三种类加载器,委派应用–&gt;扩展–&gt;启动.加载优先使用启动–&gt;扩展–&gt;应用.这样做的好处是不能轻易修改系统提供的类,但是可以扩展三方jar. 加载过程是加载,验证,准备,解析,初始化.</strong></p><h4 id="3-3运行时数据区-jvm内存结构-重点"><a href="#3-3运行时数据区-jvm内存结构-重点" class="headerlink" title="3.3运行时数据区-jvm内存结构-重点"></a>3.3运行时数据区-jvm内存结构-重点</h4><h5 id="3-3-1-运行时数据区组成"><a href="#3-3-1-运行时数据区组成" class="headerlink" title="3.3.1.运行时数据区组成"></a>3.3.1.运行时数据区组成</h5><p>jdk1.7</p><p><img src="/breeze/1a45f578/1635928330614.png" alt="1635928330614"></p><p>​	注意：堆和方法区是线程共享的，其他3个区域是线程隔离的</p><p><img src="/breeze/1a45f578/1635928444134.png" alt="1635928444134"></p><p><strong>JDK1.8及以后，方法区被元空间替代，没有方法区了，元空间直接使用本地内存而不是jvm内存</strong></p><h5 id="3-3-2-程序计数器"><a href="#3-3-2-程序计数器" class="headerlink" title="3.3.2.程序计数器"></a>3.3.2.程序计数器</h5><p>​	程序计数器是<strong>线程私有</strong>的,虽然名字叫计数器,但主要用途还是用来确定指令的执行顺序,比如循环,分支,跳转,异常捕获等.而JVM对于多线程的实现是通过轮流切换线程实现的,所以为了<code>保证每个线程都能按正确顺序执行</code>,将程序计数器作为线程私有.程序计数器是唯一一个JVM没有规定任何OOM的区块.（out of memory）</p><p>​	程序计数器是一块非常小的内存空间，<code>可以看做是当前线程执行字节码的行号指示器</code>，每个线程都有一个独立的程序计数器，因此程序计数器是线程私有的一块空间，此外，程序计数器是Java虚拟机规定的唯一不会发生内存溢出的区域</p><h5 id="3-3-3-Java虚拟机栈"><a href="#3-3-3-Java虚拟机栈" class="headerlink" title="3.3.3.Java虚拟机栈"></a>3.3.3.Java虚拟机栈</h5><p>​	Java虚拟机栈也是线程私有的,虚拟机会为<code>每个线程分配一个虚拟机栈，每个虚拟机栈中都有若干个栈帧,每个栈帧中存储了局部变量表、操作数栈、动态链接、返回地址等。</code>一个栈帧就对应Java代码中的一个方法，当线程执行到一个方法时，就代表这个方法对应的栈帧已经进入虚拟机栈并且处于栈顶的位置，每一个Java方法从被调用到执行结束，就对应了一个栈帧从入栈到出栈的过程&#96;。</p><p><img src="/breeze/1a45f578/1635928638517.png" alt="1635928638517"></p><p><img src="/breeze/1a45f578/1679899490504.png" alt="1679899490504"></p><ul><li><p>栈帧(方法执行形成栈帧)：栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构,线程私有。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用至执行完成的过程，都对应着一个栈帧在虚拟机栈里从入栈到出栈的过程，栈帧随着方法调用而创建，随着方法结束而销毁</p></li><li><p>局部变量表(储存方法参数和局部变量)：局部变量表(Local Variable Table)是一组变量值存储空间，<code>用于存放方法参数和方法内定义的局部变量</code>。局部变量表的容量以变量槽(Variable Slot)为最小单位，Java虚拟机规范并没有定义一个槽所应该占用内存空间的大小，但是规定了一个槽应该可以存放一个32位以内的数据类型。</p></li><li><p>操作数栈(用于计算的临时数据存储区)：操作数栈(Operand Stack)也常称为操作栈，它是一个后入先出栈(LIFO)，当一个方法刚刚开始执行时，其操作数栈是空的，随着方法执行和字节码指令的执行，会<code>从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈/入栈操作</code>。一个完整的方法执行期间往往包含多个这样出栈&#x2F;入栈的过程。</p></li><li><p>动态链接(用来转化方法的内存地址直接引用的)：在一个class文件中，一个方法要调用其他方法，</p><p>需要将这些方法的<code>符号引用转化为其在内存地址中的直接引用</code>，而符号引用存在于方法区中的运行时常量池。</p></li><li><p>返回地址:方法的返回地址</p></li></ul><h5 id="3-3-4-本地方法栈"><a href="#3-3-4-本地方法栈" class="headerlink" title="3.3.4.本地方法栈"></a>3.3.4.本地方法栈</h5><p>本地方法栈与虚拟机栈的区别是，虚拟机栈执行的是Java方法，<code>本地方法栈执行的是本地方法</code>（Native Method）,其他基本上一致，在HotSpot中直接把本地方法栈和虚拟机栈合二为一，这里暂时不做过多叙述。</p><p><a target="_blank" rel="noopener" href="https://xiaomogui.iteye.com/blog/857821">https://xiaomogui.iteye.com/blog/857821</a></p><h5 id="3-3-5方法区（1-6，1-7）-永久代"><a href="#3-3-5方法区（1-6，1-7）-永久代" class="headerlink" title="3.3.5方法区（1.6，1.7）-永久代"></a>3.3.5方法区（1.6，1.7）-永久代</h5><p>方法区主要用于存储虚拟机加载的<code>类信息、常量、静态变量，以及编译器编译后的代码</code>等数据。在jdk1.7及其之前，方法区是<code>堆的一个“逻辑部分”</code>（一片连续的堆空间），但为了与堆做区分，方法区还有个名字叫“非堆”，也有人用“永久代”（HotSpot对方法区的实现方法）来表示方法区。</p><p>从<code>jdk1.7已经开始准备“去永久代”</code>的规划，jdk1.7的HotSpot中，已经<code>把原本放在方法区中的静态变量、字符串常量池等移到堆内存中</code>，（常量池除字符串常量池还有class常量池等），这里只是把字符串常量池移到堆内存中；<code>在jdk1.8中，方法区已经不存在</code>，原方法区中存储的类信息、编译后的代码数据等已经移动到了元空间（MetaSpace）中，元空间并没有处于堆内存上，而是直接占用的本地内存（NativeMemory）。</p><p><img src="/breeze/1a45f578/wps2CEC.tmp.png" alt="img"></p><p>去永久代的原因有：</p><ul><li><p>字符串存在永久代中，容易出现性能问题和内存溢出。 –字符串是用得最多数据类型</p></li><li><p>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</p></li><li><p>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</p></li></ul><h5 id="3-3-6-堆内存"><a href="#3-3-6-堆内存" class="headerlink" title="3.3.6.堆内存"></a>3.3.6.堆内存</h5><p>​	堆和方法区一样(确切来说JVM规范中方法区就是堆的一个逻辑分区),就是<code>一个所有线程共享的,存放对象的区域,也是GC的主要区域.</code>其中的<code>分区分为新生代,老年代.新生代中又可以细分为一个Eden,两个Survivor区(From,To).Eden中存放的是通过new 或者newInstance方法创建出来的对象,绝大多数都是很短命的.正常情况下经历一次gc之后,存活的对象会转入到其中一个Survivor区,然后再经历默认15次的gc,就转入到老年代.这是常规状态下，在Survivor区已经满了的情况下，JVM会依据担保机制将一些对象直接放入老年代。</code></p><p>​	堆内存主要用于存放对象和数组，它是JVM管理的内存中最大的一块区域，堆内存和方法区都被所有线程共享，在虚拟机启动时创建。在垃圾收集的层面上来看，<code>由于现在收集器基本上都采用分代收集算法</code>，因此堆还可以分为新生代（YoungGeneration）和老年代（OldGeneration），新生代还可以分为Eden、From Survivor、To Survivor</p><p><img src="/breeze/1a45f578/1635928929069.png" alt="1635928929069"></p><h5 id="3-3-7-元空间-1-8"><a href="#3-3-7-元空间-1-8" class="headerlink" title="3.3.7.元空间 (1.8)"></a>3.3.7.元空间 (1.8)</h5><p>​	上面说到，jdk1.8中，已经不存在永久代（方法区），替代它的一块空间叫做“元空间”，和永久代类似，都是JVM规范对方法区的实现，但是<code>元空间并不在虚拟机中，而是使用本地内存，元空间的大小仅受本地内存限制</code>，但可以通过-XX:MetaspaceSize和-XX:MaxMetaspaceSize来指定元空间的大小</p><p><strong>Jdk1.8去除了方法区,取而代之是元空间，直接使用本地内存</strong></p><h4 id="3-4-JVM内存溢出"><a href="#3-4-JVM内存溢出" class="headerlink" title="3.4.JVM内存溢出"></a>3.4.JVM内存溢出</h4><h5 id="3-4-1-堆内存溢出"><a href="#3-4-1-堆内存溢出" class="headerlink" title="3.4.1.堆内存溢出"></a>3.4.1.堆内存溢出</h5><p>堆内存中主要存放对象、数组等，只要不断地创建这些对象，并且保证GC Roots到对象之间有可达路径来避免垃圾收集回收机制清除这些对象，当这些对象所占空间超过最大堆容量时，就会产生OutOfMemoryError的异常。堆内存异常示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 设置最大堆最小堆：-Xms20m -Xmx20m</span></span><br><span class="line"><span class="comment">* 运行时，不断在堆中创建OOMObject类的实例对象，且while执行结束之前，GC Roots(代码中的oomObjectList)到对象(每一个OOMObject对象)之间有可达路径，垃圾收集器就无法回收它们，最终导致内存溢出。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapOOMTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OOMObject</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       List&lt;OOMObject&gt; oomObjectList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">           oomObjectList.add(<span class="keyword">new</span> <span class="title class_">OOMObject</span>());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后会报异常，在堆栈信息中可以看到 java.lang.OutOfMemoryError: Java heap space 的信息，说明在堆内存空间产生内存溢出的异常。</p><p>新产生的对象最初分配在新生代，新生代满后会进行一次Minor GC，如果Minor GC后空间不足会把该对象和新生代满足条件的对象放入老年代，老年代空间不足时会进行Full GC，之后如果空间还不足以存放新对象则抛出OutOfMemoryError异常。常见原因：内存中加载的数据过多如一次从数据库中取出过多数据；集合对对象引用过多且使用完后没有清空；代码中存在死循环或循环产生过多重复对象；堆内存分配不合理；网络连接问题、数据库问题等。</p><p>不会自己改ide的对空间,通过虚拟机参数修改该运行空间.</p><ul><li>修改所有</li></ul><p><img src="/breeze/1a45f578/1635933211330.png" alt="1635933211330"></p><ul><li>单个修改</li></ul><p><img src="/breeze/1a45f578/1635933251469.png" alt="1635933251469"></p><h5 id="3-4-2-虚拟机栈-本地方法栈溢出"><a href="#3-4-2-虚拟机栈-本地方法栈溢出" class="headerlink" title="3.4.2.虚拟机栈&#x2F;本地方法栈溢出"></a>3.4.2.虚拟机栈&#x2F;本地方法栈溢出</h5><ol><li>StackOverflowError：当线程请求的栈的深度大于虚拟机所允许的最大深度，则抛出StackOverflowError，简单理解就是虚拟机栈中的栈帧数量过多（一个线程嵌套调用的方法数量过多）时，就会抛出StackOverflowError异常。最常见的场景就是方法无限递归调用，如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mliutm._03memory;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置每个线程的栈大小：-Xss256k</span></span><br><span class="line"><span class="comment"> * 运行时，不断调用doSomething()方法，main线程不断创建栈帧并入栈，导致栈的深度越来越大，最终导致栈溢出。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackSOFTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">stackLength</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StackSOFTest</span> <span class="variable">stackSOF</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StackSOFTest</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stackSOF.doSomething();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;<span class="comment">//注意捕获的是Throwable--Exception,Error</span></span><br><span class="line">            System.out.println(<span class="string">&quot;栈深度：&quot;</span> + stackSOF.stackLength);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException interruptedException) &#123;</span><br><span class="line">                interruptedException.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码执行后抛出：Exception in thread “Thread-0” java.lang.StackOverflowError的异常。</p><ol start="2"><li>OutOfMemoryError：如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError。</li></ol><p><img src="/breeze/1a45f578/1635933366717.png" alt="1635933366717"></p><p>栈上能够产生OutOfMemoryError的示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置每个线程的栈大小：-Xss2m</span></span><br><span class="line"><span class="comment"> * 运行时，不断创建新的线程（且每个线程持续执行），每个线程对一个一个栈，最终没有多余的空间来为新的线程分配，导致OutOfMemoryError</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackOOMTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">threadNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">StackOOMTest</span> <span class="variable">stackOOM</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StackOOMTest</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                threadNum++;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                        stackOOM.doSomething();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                thread.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;目前活动线程数量：&quot;</span> + threadNum);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码运行后会报异常，在堆栈信息中可以看到 java.lang.OutOfMemoryError: unable to create new native thread的信息，无法创建新的线程，说明是在扩展栈的时候产生的内存溢出异常。</p><p>总结：<code>在线程较少的时候，某个线程请求深度过大，会报StackOverflow异常，解决这种问题可以适当加大栈的深度</code>（增加栈空间大小），<code>也就是把-Xss的值设置大一些，</code>但一般情况下是代码问题的可能性较大；在虚拟机产生线程时，无法为该线程申请栈空间了，会报OutOfMemoryError异常，解决这种问题可以适当减小栈的深度，也就是把-Xss的值设置小一些，每个线程占用的空间小了，总空间一定就能容纳更多的线程，但是操作系统对一个进程的线程数有限制，经验值在3000~5000左右。在jdk1.5之前-Xss默认是256k，jdk1.5之后默认是<strong>1M</strong>，这个选项对系统硬性还是蛮大的，设置时要根据实际情况，谨慎操作。</p><h5 id="3-4-3-方法区溢出-元空间"><a href="#3-4-3-方法区溢出-元空间" class="headerlink" title="3.4.3.方法区溢出-元空间"></a>3.4.3.方法区溢出-元空间</h5><p>方法区主要用于存储虚拟机加载的类信息、常量、静态变量，以及编译器编译后的代码等数据，所以方法区溢出的原因就是没有足够的内存来存放这些数据。</p><p>由于在jdk1.6之前字符串常量池是存在于方法区中的，所以基于jdk1.6之前的虚拟机，可以通过不断产生不一致的字符串（同时要保证和GC Roots之间保证有可达路径）来模拟方法区的OutOfMemoryError异常；但方法区还存储加载的类信息，所以基于jdk1.7的虚拟机，可以通过动态不断创建大量的类来模拟方法区溢出。</p><h5 id="3-4-4-本机直接内存溢出"><a href="#3-4-4-本机直接内存溢出" class="headerlink" title="3.4.4.本机直接内存溢出"></a>3.4.4.本机直接内存溢出</h5><p>本机直接内存（DirectMemory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但Java中用到NIO相关操作时（比如ByteBuffer的allocteDirect方法申请的是本机直接内存），也可能会出现内存溢出的异常。</p><h4 id="3-5-执行引擎"><a href="#3-5-执行引擎" class="headerlink" title="3.5.执行引擎"></a>3.5.执行引擎</h4><p>​	执行引擎包含即时编译器(JIT)和垃圾回收器(GC)，对即时编译器我们简单介绍一下，主要重点在于垃圾回收器. 放到下个章节将</p><p><strong>即时编译器</strong></p><p>​ <strong>javac Hello.java(编译)</strong> java Hello(<strong>Hello.class-)–&gt;二进制</strong></p><p>​	看到这个东西的存在可能有些人会感到疑问,不是通过javac命令就把我们的java代码编译成字节码文件了吗,这个即时编译器又是干嘛的?</p><p>​	我们需要明确一个概念就是,计算机实际上只认识0和1,这种由0和1组成的命令集称之为”机器码”,而且会根据平台不同而有所不同,可读性和可移植性极差.我们的字节码文件包含的并不是机器码,不能由计算机直接运行,而需要JVM”解释”执行.JVM将字节码文件中所写的命令解释成一个个计算机操作命令,再通知计算机进行运算.</p><p>总结：<strong>Javac把源文件编译成字节码文件</strong>，即使编译JIT把<strong>字节码文件中的命令编译成机器码即计算机操作命令去执行。</strong></p><h2 id="二-垃圾回收-重点-识别垃圾-清洁工回收-怎么回收"><a href="#二-垃圾回收-重点-识别垃圾-清洁工回收-怎么回收" class="headerlink" title="二.垃圾回收  重点  识别垃圾 清洁工回收  怎么回收"></a>二.垃圾回收 重点 识别垃圾 清洁工回收 怎么回收</h2><p>它是垃圾(判断是否是垃圾),选择垃圾回收器来回收(如果没有选择使用默认),对应的垃圾回收器有对应垃圾回收算法</p><h3 id="1-垃圾标记算法–识别垃圾"><a href="#1-垃圾标记算法–识别垃圾" class="headerlink" title="1.垃圾标记算法–识别垃圾"></a>1.垃圾标记算法–识别垃圾</h3><p>​	判断对象是否已死就是找出哪些对象是已经死掉的，以后不会再用到的，就像地上有废纸、饮料瓶和百元大钞，扫地前要先判断出地上废纸和饮料瓶是垃圾，百元大钞不是垃圾。判断对象是否已死有引用计数算法和可达性分析算法。</p><h4 id="1-1-引用计数算法"><a href="#1-1-引用计数算法" class="headerlink" title="1.1.引用计数算法"></a>1.1.引用计数算法</h4><p>​	给每一个对象添加一个引用计数器，每当<code>有一个地方引用它时，计数器值加1</code>；每当有一个地方<code>不再引用它时，计数</code></p><p><code>器值减1</code>，这样只要计数器的值不为0，就说明还有地方引用它，它就不是无用的对象。如下图，对象2有1个引用，它的引用计数器值为1，对象1有两个地方引用，它的引用计数器值为2 。</p><p><img src="/breeze/1a45f578/1635929115200.png" alt="1635929115200"></p><p>这种方法看起来非常简单，但目前许多主流的虚拟机都没有选用这种算法来管理内存，原因就是<code>当某些对象之间互相引用时，无法判断出这些对象是否已死</code>，如下图，对象1和对象2都没有被堆外的变量引用，而是被对方互相引用，这时他们虽然没有用处了，但是引用计数器的值仍然是1，无法判断他们是死对象，垃圾回收器也就无法回收。</p><p><img src="/breeze/1a45f578/1635929151267.png" alt="1635929151267"></p><h4 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2.可达性分析算法"></a>1.2.可达性分析算法</h4><p>​	了解可达性分析算法之前先了解一个概念——<code>GC Roots</code>，垃圾收集的起点，可以作为GC Roots的有<strong>虚拟机栈中本地变量表中引用的对象</strong>、方法区中静态属性引用的对象、方法区中常量引用的对象、本地方法栈中JNI（Native方法）引用的对象。</p><p><code>当一个对象到GC Roots没有任何引用链相连（GC Roots到这个对象不可达）时，就说明此对象是不可用的</code>，是死对象。如下图：object1、object2、object3、object4和GC Roots之间有可达路径，这些对象不会被回收，但object5、object6、object7到GC Roots之间没有可达路径，这些对象就被判了死刑。</p><p><img src="/breeze/1a45f578/1635929192801.png" alt="1635929192801"></p><p><img src="/breeze/1a45f578/1690183925257.png" alt="1690183925257"></p><p>上面被判了死刑的对象（object5、object6、object7）并不是必死无疑，还有挽救的余地。进行可达性分析后对象和GC Roots之间没有引用链相连时，对象将会被进行一次标记，接着会判断如果<code>对象没有覆盖Object的finalize()方法或者finalize()方法已经被虚拟机调用过，那么它们就会被行刑（清除）</code>；如果对象<code>覆盖了finalize()方法且还没有被调用，则会执行finalize()方法中的内容，所以在finalize()方法中如果重新与GC Roots引用链上的对象关联就可以拯救自己</code>，但是一般不建议这么做（<mark>如果这样做了，那么只要是采用的可达性分析算法，则该对象永远不会被回收</mark>）.</p><p>final finally finalize</p><h3 id="2-常用垃圾回收算法"><a href="#2-常用垃圾回收算法" class="headerlink" title="2.常用垃圾回收算法"></a>2.常用垃圾回收算法</h3><p>常用的垃圾回收算法有四种：标记-清除算法、复制算法、标记-整理算法，<strong>分代回收</strong>(组合前面)</p><h4 id="2-1-标记清除算法"><a href="#2-1-标记清除算法" class="headerlink" title="2.1.标记清除算法"></a>2.1.标记清除算法</h4><p>分为标记和清除两个阶段，首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象，如下图</p><p><img src="/breeze/1a45f578/1635929315016.png" alt="1635929315016"></p><p>缺点：标记和清除两个过程效率都不高；标记清除之后会产生大量不连续的内存碎片。</p><h4 id="2-2-复制算法"><a href="#2-2-复制算法" class="headerlink" title="2.2.复制算法"></a>2.2.复制算法</h4><p>把内存分为大小相等的两块，每次存储只用其中一块，当这一块用完了，就把存活的对象全部复制到另一块上，同时把使用过的这块内存空间全部清理掉，往复循环，如下图。</p><p><img src="/breeze/1a45f578/1635929355501.png" alt="1635929355501"></p><p>缺点：实际可使用的内存空间缩小为原来的一半，比较适合</p><h4 id="2-3-标记整理算法–慢-性能不高"><a href="#2-3-标记整理算法–慢-性能不高" class="headerlink" title="2.3.标记整理算法–慢,性能不高"></a>2.3.标记整理算法–慢,性能不高</h4><p>先对可用的对象进行标记，然后所有被标记的对象向一端移动，最后清除可用对象边界以外的内存，如下图。</p><p><img src="/breeze/1a45f578/1635929403032.png" alt="1635929403032"></p><h4 id="2-4-分代收集算法"><a href="#2-4-分代收集算法" class="headerlink" title="2.4.分代收集算法"></a>2.4.分代收集算法</h4><p>​	把堆内存分为<code>新生代和老年代</code>，新生代又分为Eden区、From Survivor和To Survivor。一般新生代中的对象基本上都是朝生夕灭的，每次只有少量对象存活，因此<code>新生代采用复制算法</code>，只需要复制那些少量存活的对象就可以完成垃圾收集；<code>老年代中的对象存活率较高，就采用标记-清除和标记-整理算法</code>来进行回收。</p><p><img src="/breeze/1a45f578/1635929448971.png" alt="1635929448971"></p><h3 id="3-Minor-GC和Full-GC-2-4进行补充"><a href="#3-Minor-GC和Full-GC-2-4进行补充" class="headerlink" title="3.Minor GC和Full GC(2.4进行补充)"></a>3.Minor GC和Full GC(2.4进行补充)</h3><h4 id="3-1-Stop-The-World"><a href="#3-1-Stop-The-World" class="headerlink" title="3.1.Stop-The-World"></a>3.1.Stop-The-World</h4><p>​	在说这两种回收的区别之前，我们先来说一个概念，“<code>Stop-The-World</code>”。如字面意思，每次垃圾回收的时候，都会将整个JVM暂停，回收完成后再继续。如果一边增加废弃对象，一边进行垃圾回收，完成工作似乎就变得遥遥无期了。</p><h4 id="3-2-Minor-GC"><a href="#3-2-Minor-GC" class="headerlink" title="3.2.Minor GC"></a><strong>3.2.Minor GC</strong></h4><p>​	新生代的回收称为Minor GC，新生代的回收一般回收很快，采用<code>复制算法，造成的暂停时间很短</code></p><h4 id="3-3-Full-GC"><a href="#3-3-Full-GC" class="headerlink" title="3.3.Full GC"></a><strong>3.3.Full GC</strong></h4><p>​	而Full GC一般是老年代的回收,并伴随至少一次的Minor GC，新生代和老年代都回收，而老年代采用<code>标记-整理算法</code>，<code>这种GC每次都比较慢</code>，<code>造成的暂停时间比较长</code>，通常是Minor GC时间的10倍以上。</p><p>所以很明显，<code>我们需要尽量通过Minor GC来回收内存，而尽量少的触发Full GC</code>。毕竟系统运行一会儿就要因为GC卡住一段时间，再加上其他的同步阻塞，整个系统给人的感觉就是又卡又慢。</p><h4 id="3-4-GC的流程"><a href="#3-4-GC的流程" class="headerlink" title="3.4.GC的流程"></a>3.4.GC的流程</h4><ol><li><p>大多数情况下，<code>新的对象都分配在Eden区</code>，当Eden区没有空间进行分配时，将进行一次Minor GC，清理Eden区中的无用对象。<code>清理后，Eden和From Survivor中的存活对象如果小于To Survivor的可用空间则进入To Survivor</code>，否则直接进入老年代）；<code>Eden和From Survivor中还存活且能够进入To Survivor的对象年龄增加1岁</code>（虚拟机为每个对象定义了一个年龄计数器，每执行一次Minor GC年龄加1），<code>当存活对象的年龄到达一定程度（默认15岁）后进入老年代</code>，可以通过-XX:MaxTenuringThreshold来设置年龄的值。</p></li><li><p><strong>当进行了Minor GC后，Eden还不足以为新对象分配空间（那这个新对象肯定很大），新对象直接进入老年代。</strong></p></li><li><p><strong>大对象（需要大量连续内存的对象）例如很长的数组，会直接进入老年代，</strong></p></li><li><p>如果老年代没有足够的连续大空间来存放，则会进行Full GC。</p><p>Minor GC之前，如果预测老年代内存不够，就进行Full GC老年代，否则就Minor GC新生代</p></li><li><p>当在java代码里直接调用System.gc()时，会建议JVM进行Full GC，但一般情况下都会触发Full GC，一般不建议使用，尽量让虚拟机自己管理GC的策略。</p></li></ol><h3 id="4-常见垃圾收集器"><a href="#4-常见垃圾收集器" class="headerlink" title="4.常见垃圾收集器"></a>4.常见垃圾收集器</h3><h4 id="4-1-垃圾回收器分类"><a href="#4-1-垃圾回收器分类" class="headerlink" title="4.1.垃圾回收器分类"></a>4.1.垃圾回收器分类</h4><p>GC 发展阶段：Serial(串行) &#x3D;&gt; Parallel（并行）&#x3D;&gt; CMS（并发）&#x3D;&gt; G1 &#x3D;&gt; ZGC</p><p>现在常见的垃圾收集器有如下几种</p><ul><li><p>新生代收集器：Serial、ParNew、Parallel Scavenge</p></li><li><p>老年代收集器：Serial Old、CMS、Parallel Old</p></li><li><p>堆内存垃圾收集器：G1</p></li></ul><p>每种垃圾收集器之间有连线，表示他们可以搭配使用。</p><p><img src="/breeze/1a45f578/1635929929822.png" alt="1635929929822"></p><h4 id="4-2-新生代：Serial"><a href="#4-2-新生代：Serial" class="headerlink" title="4.2.新生代：Serial"></a>4.2.新生代：Serial</h4><p>Serial是一款用于<code>新生代的单线程收集器，采用复制算法进行垃圾收集</code>。Serial进行垃圾收集时，不仅只用一条线程执行垃圾收集工作，它在收集的同时，所有的用户线程必须暂停（Stop The World）。就比如妈妈在家打扫卫生的时候，肯定不会边打扫边让儿子往地上乱扔纸屑，否则一边制造垃圾，一遍清理垃圾，这活啥时候也干不完。</p><p>如下是Serial收集器和Serial Old收集器结合进行垃圾收集的示意图，当用户线程都执行到安全点时，所有线程暂停执行，Serial收集器以单线程，采用复制算法进行垃圾收集工作，收集完之后，用户线程继续开始执行。</p><p><img src="/breeze/1a45f578/wpsA835.tmp.jpg" alt="img"> 适用场景：Client模式（桌面应用）；单核服务器。可以用-XX:+UserSerialGC来选择Serial作为新生代收集器。</p><h4 id="4-3-新生代：ParNew"><a href="#4-3-新生代：ParNew" class="headerlink" title="4.3.新生代：ParNew"></a>4.3.新生代：ParNew</h4><p><code>ParNew就是一个Serial的多线程版本</code>，其它与Serial并无区别。ParNew在单核CPU环境并不会比Serial收集器达到更好的效果，它默认开启的收集线程数和CPU数量一致，可以通过-XX:ParallelGCThreads来设置垃圾收集的线程数。</p><p>如下是ParNew收集器和Serial Old收集器结合进行垃圾收集的示意图，当用户线程都执行到安全点时，所有线程暂停执行，ParNew收集器以多线程，采用<strong>复制算法</strong>进行垃圾收集工作，收集完之后，用户线程继续开始执行。</p><p><img src="/breeze/1a45f578/1635930253471.png" alt="1635930253471"></p><p>适用场景：多核服务器；与CMS收集器搭配使用。当使用-XX:+UserConcMarkSweepGC来选择CMS作为老年代收集器时，新生代收集器默认就是ParNew，也可以用-XX:+UseParNewGC来指定使用ParNew作为新生代收集器。</p><h4 id="4-4-新生代：Parallel-Scavenge-掌握"><a href="#4-4-新生代：Parallel-Scavenge-掌握" class="headerlink" title="4.4.新生代：Parallel Scavenge(掌握)"></a>4.4.新生代：Parallel Scavenge(掌握)</h4><p>Parallel Scavenge也是一款用于新生代的<code>多线程收集器</code>，与ParNew的不同之处是，ParNew的目标是<code>尽可能缩短垃圾收集时用户线程的停顿时间，Parallel Scavenge的目标是达到一个可控制的吞吐量</code></p><p>可以通过-XX:MaxGCPauseMillis来设置收集器尽可能在多长时间内完成内存回收，可以通过-XX:GCTimeRatio来精确控制吞吐量。</p><p>如下是Parallel收集器和Parallel Old收集器结合进行垃圾收集的示意图，在新生代，当用户线程都执行到安全点时，所有线程暂停执行，Parallel收集器以多线程，采用<strong>复制算法</strong>进行垃圾收集工作，收集完之后，用户线程继续开始执行；在老年代，当用户线程都执行到安全点时，所有线程暂停执行，<code>Parallel Old收集器以多线程，采用标记整理算法进行垃圾收集工作。</code></p><p>​ 停顿10s 收集5s—-&gt;停顿11s 收集1s</p><p><img src="/breeze/1a45f578/wps455E.tmp.jpg" alt="img"></p><p>适用场景：注重吞吐量，高效利用CPU，需要高效运算且不需要太多交互。可以使用-XX:+UseParallelGC来选择Parallel Scavenge作为新生代收集器，<strong>jdk7、jdk8默认使用Parallel Scavenge作为新生代收集器。</strong></p><h4 id="4-5-老年代：Serial-Old"><a href="#4-5-老年代：Serial-Old" class="headerlink" title="4.5.老年代：Serial Old"></a>4.5.老年代：Serial Old</h4><p><code>Serial Old收集器是Serial的老年代版本，同样是一个单线程收集器，采用标记-整理算法。</code></p><p>如下图是Serial收集器和Serial Old收集器结合进行垃圾收集的示意图：</p><p><img src="/breeze/1a45f578/1635930562595.png" alt="1635930562595"></p><p>适用场景：Client模式（桌面应用）；单核服务器；与Parallel Scavenge收集器搭配；作为CMS收集器的后备预案。</p><h4 id="4-6-老年代：CMS"><a href="#4-6-老年代：CMS" class="headerlink" title="4.6.老年代：CMS"></a>4.6.老年代：CMS</h4><p>CMS收集器是一种以最短回收停顿时间为目标的收集器，以“最短用户线程停顿时间”著称。整个垃圾收集过程分为4个步骤</p><ul><li>初始标记：标记一下GC Roots能直接关联到的对象，速度较快</li><li>并发标记：进行GC Roots Tracing，标记出全部的垃圾对象，耗时较长</li><li>重新标记：修正并发标记阶段引用户程序继续运行而导致变化的对象的标记记录，耗时较短</li><li>并发清除：<code>用标记-清除算法清除垃圾对象</code>，耗时较长</li></ul><p>整个过程耗时最长的并发标记和并发清除都是和用户线程一起工作，所以从总体上来说，<code>CMS收集器垃圾收集可以看做是和用户线程并发执行的。</code></p><p><img src="/breeze/1a45f578/1635930617213.png" alt="1635930617213"></p><p>CMS收集器也存在一些缺点：</p><ul><li><p>对CPU资源敏感：默认分配的垃圾收集线程数为（CPU数+3）&#x2F;4，随着CPU数量下降，<code>占用CPU资源越多，吞吐量越小</code></p></li><li><p><code>无法处理浮动垃圾</code>：在并发清理阶段，由于用户线程还在运行，还会不断产生新的垃圾，CMS收集器无法在当次收集中清除这部分垃圾。同时由于在垃圾收集阶段用户线程也在并发执行，CMS收集器不能像其他收集器那样等老年代被填满时再进行收集，需要预留一部分空间提供用户线程运行使用。当CMS运行时，预留的内存空间无法满足用户线程的需要，就会出现“Concurrent Mode Failure”的错误，这时将会启动后备预案，临时用Serial Old来重新进行老年代的垃圾收集。</p></li><li><p>因为CMS是<code>基于标记-清除算法，所以垃圾回收后会产生空间碎片</code>，可以通过-XX:UserCMSCompactAtFullCollection开启碎片整理（默认开启），在CMS进行Full GC之前，会进行内存碎片的整理。还可以用-XX:CMSFullGCsBeforeCompaction设置执行多少次不压缩（不进行碎片整理）的Full GC之后，跟着来一次带压缩（碎片整理）的Full GC。</p></li></ul><p>适用场景：重视服务器响应速度，要求系统停顿时间最短。可以使用-XX:+UserConMarkSweepGC来选择CMS作为老年代收集器。</p><h4 id="4-7-老年代：Parallel-Old"><a href="#4-7-老年代：Parallel-Old" class="headerlink" title="4.7.老年代：Parallel Old"></a>4.7.老年代：Parallel Old</h4><p>Parallel Old收集器是Parallel Scavenge的老年代版本，是一个<code>多线程收集器，采用标记-整理算法。可以与Parallel Scavenge收集器搭配，可以充分利用多核CPU的计算能力</code>。</p><p>​ <img src="/breeze/1a45f578/wps49E0.tmp.jpg" alt="img"></p><p>适用场景：与Parallel Scavenge收集器搭配使用；注重吞吐量。<code>jdk7、jdk8默认使用该收集器作为老年代收集器</code>，<code>使用 -XX:+UseParallelOldGC</code>来指定使用Paralle Old收集器。</p><h4 id="4-8-堆收集：G1-收集器"><a href="#4-8-堆收集：G1-收集器" class="headerlink" title="4.8.堆收集：G1 收集器"></a>4.8.堆收集：G1 收集器</h4><p>G1 收集器是jdk1.7才正式引用的<strong>商用收集器</strong>，现在已经成为<code>jdk1.9默认的收集器</code>。前面几款收集器收集的范围都是新生代或者老年代，<code>G1进行垃圾收集的范围是整个堆内存</code>，它采用“化整为零”的思路，<code>把整个堆内存划分为多个大小相等的独立区域（Region）</code>，在G1收集器中还保留着新生代和老年代的概念，它们分别都是一部分Region，如下图：</p><p><code>在每个Region中，都有一个Remembered Set来实时记录该区域内的引用类型数据与其他区域数据的引用关系</code>（在前面的几款分代收集中，新生代、老年代中也有一个Remembered Set来实时记录与其他区域的引用关系），在<code>标记时直接参考这些引用关系就可以知道这些对象是否应该被清除，而不用扫描全堆的数据</code>。</p><p>如下图所示，<code>G1收集器收集器收集过程有初始标记、并发标记、最终标记、筛选回收，和CMS收集器前几步的收集过程很相似：</code></p><p><img src="/breeze/1a45f578/54fbb2fb43166d22e7b9cd23cc0a10fb9152d275.jpg" alt="img"></p><ol><li><p>初始标记：标记出GC Roots直接关联的对象，这个阶段速度较快，需要停止用户线程，单线程执行</p></li><li><p>并发标记：从GC Root开始对堆中的对象进行可达新分析，找出存活对象，这个阶段耗时较长，但可以和用户线程并发执行</p></li><li><p>最终标记：修正在并发标记阶段引用户程序执行而产生变动的标记记录</p></li><li><p>筛选回收：筛选回收阶段会对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来指定回收计划（用最少的时间来回收包含垃圾最多的区域，这就是Garbage First的由来——第一时间清理垃圾最多的区块），这里为了提高回收效率，<code>并没有采用和用户线程并发执行的方式，而是停顿用户线程</code>。</p></li></ol><p>适用场景：要求尽可能可控GC停顿时间；内存占用较大的应用。可以用-XX:+UseG1GC使用G1收集器，jdk9默认使用G1收集器。</p><p>Jdk1.7.<strong>1.8</strong>新生代使用Parallel Scavenge(复制),老年代使用Parallel Old(标记整理)</p><p>jdk1.9 默认G1,被它自己淘汰.</p><p>jdk14 zgc <strong>jdk17</strong>用的zgc. 不收费</p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45925485/article/details/127580787">https://blog.csdn.net/weixin_45925485/article/details/127580787</a></p><h2 id="三-JVM的优化"><a href="#三-JVM的优化" class="headerlink" title="三.JVM的优化"></a>三.JVM的优化</h2><h3 id="1-JVM优化概述"><a href="#1-JVM优化概述" class="headerlink" title="1.JVM优化概述"></a>1.JVM优化概述</h3><h4 id="1-1-JVM优化目标"><a href="#1-1-JVM优化目标" class="headerlink" title="1.1.JVM优化目标"></a>1.1.JVM优化目标</h4><p><strong>JVM调优目标：</strong><code>使用较小的内存占用来获得较高的吞吐量或者较低的延迟</code>。</p><p>程序在上线前的测试或运行中有时会出现一些大大小小的JVM问题，比如cpu load过高、请求延迟、tps降低等，甚至出现内存泄漏（每次垃圾收集使用的时间越来越长，垃圾收集频率越来越高，每次垃圾收集清理掉的垃圾数据越来越少）、内存溢出导致系统崩溃，因此需要对JVM进行调优，使得程序在正常运行的前提下，获得更高的用户体验和运行效率。</p><p>这里有几个比较重要的指标：</p><ul><li><p><strong>内存占用：</strong>程序正常运行需要的内存大小。</p></li><li><p><strong>延迟：</strong>由于垃圾收集而引起的程序停顿时间。</p></li><li><p><strong>吞吐量：</strong>用户程序运行时间占用户程序和垃圾收集占用总时间的比值。</p></li></ul><p>当然，<code>和CAP原则一样，同时满足一个程序内存占用小、延迟低、高吞吐量是不可能的，程序的目标不同，调优时所考虑的方向也不同，在调优之前，必须要结合实际场景，有明确的的优化目标，找到性能瓶颈，对瓶颈有针对性的优化</code>，最后进行测试，通过各种监控工具确认调优后的结果是否符合目标。</p><p><code>[重要]调优可以依赖、参考的数据有系统运行日志(OOM)、堆栈错误信息、gc日志、线程快照、堆转储快照等。</code></p><h4 id="1-2-优化手段"><a href="#1-2-优化手段" class="headerlink" title="1.2.优化手段"></a>1.2.优化手段</h4><ul><li><p>系统运行日志</p><p>系统运行日志就是在程序代码中打印出的日志，描述了代码级别的系统运行轨迹（执行的方法、入参、返回值等），一般系统出现问题，系统运行日志是首先要查看的日志。</p></li><li><p>堆栈错误信息</p><p>当系统出现异常后，可以根据堆栈信息初步定位问题所在，比如根据“java.lang.OutOfMemoryError: Java heap space”可以判断是堆内存溢出；根据“java.lang.StackOverflowError”可以判断是栈溢出；根据“java.lang.OutOfMemoryError: PermGen space”可以判断是方法区溢出等。</p></li><li><p>GC日志</p><p>程序启动时用 -XX:+PrintGCDetails 和 -Xloggc:&#x2F;data&#x2F;jvm&#x2F;gc.log 可以在程序运行时把gc的详细过程记录下来，或者直接配置“-verbose:gc”参数把gc日志打印到控制台，通过记录的gc日志可以分析每块内存区域gc的频率、时间等，从而发现问题，进行有针对性的优化</p></li><li><p>线程快照</p><p>顾名思义，根据线程快照可以看到线程在某一时刻的状态，当系统中可能存在请求超时、死循环、死锁等情况是，可以根据线程快照来进一步确定问题。通过执行虚拟机自带的“jstack pid”命令，可以dump出当前进程中线程的快照信息</p></li><li><p>堆转储快照</p><p>程序启动时可以使用 “-XX:+HeapDumpOnOutOfMemory” 和</p><p>“-XX:HeapDumpPath&#x3D;&#x2F;data&#x2F;jvm&#x2F;dumpfile.hprof”，当程序发生内存溢出时，把当时的内存快照以文件形式进行转储（也可以直接用jmap命令转储程序运行时任意时刻的内存快照），事后对当时的内存使用情况进行分析。</p></li></ul><h3 id="2-JVM内存优化—通过一些工具或日志-找到问题所在-要么设置内存-要么跟换垃圾回收器"><a href="#2-JVM内存优化—通过一些工具或日志-找到问题所在-要么设置内存-要么跟换垃圾回收器" class="headerlink" title="2.JVM内存优化—通过一些工具或日志,找到问题所在,要么设置内存,要么跟换垃圾回收器."></a>2.JVM内存优化—通过一些工具或日志,找到问题所在,要么设置内存,要么跟换垃圾回收器.</h3><h4 id="2-1-使用jps-jmap分析内存快照"><a href="#2-1-使用jps-jmap分析内存快照" class="headerlink" title="2.1.使用jps,jmap分析内存快照"></a>2.1.使用jps,jmap分析内存快照</h4><h5 id="1-用jps-（JVM-process-Status）查看进程"><a href="#1-用jps-（JVM-process-Status）查看进程" class="headerlink" title="1.用jps&#96;（JVM process Status）查看进程"></a>1.用jps&#96;（JVM process Status）查看进程</h5><p>可以查看虚拟机启动的所有进程、执行主类的全名、JVM启动参数，比如当执行了JPSTest类中的main方法后（main方法持续执行），执行 jps -l可看到下面的OOMTest类的pid为7480，加上-v参数还可以看到JVM启动参数。</p><p><img src="/breeze/1a45f578/1635931725455.png" alt="1635931725455"></p><p><img src="/breeze/1a45f578/1635931739556.png" alt="1635931739556"></p><h5 id="2-用jstat（JVM-Statistics-Monitoring-Tool）监视虚拟机信息"><a href="#2-用jstat（JVM-Statistics-Monitoring-Tool）监视虚拟机信息" class="headerlink" title="2.用jstat（JVM Statistics Monitoring Tool）监视虚拟机信息"></a>2.用jstat（JVM Statistics Monitoring Tool）监视虚拟机信息</h5><p><code>jstat -gc pid 500 10</code> ：pid是进程ID，每500毫秒打印一次Java堆状况（各个区的容量、使用容量、gc时间等信息），打印10次</p><p><img src="/breeze/1a45f578/1635931765309.png" alt="1635931765309"></p><p><img src="/breeze/1a45f578/1685427084631.png" alt="1685427084631"></p><p>jstat还可以以其他角度监视各区内存大小、监视类装载信息等，具体可以google jstat的详细用法。</p><h5 id="3-用jmap（Memory-Map-for-Java）查看堆内存信息"><a href="#3-用jmap（Memory-Map-for-Java）查看堆内存信息" class="headerlink" title="3.用jmap（Memory Map for Java）查看堆内存信息"></a>3.用jmap（Memory Map for Java）查看堆内存信息</h5><p>执行<code>jmap -histo pid</code>可以打印出当前堆中所有每个类的实例数量和内存占用，如下，class name是每个类的类名（[B是byte类型，[C是char类型，[I是int类型），bytes是这个类的所有示例占用内存大小，instances是这个类的实例数量：</p><p><img src="/breeze/1a45f578/1635931814235.png" alt="1635931814235"></p><p>执行jmap -dump 可以转储堆内存快照到指定文件，比如执行</p><p><strong>jmap -dump:format&#x3D;b,file&#x3D;&#x2F;data&#x2F;jvm&#x2F;dumpfile_jmap.hprof PID ，可以把当前堆内存的快照转储到dumpfile_jmap.hprof文件中，然后可以对内存快照进行分析。</strong></p><h5 id="4-分析堆转储快照"><a href="#4-分析堆转储快照" class="headerlink" title="4.分析堆转储快照"></a>4.分析堆转储快照</h5><p>前面说到配置了 “-<strong>XX:+HeapDumpOnOutOfMemory</strong>” 参数可以在程序发生内存溢出时dump出当前的内存快照，也可以用jmap命令随时dump出当时内存状态的快照信息，dump的内存快照一般是以.hprof为后缀的二进制格式文件。</p><p>可以直接用 jhat（JVM Heap Analysis Tool） 命令来分析内存快照，它的本质实际上内嵌了一个微型的服务器，可以通过浏览器来分析对应的内存快照，比如执行 jhat -port 9810 -J-Xmx4G &#x2F;data&#x2F;jvm&#x2F;dumpfile_jmap.hprof 表示以9810端口启动 jhat 内嵌的服务器：</p><p><img src="/breeze/1a45f578/1635931938779.png" alt="1635931938779"></p><p>在控制台可以看到服务器启动了，访问 <a target="_blank" rel="noopener" href="http://127.0.0.1:9810/">http://127.0.0.1:9810/</a> 可以看到对快照中的每个类进行分析的结果。</p><p><img src="/breeze/1a45f578/1635931969429.png" alt="1635931969429"></p><h4 id="2-2-jvisualvm分析内存快照"><a href="#2-2-jvisualvm分析内存快照" class="headerlink" title="2.2.jvisualvm分析内存快照"></a>2.2.jvisualvm分析内存快照</h4><p>jvisualvm也可以分析内存快照，在jvisualvm菜单的“文件”-“装入”，选择堆内存快照，快照中的信息就以图形界面展示出来了，</p><p>或者直接使用监视 - 堆Dump ：如下，主要可以查看每个类占用的空间、实例的数量和实例的详情等：</p><p><img src="/breeze/1a45f578/1635931996432.png" alt="1635931996432"></p><p><img src="/breeze/1a45f578/1635932035145.png" alt="1635932035145"></p><h4 id="2-3-内存溢出问题定位"><a href="#2-3-内存溢出问题定位" class="headerlink" title="2.3.内存溢出问题定位"></a>2.3.内存溢出问题定位</h4><h5 id="1-设置堆大小，以及捕获jvm日志"><a href="#1-设置堆大小，以及捕获jvm日志" class="headerlink" title="1.设置堆大小，以及捕获jvm日志"></a>1.设置堆大小，以及捕获jvm日志</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-Xms50m</span><br><span class="line">-Xmx50m</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:HeapDumpPath=d:\</span><br></pre></td></tr></table></figure><p><img src="/breeze/1a45f578/1635932093590.png" alt="1635932093590"></p><h5 id="2-制造内存溢出"><a href="#2-制造内存溢出" class="headerlink" title="2.制造内存溢出"></a>2.制造内存溢出</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程执行.....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p><img src="/breeze/1a45f578/1635932124718.png" alt="1635932124718"></p><h5 id="3-使用Java-Visual-VM-分析日志"><a href="#3-使用Java-Visual-VM-分析日志" class="headerlink" title="3.使用Java Visual VM 分析日志"></a>3.使用Java Visual VM 分析日志</h5><p>文件 -&gt; 载入 -&gt; 文件类型选择堆 -&gt; 打开日志</p><p><img src="/breeze/1a45f578/wpsFFE0.tmp.jpg" alt="img"></p><p>概要中可以看到内存溢出异常，Thread-61 ,点击进去</p><p><img src="/breeze/1a45f578/1635932157217.png" alt="1635932157217"></p><p>这里可以看到是哪一行，哪个对象造成的内存溢出</p><p><img src="/breeze/1a45f578/1635932168029.png" alt="1635932168029"></p><h3 id="3-常用JVM参数参考"><a href="#3-常用JVM参数参考" class="headerlink" title="3.常用JVM参数参考"></a>3.常用JVM参数参考</h3><p><img src="/breeze/1a45f578/1635932483463.png" alt="1635932483463"></p><ul><li>jdk1.7 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）</li><li>jdk1.8 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）</li><li>jdk1.9 默认垃圾收集器G1</li><li>jdk14以后途径zgc</li></ul><p>-XX:+PrintCommandLineFlags jvm参数可查看默认设置收集器类型</p><p>-XX:+PrintGCDetails亦可通过打印的GC日志的新生代、老年代名称判断</p><p>在里面公司里面一般都会有一些启动项目的参数模板,拷贝过去先运行!</p><p>java -jar -XX:MetaspaceSize&#x3D;128m -XX:MaxMetaspaceSize&#x3D;128m -Xms1024m -Xmx1024m -Xmn256m（年轻代） -Xss256k（线程栈） -XX:SurvivorRatio&#x3D;8 -XX:+UseConcMarkSweepGC newframe-1.0.0.jar</p><h3 id="4-jvm优化实战"><a href="#4-jvm优化实战" class="headerlink" title="4.jvm优化实战"></a>4.jvm优化实战</h3><p>​ jvm优化就是设置堆栈大小,以及选用垃圾回收器.如果没有设置,都使用默认,程序不一定运行良好.</p><h4 id="4-1-开发时"><a href="#4-1-开发时" class="headerlink" title="4.1 开发时"></a>4.1 开发时</h4><p>1、springboot项目-改一个</p><p>idea中配置</p><p><img src="/breeze/1a45f578/wps51A.tmp.jpg" alt="img"></p><p>2、集成开发环境下启动并使用JVM，如eclipse需要修改根目录文件</p><p>eclipse.ini； idea**,idea64.exe.vmoptions,** 单个修改通过vm参数</p><h4 id="4-2-上线的时候"><a href="#4-2-上线的时候" class="headerlink" title="4.2 上线的时候"></a>4.2 上线的时候</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Linux: java</span><br><span class="line">初始值:  如果你们公司没有...可以使用参考值</span><br><span class="line">java -jar -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=128m -Xms1024m -Xmx1024m -Xmn256m（年轻代） -Xss256k（线程栈） -XX:SurvivorRatio=<span class="number">8</span> -XX:+UseConcMarkSweepGC newframe-<span class="number">1.0</span><span class="number">.0</span>.jar</span><br><span class="line"></span><br><span class="line">docker:</span><br><span class="line">NTRYPOINT [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar -XX:MetaspaceSize=128m -XX:MaxMe    xxx.jar]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><h3 id="5-调优经验"><a href="#5-调优经验" class="headerlink" title="5.调优经验"></a>5.调优经验</h3><p>我们依据Java Performance这本书的建议的设置原则进行设置，</p><p>​	Java整个堆大小设置，Xmx 和 Xms设置为老年代存活对象的3-4倍，即FullGC之后的老年代内存占用的3-4倍，Xmx和Xms的大小设置为一样，避免GC后对内存的重新分配。而Full GC之后的老年代内存大小，我们可以通过前面在Visual VM中添加的插件Visual GC查看。先手动进行一次GC，然后查看老年代的内存占用。</p><p>​	新生代Xmn的设置为老年代存活对象的1-1.5倍。</p><p>​	老年代的内存大小设置为老年代存活对象的2-3倍。</p><p>​	JVM配置方面，一般情况可以先用默认配置（基本的一些初始参数可以保证一般的应用跑的比较稳定了），在测试中根据系统运行状况（会话并发情况、会话时间等），结合gc日志、内存监控、使用的垃圾收集器等进行合理的调整，当老年代内存过小时可能引起频繁Full GC，当内存过大时Full GC时间会特别长。</p><p>​	那么JVM的配置比如新生代、老年代应该配置多大最合适呢？答案是不一定，调优就是找答案的过程，物理内存一定的情况下，新生代设置越大，老年代就越小，Full GC频率就越高，但Full GC时间越短；相反新生代设置越小，老年代就越大，Full GC频率就越低，但每次Full GC消耗的时间越大。建议如下：</p><p>​	-Xms和-Xmx的值设置成相等，堆大小默认为-Xms指定的大小，默认空闲堆内存小于40%时，JVM会扩大堆到-Xmx指定的大小；空闲堆内存大于70%时，JVM会减小堆到-Xms指定的大小。如果在Full GC后满足不了内存需求会动态调整，这个阶段比较耗费资源。</p><p>​	新生代尽量设置大一些，让对象在新生代多存活一段时间，每次Minor GC 都要尽可能多的收集垃圾对象，防止或延迟对象进入老年代的机会，以减少应用程序发生Full GC的频率。</p><p>​	老年代如果使用CMS收集器，新生代可以不用太大，因为CMS的并行收集速度也很快，收集过程比较耗时的并发标记和并发清除阶段都可以与用户线程并发执行。</p><p>​	方法区大小的设置，1.6之前的需要考虑系统运行时动态增加的常量、静态变量等，1.7只要差不多能装下启动时和后期动态加载的类信息就行。</p><p>代码实现方面，性能出现问题比如程序等待、内存泄漏除了JVM配置可能存在问题，代码实现上也有很大关系：</p><p>避免创建过大的对象及数组：过大的对象或数组在新生代没有足够空间容纳时会直接进入老年代，如果是短命的大对象，会提前出发Full GC。</p><p>避免同时加载大量数据，如一次从数据库中取出大量数据，或者一次从Excel中读取大量记录，可以分批读取，用完尽快清空引用。</p><p>当集合中有对象的引用，这些对象使用完之后要尽快把集合中的引用清空，这些无用对象尽快回收避免进入老年代。</p><p>可以在合适的场景（如实现缓存）采用软引用、弱引用，比如用软引用来为ObjectA分配实例：SoftReference objectA&#x3D;new SoftReference(); 在发生内存溢出前，会将objectA列入回收范围进行二次回收，如果这次回收还没有足够内存，才会抛出内存溢出的异常。</p><p>避免产生死循环，产生死循环后，循环体内可能重复产生大量实例，导致内存空间被迅速占满。</p><p>尽量避免长时间等待外部资源（数据库、网络、设备资源等）的情况，缩小对象的生命周期，避免进入老年代，如果不能及时返回结果可以适当采用异步处理的方式等。</p><h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h2><h3 id="1-重点内容"><a href="#1-重点内容" class="headerlink" title="1.重点内容"></a>1.重点内容</h3><ul><li>JVM组成</li><li>jvm内存结构</li><li>类加载子系统</li><li>垃圾标记&#x2F;回收算法</li><li>常见的垃圾回收器</li><li>JVM常用参数</li><li>内存溢出解决</li></ul><h3 id="2-面试必备"><a href="#2-面试必备" class="headerlink" title="2.面试必备"></a>2.面试必备</h3><ul><li>你们用什么工具监控JVM</li><li>JVM类加载流程</li><li>JVM类加载器有几种类型，分别加载什么东西，用到什么设计模式？</li><li>JVM组成，以及他们的作用</li><li>在JVM层面，一个线程是如何执行的？</li><li>程序内存溢出了，如何定位问题出在哪儿？</li><li>垃圾标记算法， 垃圾回收算法</li><li>说说分带回收算法，(新生代,老年代)</li><li>JVM优化的目的是什么？</li><li>堆大小怎么调，栈大小怎么调</li><li>线程在JVM中是怎么执行的，涉及到哪些区域？</li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://mliutm.github.io">清风</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://mliutm.github.io/breeze/1a45f578.html">https://mliutm.github.io/breeze/1a45f578.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://mliutm.github.io" target="_blank">清风</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM%E4%BC%98%E5%8C%96/">JVM优化</a></div><div class="post_share"><div class="social-share" data-image="/img/photo-1645943020355-305df166473d.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/breeze/75a56cf8.html" title="MySQL多机优化"><img class="cover" src="/img/photo-1692708632140-ee01624d558d.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL多机优化</div></div></a></div><div class="next-post pull-right"><a href="/breeze/b3ef3604.html" title="SpringCloud-oauth-JWT"><img class="cover" src="/img/photo-1645943020355-305df166473d.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SpringCloud-oauth-JWT</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">清风</div><div class="author-info__description">清风洒六合，邈然不可攀</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">153</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">76</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:huangpan0805@163.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div><timing></timing></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM%E4%BC%98%E5%8C%96"><span class="toc-text">JVM优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AE%B9%E2%80%93-jvm%E6%A6%82%E8%BF%B0-%E7%BB%93%E6%9E%84-%E6%9C%89%E9%97%AE%E9%A2%98-%E4%BC%98%E5%8C%96"><span class="toc-text">内容– jvm概述 结构 有问题 优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-JVM%E7%BB%84%E6%88%90"><span class="toc-text">一.JVM组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-JVM%E6%A6%82%E8%BF%B0"><span class="toc-text">1.JVM概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AFJVM"><span class="toc-text">1.1.什么是JVM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BC%98%E5%8C%96JVM"><span class="toc-text">1.2.为什么要优化JVM</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-JVM%E5%88%86%E6%9E%90%E7%9A%84%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-text">2.JVM分析的常用工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="toc-text">2.1.分析工具</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-jvisualvm%E5%AE%89%E8%A3%85GC%E6%8F%92%E4%BB%B6"><span class="toc-text">2.2.jvisualvm安装GC插件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-JVM%E7%BB%84%E6%88%90"><span class="toc-text">3.JVM组成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-JVM%E7%BB%84%E6%88%90%E5%9B%BE-%E9%87%8D%E7%82%B9"><span class="toc-text">3.1.JVM组成图 重点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E9%87%8D%E7%82%B9"><span class="toc-text">3.2.类加载子系统 重点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-1%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">3.2.1类加载过程[面试题]</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-2%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-text">3.2.2类加载机制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-%E9%87%8D%E7%82%B9"><span class="toc-text">3.3运行时数据区-jvm内存结构-重点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-1-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E7%BB%84%E6%88%90"><span class="toc-text">3.3.1.运行时数据区组成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-2-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-text">3.3.2.程序计数器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-3-Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-text">3.3.3.Java虚拟机栈</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-4-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-text">3.3.4.本地方法栈</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-5%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%881-6%EF%BC%8C1-7%EF%BC%89-%E6%B0%B8%E4%B9%85%E4%BB%A3"><span class="toc-text">3.3.5方法区（1.6，1.7）-永久代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-6-%E5%A0%86%E5%86%85%E5%AD%98"><span class="toc-text">3.3.6.堆内存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-7-%E5%85%83%E7%A9%BA%E9%97%B4-1-8"><span class="toc-text">3.3.7.元空间 (1.8)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-JVM%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-text">3.4.JVM内存溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-1-%E5%A0%86%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-text">3.4.1.堆内存溢出</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-2-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E6%BA%A2%E5%87%BA"><span class="toc-text">3.4.2.虚拟机栈&#x2F;本地方法栈溢出</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-3-%E6%96%B9%E6%B3%95%E5%8C%BA%E6%BA%A2%E5%87%BA-%E5%85%83%E7%A9%BA%E9%97%B4"><span class="toc-text">3.4.3.方法区溢出-元空间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-4-%E6%9C%AC%E6%9C%BA%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-text">3.4.4.本机直接内存溢出</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="toc-text">3.5.执行引擎</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E9%87%8D%E7%82%B9-%E8%AF%86%E5%88%AB%E5%9E%83%E5%9C%BE-%E6%B8%85%E6%B4%81%E5%B7%A5%E5%9B%9E%E6%94%B6-%E6%80%8E%E4%B9%88%E5%9B%9E%E6%94%B6"><span class="toc-text">二.垃圾回收 重点 识别垃圾 清洁工回收 怎么回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9E%83%E5%9C%BE%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95%E2%80%93%E8%AF%86%E5%88%AB%E5%9E%83%E5%9C%BE"><span class="toc-text">1.垃圾标记算法–识别垃圾</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="toc-text">1.1.引用计数算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-text">1.2.可达性分析算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B8%B8%E7%94%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-text">2.常用垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-text">2.1.标记清除算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-text">2.2.复制算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95%E2%80%93%E6%85%A2-%E6%80%A7%E8%83%BD%E4%B8%8D%E9%AB%98"><span class="toc-text">2.3.标记整理算法–慢,性能不高</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-text">2.4.分代收集算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Minor-GC%E5%92%8CFull-GC-2-4%E8%BF%9B%E8%A1%8C%E8%A1%A5%E5%85%85"><span class="toc-text">3.Minor GC和Full GC(2.4进行补充)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-Stop-The-World"><span class="toc-text">3.1.Stop-The-World</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-Minor-GC"><span class="toc-text">3.2.Minor GC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-Full-GC"><span class="toc-text">3.3.Full GC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-GC%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-text">3.4.GC的流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%B8%B8%E8%A7%81%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">4.常见垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%88%86%E7%B1%BB"><span class="toc-text">4.1.垃圾回收器分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E6%96%B0%E7%94%9F%E4%BB%A3%EF%BC%9ASerial"><span class="toc-text">4.2.新生代：Serial</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E6%96%B0%E7%94%9F%E4%BB%A3%EF%BC%9AParNew"><span class="toc-text">4.3.新生代：ParNew</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-%E6%96%B0%E7%94%9F%E4%BB%A3%EF%BC%9AParallel-Scavenge-%E6%8E%8C%E6%8F%A1"><span class="toc-text">4.4.新生代：Parallel Scavenge(掌握)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%9ASerial-Old"><span class="toc-text">4.5.老年代：Serial Old</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%9ACMS"><span class="toc-text">4.6.老年代：CMS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%9AParallel-Old"><span class="toc-text">4.7.老年代：Parallel Old</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8-%E5%A0%86%E6%94%B6%E9%9B%86%EF%BC%9AG1-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">4.8.堆收集：G1 收集器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-JVM%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-text">三.JVM的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-JVM%E4%BC%98%E5%8C%96%E6%A6%82%E8%BF%B0"><span class="toc-text">1.JVM优化概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-JVM%E4%BC%98%E5%8C%96%E7%9B%AE%E6%A0%87"><span class="toc-text">1.1.JVM优化目标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5"><span class="toc-text">1.2.优化手段</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-JVM%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E2%80%94%E9%80%9A%E8%BF%87%E4%B8%80%E4%BA%9B%E5%B7%A5%E5%85%B7%E6%88%96%E6%97%A5%E5%BF%97-%E6%89%BE%E5%88%B0%E9%97%AE%E9%A2%98%E6%89%80%E5%9C%A8-%E8%A6%81%E4%B9%88%E8%AE%BE%E7%BD%AE%E5%86%85%E5%AD%98-%E8%A6%81%E4%B9%88%E8%B7%9F%E6%8D%A2%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-text">2.JVM内存优化—通过一些工具或日志,找到问题所在,要么设置内存,要么跟换垃圾回收器.</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E4%BD%BF%E7%94%A8jps-jmap%E5%88%86%E6%9E%90%E5%86%85%E5%AD%98%E5%BF%AB%E7%85%A7"><span class="toc-text">2.1.使用jps,jmap分析内存快照</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%94%A8jps-%EF%BC%88JVM-process-Status%EF%BC%89%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B"><span class="toc-text">1.用jps&#96;（JVM process Status）查看进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%94%A8jstat%EF%BC%88JVM-Statistics-Monitoring-Tool%EF%BC%89%E7%9B%91%E8%A7%86%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BF%A1%E6%81%AF"><span class="toc-text">2.用jstat（JVM Statistics Monitoring Tool）监视虚拟机信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E7%94%A8jmap%EF%BC%88Memory-Map-for-Java%EF%BC%89%E6%9F%A5%E7%9C%8B%E5%A0%86%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF"><span class="toc-text">3.用jmap（Memory Map for Java）查看堆内存信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%88%86%E6%9E%90%E5%A0%86%E8%BD%AC%E5%82%A8%E5%BF%AB%E7%85%A7"><span class="toc-text">4.分析堆转储快照</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-jvisualvm%E5%88%86%E6%9E%90%E5%86%85%E5%AD%98%E5%BF%AB%E7%85%A7"><span class="toc-text">2.2.jvisualvm分析内存快照</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D"><span class="toc-text">2.3.内存溢出问题定位</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%AE%BE%E7%BD%AE%E5%A0%86%E5%A4%A7%E5%B0%8F%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%8D%95%E8%8E%B7jvm%E6%97%A5%E5%BF%97"><span class="toc-text">1.设置堆大小，以及捕获jvm日志</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%88%B6%E9%80%A0%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-text">2.制造内存溢出</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8Java-Visual-VM-%E5%88%86%E6%9E%90%E6%97%A5%E5%BF%97"><span class="toc-text">3.使用Java Visual VM 分析日志</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B8%B8%E7%94%A8JVM%E5%8F%82%E6%95%B0%E5%8F%82%E8%80%83"><span class="toc-text">3.常用JVM参数参考</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-jvm%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98"><span class="toc-text">4.jvm优化实战</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E5%BC%80%E5%8F%91%E6%97%B6"><span class="toc-text">4.1 开发时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E4%B8%8A%E7%BA%BF%E7%9A%84%E6%97%B6%E5%80%99"><span class="toc-text">4.2 上线的时候</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%B0%83%E4%BC%98%E7%BB%8F%E9%AA%8C"><span class="toc-text">5.调优经验</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E6%80%BB%E7%BB%93"><span class="toc-text">四.总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%87%8D%E7%82%B9%E5%86%85%E5%AE%B9"><span class="toc-text">1.重点内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87"><span class="toc-text">2.面试必备</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/breeze/2a548e97.html" title="面试实战"><img src="/img/photo-1645943020355-305df166473d.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="面试实战"></a><div class="content"><a class="title" href="/breeze/2a548e97.html" title="面试实战">面试实战</a><time datetime="2024-02-29T02:43:59.000Z" title="发表于 2024-02-29 10:43:59">2024-02-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/breeze/4edde71e.html" title="Vue2-3-Vue3状态管理Pinia（十一）"><img src="/img/photo-1645943020355-305df166473d.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Vue2-3-Vue3状态管理Pinia（十一）"></a><div class="content"><a class="title" href="/breeze/4edde71e.html" title="Vue2-3-Vue3状态管理Pinia（十一）">Vue2-3-Vue3状态管理Pinia（十一）</a><time datetime="2024-02-03T13:31:25.000Z" title="发表于 2024-02-03 21:31:25">2024-02-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/breeze/da043fa1.html" title="Vue2-3-大事件管理系统（十）"><img src="/img/premium_photo-1695185954894-e9382c6f4da8.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Vue2-3-大事件管理系统（十）"></a><div class="content"><a class="title" href="/breeze/da043fa1.html" title="Vue2-3-大事件管理系统（十）">Vue2-3-大事件管理系统（十）</a><time datetime="2024-02-03T13:30:11.000Z" title="发表于 2024-02-03 21:30:11">2024-02-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/breeze/3a02bcd7.html" title="Vue2-3-Vue3入门（九）"><img src="/img/photo-1692708632140-ee01624d558d.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Vue2-3-Vue3入门（九）"></a><div class="content"><a class="title" href="/breeze/3a02bcd7.html" title="Vue2-3-Vue3入门（九）">Vue2-3-Vue3入门（九）</a><time datetime="2024-02-03T13:28:47.000Z" title="发表于 2024-02-03 21:28:47">2024-02-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/breeze/e727cc3a.html" title="Vue2-3-智慧商城项目（八）"><img src="/img/photo-1688475747590-d0db5e2412cb.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Vue2-3-智慧商城项目（八）"></a><div class="content"><a class="title" href="/breeze/e727cc3a.html" title="Vue2-3-智慧商城项目（八）">Vue2-3-智慧商城项目（八）</a><time datetime="2024-02-03T13:27:28.000Z" title="发表于 2024-02-03 21:27:28">2024-02-03</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/img/photo-1645943020355-305df166473d.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 <i id="heartbeat" class="fa fas fa-heartbeat"></i> 清风</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></head></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script src="/js/timing.js"></script><script id="canvas_nest" defer color="255,0,255" opacity="0.7" zindex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!0,document.body.addEventListener("input",POWERMODE)</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="天枢,天璇,天玑,天权,玉衡,开阳,瑶光" data-fontsize="15px" data-random="true" async></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>