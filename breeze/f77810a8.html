<!DOCTYPE html><html class="hide-aside" lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>随笔 | 清风</title><meta name="author" content="清风"><meta name="copyright" content="清风"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="写在最前：“随笔”“随笔”，有文就录，有感就发，有事就记，有理就说，率性而为，不必拘泥！  所以这篇文章不会有连续完整的知识体系，全部由一条条杂乱无章的知识点构成，只为记录平时学习中遇到的自己没有掌握好或新奇的觉得很有必要记录的东西！！   私有属性可以被继承吗？在Java中，私有属性不能直接被继承，因为私有属性只能在当前类中使用，其子类是无法直接访问的。但是，可以通过定义公共的Getter和Se"><meta property="og:type" content="article"><meta property="og:title" content="随笔"><meta property="og:url" content="https://mliutm.github.io/breeze/f77810a8.html"><meta property="og:site_name" content="清风"><meta property="og:description" content="写在最前：“随笔”“随笔”，有文就录，有感就发，有事就记，有理就说，率性而为，不必拘泥！  所以这篇文章不会有连续完整的知识体系，全部由一条条杂乱无章的知识点构成，只为记录平时学习中遇到的自己没有掌握好或新奇的觉得很有必要记录的东西！！   私有属性可以被继承吗？在Java中，私有属性不能直接被继承，因为私有属性只能在当前类中使用，其子类是无法直接访问的。但是，可以通过定义公共的Getter和Se"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://mliutm.github.io/img/photo-1645943020355-305df166473d.jpg"><meta property="article:published_time" content="2023-10-25T15:47:26.000Z"><meta property="article:modified_time" content="2024-03-14T09:31:15.817Z"><meta property="article:author" content="清风"><meta property="article:tag" content="知识杂谈"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://mliutm.github.io/img/photo-1645943020355-305df166473d.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://mliutm.github.io/breeze/f77810a8.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,top_n_per_article:1,unescape:!1,languages:{hits_empty:"找不到您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!1,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"随笔",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-03-14 17:31:15"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,a){0!==a&&(a=864e5*a,t={value:t,expiry:(new Date).getTime()+a},localStorage.setItem(e,JSON.stringify(t)))},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!((new Date).getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=o=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.getCSS=(o,n=!1)=>new Promise((t,e)=>{const a=document.createElement("link");a.rel="stylesheet",a.href=o,n&&(a.id=n),a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">169</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">82</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/img/photo-1645943020355-305df166473d.jpg)"><nav id="nav"><span id="blog-info"><a href="/" title="清风"><span class="site-name">清风</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">随笔</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-25T15:47:26.000Z" title="发表于 2023-10-25 23:47:26">2023-10-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-14T09:31:15.817Z" title="更新于 2024-03-14 17:31:15">2024-03-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">33.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>106分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="随笔"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><strong>写在最前：<a target="_blank" rel="noopener" href="https://zhidao.baidu.com/question/1863266447082385667.html">“随笔”“随笔”，有文就录，有感就发，有事就记，有理就说，率性而为，不必拘泥！</a></strong></p><blockquote><p>所以这篇文章不会有连续完整的知识体系，全部由一条条杂乱无章的知识点构成，只为记录平时学习中遇到的自己没有掌握好或新奇的觉得很有必要记录的东西！！</p></blockquote><hr><h3 id="私有属性可以被继承吗？"><a href="#私有属性可以被继承吗？" class="headerlink" title="私有属性可以被继承吗？"></a>私有属性可以被继承吗？</h3><p>在Java中，私有属性不能直接被继承，因为私有属性只能在当前类中使用，其子类是无法直接访问的。但是，可以通过定义公共的Getter和Setter方法来让子类间接访问和修改私有属性。另外，在子类中可以通过调用父类的构造函数或者父类中的公共方法来初始化或者获取父类中的私有属性。</p><hr><h3 id="这里面的属性是什么意思？"><a href="#这里面的属性是什么意思？" class="headerlink" title="&lt;insert id=&quot;insert&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot; keyColumn=&quot;id&quot;&gt;&lt;/insert&gt;这里面的属性是什么意思？"></a><code>&lt;insert id=&quot;insert&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot; keyColumn=&quot;id&quot;&gt;&lt;/insert&gt;</code>这里面的属性是什么意思？</h3><p>在MyBatis中，<code>&lt;insert&gt;</code>标签用于定义插入操作的SQL语句。其中，<code>useGeneratedKeys</code>、<code>keyProperty</code>和<code>keyColumn</code>是该标签的属性，具体含义如下：</p><ol><li><code>useGeneratedKeys</code>：指示是否使用自动生成的主键。当设置为<code>true</code>时，表示数据库会为插入的记录自动生成一个主键值，<strong>并将其返回给程序使用</strong>；当设置为<code>false</code>时，表示不使用自动生成的主键。</li><li><code>keyProperty</code>：指定用于接收生成的主键值的Java对象属性名。当<code>useGeneratedKeys</code>为<code>true</code>时，需要通过<code>keyProperty</code>设置将生成的主键值映射到哪个Java对象的属性上。</li><li><code>keyColumn</code>：指定数据库表中对应的主键列名。当<code>useGeneratedKeys</code>为<code>true</code>时，需要通过<code>keyColumn</code>设置生成的主键值对应的数据库列名。</li></ol><p>综合起来，<code>&lt;insert&gt;</code>中的这些属性的作用是告诉MyBatis在执行插入操作后，是否使用数据库自动生成的主键，并将其映射到Java对象的属性上，<strong>以便程序可以获取到插入记录生成的主键值</strong>。</p><hr><h3 id="ServletContextListener中方法的执行时机和作用？"><a href="#ServletContextListener中方法的执行时机和作用？" class="headerlink" title="ServletContextListener中方法的执行时机和作用？"></a>ServletContextListener中方法的执行时机和作用？</h3><p>在 Servlet API 中，<code>ServletContextListener</code> 接口表示一个监听器，它可以监听 ServletContext 对象的创建和销毁，并在这些事件发生时执行特定的逻辑。</p><p>具体来说，<code>ServletContextListener</code> 接口包含两个方法：</p><ul><li><code>contextInitialized(ServletContextEvent event)</code> ：当 ServletContext 对象被创建（即 web 应用启动）后，容器会调用该方法，通知所有实现了该接口的监听器 ServletContext 被创建。</li><li><code>contextDestroyed(ServletContextEvent event)</code> ：当 ServletContext 对象被销毁（即 web 应用停止）后，容器会调用该方法，通知所有实现了该接口的监听器 ServletContext 被销毁。</li></ul><p>这两个方法的执行时机分别在 web 应用启动和关闭时，可以在其中执行一些初始化和清理工作。例如，在<code>contextInitialized()</code> 方法中可以读取和解析一些配置文件、连接数据库等初始化操作；在<code>contextDestroyed()</code> 方法中可以释放资源、关闭数据库连接等清理操作。</p><p>值得注意的是，<code>contextInitialized()</code> 方法会在<code>Servlet</code> 的 init() 方法之前被执行，而<code>contextDestroyed()</code> 方法会在<code>Servlet</code> 的 destroy() 方法之后被执行。因此，在<code>contextInitialized()</code> 方法中不能依赖于任何<code>Servlet</code> 的初始化，而在<code>contextDestroyed()</code> 方法中也不应使用已经被销毁的<code>Servlet</code> 对象。</p><hr><h3 id="java中，加了-Configuration注解的类中，又在方法上加的-Bean注解有什么作用？可以不加吗？"><a href="#java中，加了-Configuration注解的类中，又在方法上加的-Bean注解有什么作用？可以不加吗？" class="headerlink" title="java中，加了@Configuration注解的类中，又在方法上加的@Bean注解有什么作用？可以不加吗？"></a>java中，加了@Configuration注解的类中，又在方法上加的@Bean注解有什么作用？可以不加吗？</h3><p>在Java中，加了@Configuration注解的类中，再在方法上加上@Bean注解的作用是将这些方法返回的对象注册为Spring容器中的Bean。通过在方法上使用@Bean注解，我们可以自定义Bean的创建方式，并将其交给Spring容器进行管理。这样，在其他地方可以通过依赖注入的方式来使用这些Bean。</p><p>@Configuration注解用于标识一个类是配置类，它主要作为Bean定义的源。同时，这个类也可以被组件扫描，就像普通的@Component一样，可以使用@Autowired或者@Inject注解进行注入。</p><p>而@Bean注解则用于声明一个Bean。当一个类中的方法被@Bean注解标记时，Spring容器会调用这些方法，并将其返回的对象注册为Bean。通过在方法上使用@Bean注解，我们可以自定义Bean的创建方式，并在需要的地方进行注入和使用。</p><p>可以不加@Configuration注解吗？答案是不能。@Configuration注解告诉Spring框架该类是一个配置类，如果不加这个注解，Spring无法识别该类中的@Bean注解，也就无法将其作为Bean注册到容器中。</p><p>也不能不加@Bean注解。因为加了@Configuration注解的类是一个配置类，告诉Spring框架该类中包含了一些Bean的定义。如果不在方法上加@Bean注解，Spring无法识别这些方法并将它们注册为Bean。所以必须在希望将方法返回的对象作为Bean注册到容器中时，在方法上加上@Bean注解。</p><p>总结起来，加了@Configuration注解的类中，再在方法上加上@Bean注解，可以将方法返回的对象注册为Spring容器中的Bean，以便在其他地方进行注入和使用。不加@Configuration注解，则无法识别@Bean注解，无法注册为Bean。也必须加上@Bean注解，否则Spring无法识别并注册这些方法返回的对象。</p><hr><h3 id="前端登录界面中，对获取验证码的按钮进行倒计时的设计（发送验证码）："><a href="#前端登录界面中，对获取验证码的按钮进行倒计时的设计（发送验证码）：" class="headerlink" title="前端登录界面中，对获取验证码的按钮进行倒计时的设计（发送验证码）："></a>前端登录界面中，对获取验证码的按钮进行倒计时的设计（发送验证码）：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">sendCode</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//1.获取用户的手机号和图形验证码</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="property">regForm</span>.<span class="property">imgCode</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">errMsg</span>=<span class="string">&quot;请填写图形验证码&quot;</span>; <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="property">regForm</span>.<span class="property">phone</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">errMsg</span>=<span class="string">&quot;请填手机号&quot;</span>; <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">errMsg</span>=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> uuid = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;rdmuid&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (uuid)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">regForm</span>.<span class="property">uuid</span>=uuid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按钮不可点击</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">btnDisable</span>=<span class="literal">true</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$http</span>.<span class="title function_">post</span>(<span class="string">&quot;/code/phone&quot;</span>,<span class="variable language_">this</span>.<span class="property">regForm</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(res.<span class="property">data</span>.<span class="property">success</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> time=<span class="number">60</span>;</span><br><span class="line">            <span class="keyword">let</span> that = <span class="variable language_">this</span>;  <span class="comment">// this指代当前的vue对象，把vue对象赋值给变量that</span></span><br><span class="line">            <span class="keyword">let</span> intervalId = <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="comment">//动态的设置按钮的文字</span></span><br><span class="line">                <span class="keyword">if</span>(time)&#123;</span><br><span class="line">                    that.<span class="property">btnText</span>=time-- +<span class="string">&quot;s&quot;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    that.<span class="property">btnDisable</span>=<span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">//把文字设置为重发</span></span><br><span class="line">                    that.<span class="property">btnText</span>=<span class="string">&quot;重新发送&quot;</span>;</span><br><span class="line">                    <span class="comment">//结束定时任务--文字变为重发</span></span><br><span class="line">                    <span class="built_in">clearInterval</span>(intervalId);<span class="comment">//移出指定的定时任务</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="number">1000</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">errMsg</span>=res.<span class="property">data</span>.<span class="property">message</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><hr><h3 id="以下代码中，Throwable参数的作用？"><a href="#以下代码中，Throwable参数的作用？" class="headerlink" title="以下代码中，Throwable参数的作用？"></a>以下代码中，Throwable参数的作用？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BusinessException</span><span class="params">(String message, Throwable cause)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(message, cause);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先：Throwable类是Java语言中所有错误（errors）和异常（exceptions）的父类。</p><p>在你提供的代码中，cause 是一个参数，用于构造 BusinessException 的构造函数。在这里，cause 是一个 Throwable 类型的对象，通常用于表示异常的原因或根本原因。它允许你将一个异常与另一个异常相关联，以便更好地追踪问题的根本来源。</p><p>在构造异常时，cause 参数允许你指定在抛出当前异常时，是什么原因导致了这个异常。这有助于建立异常链，使得在异常处理中能够更好地理解问题的起因。</p><p>例如，如果在某个方法内部捕获了一个低级别的异常，但你希望抛出一个自定义异常，以便更清晰地传达问题的本质，你可以将低级别异常作为 cause 参数传递给自定义异常，以便后续代码可以访问原始异常信息。</p><p>这种做法有助于调试和排查问题，因为它保留了异常的层次结构，使得你可以追溯到异常发生的原因。</p><hr><h3 id="java中-serialVersionUID-是什么？作用是什么？"><a href="#java中-serialVersionUID-是什么？作用是什么？" class="headerlink" title="java中 serialVersionUID 是什么？作用是什么？"></a>java中 serialVersionUID 是什么？作用是什么？</h3><p>在Java中，serialVersionUID是一个用于序列化的静态常量。它用来标识类的版本，以确保在序列化和反序列化对象时的兼容性。</p><p>当一个可序列化的类被修改后，例如添加或删除了字段、改变了字段类型，如果没有显式地定义serialVersionUID，Java编译器会自动生成一个默认的serialVersionUID。这个默认值依赖于类的结构，因此在类结构发生变化时可能会导致生成不同的默认值。这样就可能导致在反序列化时出现InvalidClassException，因为默认的serialVersionUID与序列化时的版本不匹配。</p><p>通过显式地定义serialVersionUID，可以确保在类的结构变化后仍能正确地反序列化对象，即使类的实现发生更改。通常情况下，建议在可序列化的类中定义private static final long serialVersionUID字段，并根据需要手动指定其值。</p><p><font color="red">总结一下，serialVersionUID的作用是提供一个固定的标识符，以确保序列化和反序列化操作的兼容性，避免由类的结构变化引起的问题。</font></p><hr><h3 id="Maven中dependencyManagement的作用"><a href="#Maven中dependencyManagement的作用" class="headerlink" title="Maven中dependencyManagement的作用"></a>Maven中dependencyManagement的作用</h3><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1948927">Maven中dependencyManagement的作用</a></p><hr><h3 id="ThreadLocal工具类封装"><a href="#ThreadLocal工具类封装" class="headerlink" title="ThreadLocal工具类封装"></a>ThreadLocal工具类封装</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/167955824">工具类封装</a></p><hr><h3 id="什么是QPS"><a href="#什么是QPS" class="headerlink" title="什么是QPS"></a>什么是QPS</h3><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1807423">秒懂QPS、TPS、PV、UV、GMV、IP、RPS</a></p><hr><h3 id="如何定义SpringMVC的拦截器"><a href="#如何定义SpringMVC的拦截器" class="headerlink" title="如何定义SpringMVC的拦截器"></a>如何定义SpringMVC的拦截器</h3><p>SpringMVC 的拦截器主要用于拦截用户的请求并做相应的处理，通常应用在权限验证、判断登录等功</p><p>能上第1步，定义拦截器：可以实现 HandlerInterceptor 接口来自定义拦截器，接口定义了三个方法，</p><p>preHandler方法是在请求到达处理器之前执行，postHandler方法是在请求经过处理器之后、解析试图</p><p>之前执行，afterCompletion方法是在视图渲染之后、返回客户端之前执行</p><p>第2步，配置拦截器：在springmvc的配置文件xml或者配置类中，配置所有拦截路径，以及需要放行的路径</p><hr><h3 id="HandlerInterceptor和HandlerInterceptorAdapter的区别"><a href="#HandlerInterceptor和HandlerInterceptorAdapter的区别" class="headerlink" title="HandlerInterceptor和HandlerInterceptorAdapter的区别"></a>HandlerInterceptor和HandlerInterceptorAdapter的区别</h3><p>HandlerInterceptor是接口，我们可以实现该接口来定义拦截器，HandlerInterceptorAdapter是抽象</p><p>类，它实现了HandlerInterceptor接口的子接口AsyncHandlerInterceptor，我们可以继承该类来定义</p><p>拦截器，它简化拦截器的实现，默认preHandler返回true</p><hr><h3 id="单机下redis最多可以存多少个key？"><a href="#单机下redis最多可以存多少个key？" class="headerlink" title="单机下redis最多可以存多少个key？"></a>单机下redis最多可以存多少个key？</h3><p>从官网中找到了答案，可见一个单实例的redis最多能支持2^32个键，差不多就是2.5亿个</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">What is <span class="keyword">the</span> maximum <span class="built_in">number</span> <span class="keyword">of</span> <span class="built_in">keys</span> <span class="keyword">a</span> single Redis instance can hold? <span class="keyword">and</span> what <span class="keyword">the</span> <span class="built_in">max</span> <span class="built_in">number</span> <span class="keyword">of</span> elements <span class="keyword">in</span> <span class="keyword">a</span> Hash, List, Set, Sorted Set?</span><br><span class="line">Redis can handle up <span class="built_in">to</span> <span class="number">2</span>^<span class="number">32</span> <span class="built_in">keys</span>, <span class="keyword">and</span> was tested <span class="keyword">in</span> practice <span class="built_in">to</span> handle <span class="keyword">at</span> least <span class="number">250</span> million <span class="built_in">keys</span> per instance.</span><br><span class="line">Every hash, list, <span class="built_in">set</span>, <span class="keyword">and</span> sorted <span class="built_in">set</span>, can hold <span class="number">2</span>^<span class="number">32</span> elements.</span><br><span class="line">In other <span class="keyword">words</span> your limit is likely <span class="keyword">the</span> available memory <span class="keyword">in</span> your <span class="keyword">system</span>.</span><br></pre></td></tr></table></figure><hr><h3 id="Redis实例支持的单个Key和Value数据大小是否有限制？"><a href="#Redis实例支持的单个Key和Value数据大小是否有限制？" class="headerlink" title="Redis实例支持的单个Key和Value数据大小是否有限制？"></a>Redis实例支持的单个Key和Value数据大小是否有限制？</h3><ul><li><p>Key的大小上限为512M。</p><p>建议key的大小不超过1KB，这样既节约存储空间，也利于Redis进行检索。</p></li><li><p>String类型的value值上限为512M。</p></li><li><p>集合、链表、哈希等key类型，单个元素的value上限为512M。</p><p>事实上，集合、链表、哈希都可以看成由String类型的key按照一定的映射关系组合而成。</p></li></ul><p>同时，请注意避免对大Value进行长时间高并发写入，这样会影响网络传输效率，也会增加redis-server的内部处理耗时，从而导致请求时延较大</p><hr><h3 id="MVCC机制原理"><a href="#MVCC机制原理" class="headerlink" title="MVCC机制原理"></a>MVCC机制原理</h3><p>MVCC（Multi-Version Concurrency Control，多版本并发控制）是一种用于高性能读写操作的并发控制技术。它允许多个读者和写者在同一时间访问同一份数据，并通过控制版本的生成和更新来保证数据的一致性和完整性。MVCC机制主要应用于数据库系统、缓存系统以及分布式系统等领域。</p><p>MVCC机制的原理可以概括为以下几点：</p><ol><li><p>数据版本化：对于每个数据对象，系统为其生成一个版本号。当数据被读取时，读取到的数据版本号即为该数据对象的当前版本。写入新数据时，系统会为该数据生成一个新的版本号。</p></li><li><p>读取操作：当一个读取操作请求发出时，系统会查找当前版本号小于等于请求版本号的数据对象。这意味着读取操作可以访问到较旧的数据版本，从而避免了读写冲突。</p></li><li><p>写入操作：写入操作时，系统会为数据对象生成一个新的版本号。在写入完成后，其他读取操作只能读取到版本号大于写入操作版本号的数据对象，从而实现了对新数据的保护。</p></li><li><p>事务处理：为了保证数据的一致性，MVCC通常与事务处理结合使用。在读取和写入数据时，事务会记录数据的版本号。在事务提交时，系统会检查事务中的所有操作是否符合MVCC规则，以确保数据的一致性。</p></li><li><p>过期版本处理：为了避免内存溢出，MVCC机制需要对过期的数据版本进行清理。通常，系统会设置一个最大版本号，当数据版本号超过最大版本号时，系统会自动清理过期版本的数据。</p></li></ol><p>总之，MVCC机制通过数据版本化、读写操作的控制以及事务处理等方式，实现了在高并发场景下对数据的一致性和完整性的保护。这使得系统能够在不影响性能的前提下，允许多个读写操作同时访问同一份数据。</p><hr><h3 id="MVCC是乐观锁的实现吗？"><a href="#MVCC是乐观锁的实现吗？" class="headerlink" title="MVCC是乐观锁的实现吗？"></a>MVCC是乐观锁的实现吗？</h3><p>MVCC（多版本并发控制）并不是乐观锁的实现，而是一种独立的并发控制技术。然而，MVCC机制在实际应用中可以与乐观锁结合使用，以提高系统的并发性能。</p><p>乐观锁是一种假设不会发生并发冲突的锁机制，主要通过在提交操作时检查数据是否被其他事务修改来避免冲突。在乐观锁中，事务在提交更新操作之前不会对数据加锁，而是在提交时检查数据是否发生冲突。如果发生冲突，则提交失败，否则成功。</p><p>MVCC机制则是在数据表中添加一个版本号字段，对于同一数据，不同版本号的数据可以同时存在。在读取数据时，只读取版本号小于等于请求版本号的数据。写入数据时，为数据生成一个新的版本号。这样，MVCC机制可以避免读写冲突，提高系统的并发性能。</p><p>综上，MVCC机制并不是乐观锁的实现，但它们可以结合使用。在实际应用中，乐观锁可以用于解决数据在读取和写入过程中的冲突，而MVCC机制则可以用于避免读写冲突，从而提高系统的并发性能。</p><hr><h3 id="java中set集合的遍历方式有哪些？"><a href="#java中set集合的遍历方式有哪些？" class="headerlink" title="java中set集合的遍历方式有哪些？"></a>java中set集合的遍历方式有哪些？</h3><p>在Java中，Set集合的遍历方式有以下几种：</p><ol><li><p>使用迭代器（Iterator）进行遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 添加元素到set...</span></span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; iterator = set.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="comment">// 对元素进行处理...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用增强型for循环（foreach）进行遍历：</p><p><strong><font color="red">注意：不能使用普通for循环遍历set集合，因为普通for循环是使用下标进行遍历，而set集合中的元素没有下标。</font></strong></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 添加元素到set...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String element : set) &#123;</span><br><span class="line">    <span class="comment">// 对元素进行处理...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用Java 8的流（Stream）进行遍历：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 添加元素到set...</span></span><br><span class="line"></span><br><span class="line">set.stream().forEach(element -&gt; &#123;</span><br><span class="line">    <span class="comment">// 对元素进行处理...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><p>这些遍历方式都可以用于遍历Set集合中的元素，并对每个元素进行处理。使用不同的遍历方式可以根据具体的需求选择合适的方式。</p><hr><h3 id="java中TreeSet的排序规则"><a href="#java中TreeSet的排序规则" class="headerlink" title="java中TreeSet的排序规则"></a>java中TreeSet的排序规则</h3><p>在Java中，TreeSet是基于红黑树实现的有序集合，它会根据元素的自然排序或者自定义的比较器进行排序。</p><p>如果元素实现了Comparable接口，TreeSet会使用元素的compareTo方法进行排序。比如，对于String类型的元素，默认按照字典序进行排序。</p><p>如果元素没有实现Comparable接口，可以在创建TreeSet时传入自定义的Comparator比较器来指定排序规则。比如，对于自定义的类，可以实现Comparator接口并重写compare方法来定义排序规则。</p><p>以下是使用Comparator比较器对TreeSet进行排序的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(Comparator.reverseOrder());</span><br><span class="line">        set.add(<span class="number">3</span>);</span><br><span class="line">        set.add(<span class="number">1</span>);</span><br><span class="line">        set.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> element : set) &#123;</span><br><span class="line">            System.out.println(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们创建了一个TreeSet，并传入了一个自定义的Comparator比较器，该比较器以降序排序。输出结果将是3、2、1。</p><p>需要注意的是，TreeSet的排序是在插入元素时自动完成的，每次插入元素后都会进行排序。因此，对于已经存在的TreeSet，如果想要改变排序规则，需要先清空集合，再重新插入元素。</p><hr><h3 id="java开发注释应该写在哪些地方？接口方法和接口对应的实现方法上都需要写注释吗？"><a href="#java开发注释应该写在哪些地方？接口方法和接口对应的实现方法上都需要写注释吗？" class="headerlink" title="java开发注释应该写在哪些地方？接口方法和接口对应的实现方法上都需要写注释吗？"></a>java开发注释应该写在哪些地方？接口方法和接口对应的实现方法上都需要写注释吗？</h3><p>在Java开发中，注释是用来解释代码的作用、实现方式、注意事项等信息的。注释通常写在以下几个地方：</p><ol><li><p>类（Class）或接口（Interface）：在类或接口的定义之前，可以写一段注释来解释该类或接口的作用、设计意图等。</p></li><li><p>方法（Method）：在方法定义之前，可以写一段注释来解释该方法的功能、参数、返回值等。</p></li><li><p>属性（Field）：在属性定义之前，可以写一段注释来解释该属性的用途、取值范围等。</p></li><li><p>构造方法（Constructor）：在构造方法定义之前，可以写一段注释来解释该构造方法的作用、参数等。</p></li></ol><p>对于接口方法和接口对应的实现方法，原则上都应该写注释。接口方法的注释可以解释该方法的作用、参数、返回值等，而实现方法的注释可以解释该方法的具体实现逻辑、注意事项等。</p><p>写注释的好处是可以提高代码的可读性和可维护性，方便其他开发人员理解代码的意图，减少潜在的bug。因此，在开发过程中，建议养成良好的注释习惯，对重要的代码块进行注释。</p><hr><h3 id="java开发中，遇到陌生的类需要调用类中的方法，但是对方法的功能不熟悉，该如何快速确定调用哪个方法可以达到预期的效果呢？"><a href="#java开发中，遇到陌生的类需要调用类中的方法，但是对方法的功能不熟悉，该如何快速确定调用哪个方法可以达到预期的效果呢？" class="headerlink" title="java开发中，遇到陌生的类需要调用类中的方法，但是对方法的功能不熟悉，该如何快速确定调用哪个方法可以达到预期的效果呢？"></a>java开发中，遇到陌生的类需要调用类中的方法，但是对方法的功能不熟悉，该如何快速确定调用哪个方法可以达到预期的效果呢？</h3><p>当遇到陌生的类需要调用其中的方法时，可以按照以下步骤进行快速确定调用哪个方法可以达到预期的效果：</p><ol><li><p>查阅文档：首先查看该类的文档或说明，了解该类的作用、属性和方法，以及每个方法的功能和用途。文档通常会提供方法的详细描述和示例代码，帮助你理解如何正确地使用这些方法。</p></li><li><p>IDE 的自动补全功能：在集成开发环境（IDE）中，通常提供了自动补全功能。当你输入类的实例对象或类名时，IDE 会显示出可用的方法列表。阅读方法名和参数列表，根据命名和注释来判断哪个方法可能与你的需求最匹配。选择一个看起来合适的方法并尝试调用之。</p></li><li><p>审查源代码：如果没有文档或者文档不够详细，可以查看该类的源代码。阅读方法的实现代码可以让你更好地理解方法的功能和工作原理，从而确定哪个方法可以实现你的预期效果。</p></li><li><p>使用调试器：如果以上方法仍无法确定正确的方法，可以使用调试器来对代码进行调试。在运行时逐步执行代码并观察每个方法的行为，找到满足你需求的方法。</p></li><li><p>查阅相关资源：如果以上方法仍然不够，可以查阅相关的博客、论坛或问答网站，寻找有关该类或方法的经验分享和使用示例。</p></li></ol><p>最重要的是要不断学习和实践，熟悉常用的类和方法，以及如何有效地查找和使用相关资源。这样在遇到陌生的类时，就能更快地确定使用方法以达到预期的效果。</p><hr><h3 id="java中，基本数据类型和引用数据类型的区别？"><a href="#java中，基本数据类型和引用数据类型的区别？" class="headerlink" title="java中，基本数据类型和引用数据类型的区别？"></a>java中，基本数据类型和引用数据类型的区别？</h3><p>在Java中，基本数据类型和引用数据类型有以下几个主要区别：</p><ol><li><p>存储方式：基本数据类型的值直接存储在栈内存中，而引用数据类型存储在堆内存中，栈内存中保存的是引用地址。</p></li><li><p>内存占用：基本数据类型占用的内存大小是固定的，不会改变，而引用数据类型的大小取决于实例所占内存大小和地址的长度。</p></li><li><p>赋值方式：基本数据类型的赋值是将实际的值进行复制，而引用数据类型的赋值是将引用地址进行复制，指向同一个存储地址。</p></li><li><p>默认值：基本数据类型有默认值，例如int默认值为0，boolean默认值为false，而引用数据类型默认值为null。</p></li><li><p>传递参数：基本数据类型作为方法参数传递时，是传递值的副本，而引用数据类型作为方法参数传递时，是传递引用的副本，实际上仍然指向同一块内存区域。</p></li></ol><p>基本数据类型包括整型（byte, short, int, long）、浮点型（float, double）、字符型（char）、布尔型（boolean）等，而引用数据类型包括类、接口、数组等。通过了解这些区别，开发人员可以更好地理解和应用Java中的数据类型。</p><hr><h3 id="Rocket中，Broker是什么？有什么作用？"><a href="#Rocket中，Broker是什么？有什么作用？" class="headerlink" title="Rocket中，Broker是什么？有什么作用？"></a>Rocket中，Broker是什么？有什么作用？</h3><p>在 Apache RocketMQ 中，Broker 是指消息中间件的服务器节点，主要用于存储和转发消息。Broker 在 RocketMQ 中扮演着核心角色，负责接收客户端发送的消息，存储消息并将消息传递给消息的消费者。</p><p>Broker 的主要作用包括：</p><ol><li><p>接收消息： 当客户端发送消息时，消息会被发送到 Broker 服务器，该服务器负责接收并存储这些消息。</p></li><li><p>存储消息：Broker 负责将接收到的消息存储在磁盘中，以确保消息的可靠性和持久性。</p></li><li><p>转发消息：当消息的消费者准备消费消息时，Broker 负责将消息传递给消费者，确保消息被正确地分发和处理。</p></li><li><p>管理主题和队列：Broker 负责管理主题和队列的创建、订阅和维护，以实现消息的发布和订阅功能。</p></li></ol><p>总的来说，Broker 是 RocketMQ 消息中间件的核心组件，负责接收、存储和转发消息，同时管理消息的主题和队列，是实现消息发布和订阅的关键部分。</p><hr><h3 id="享元模式和常量池的区别"><a href="#享元模式和常量池的区别" class="headerlink" title="享元模式和常量池的区别"></a>享元模式和常量池的区别</h3><h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><p>享元模式是一种设计模式，它可以减少创建对象的开销。它通过共享的对象来实现这一点，以便可以重复使用这些对象，而不是为每个操作创建一个新的对象。</p><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>常量池是一种存储常量数据的内存区域。常量池由Java虚拟机（JVM）管理，它是一个共享的资源，可以被所有线程访问。常量池中的数据不能被修改，并且在程序的整个生命周期中都可用。</p><h4 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h4><table><thead><tr><th>特征</th><th>享元模式</th><th>常量池</th></tr></thead><tbody><tr><td>目的</td><td>减少创建对象的开销</td><td>存储常量数据</td></tr><tr><td>实现</td><td>通过共享对象来实现</td><td>通过共享内存区域来实现</td></tr><tr><td>范围</td><td>可以被多个对象使用</td><td>只被一个对象使用</td></tr><tr><td>可修改性</td><td>可以被修改</td><td>不能被修改</td></tr><tr><td>生命周期</td><td>在程序的整个生命周期中都可用</td><td>在程序的整个生命周期中都可用</td></tr><tr><td>使用场景</td><td>当需要创建大量对象时</td><td>当需要存储常量数据时</td></tr></tbody></table><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>享元模式可以用来减少创建字符串对象的开销。字符串对象是不可变的，这意味着一旦创建，就不能修改。因此，如果我们创建大量字符串对象，那么这些对象将永远不会被修改，并且它们将占用大量的内存空间。为了减少这种浪费，我们可以使用享元模式来共享字符串对象。我们可以将所有字符串对象存储在一个池中，然后当我们需要一个字符串对象时，我们可以从池中获取它，而不是创建一个新的字符串对象。</p><p>常量池可以用来存储常量数据，例如字符串字面量、数字字面量和布尔字面量。常量池中的数据不能被修改，并且在程序的整个生命周期中都可用。这使得常量池非常适合存储需要在整个程序中使用的常量数据。</p><hr><h3 id="JDK，JRE，JVM之间的区别和联系"><a href="#JDK，JRE，JVM之间的区别和联系" class="headerlink" title="JDK，JRE，JVM之间的区别和联系"></a>JDK，JRE，JVM之间的区别和联系</h3><p><strong>JDK (Java Development Kit)</strong></p><ul><li>JDK是Java语言的开发工具包，它包含了编译器、解释器、调试器和其他开发工具。</li><li>JDK是Java开发者必备的工具，它可以用来开发Java应用程序。</li></ul><p><strong>JRE (Java Runtime Environment)</strong></p><ul><li>JRE是Java语言的运行时环境，它包含了JVM和Java核心库。</li><li>JRE是Java应用程序运行所必需的，它可以使Java应用程序在计算机上运行。</li></ul><p><strong>JVM (Java Virtual Machine)</strong></p><ul><li>JVM是Java虚拟机，它是一种软件，可以将Java字节码转换为机器码，并执行Java字节码。</li><li>JVM是Java语言的核心，它可以使Java应用程序在不同的操作系统上运行。</li></ul><p><strong>区别</strong></p><ul><li>JDK包含了JRE和Java开发工具，而JRE只包含了JVM和Java核心库。</li><li>JDK可以用来开发Java应用程序，而JRE只能用来运行Java应用程序。</li><li>JVM是JRE和JDK的核心组件，它可以将Java字节码转换为机器码，并执行Java字节码。</li></ul><p><strong>联系</strong></p><ul><li>JDK、JRE和JVM都是Java语言的必备组件。</li><li>JDK包含了JRE和Java开发工具，而JRE只包含了JVM和Java核心库。</li><li>JVM是JRE和JDK的核心组件，它可以将Java字节码转换为机器码，并执行Java字节码。</li></ul><p><strong>示例</strong></p><ul><li>当我们开发Java应用程序时，我们需要使用JDK。</li><li>当我们运行Java应用程序时，我们需要使用JRE。</li><li>当JVM执行Java应用程序时，它会将Java字节码转换为机器码，并执行Java字节码。</li></ul><p><strong>注意</strong></p><ul><li>JDK、JRE和JVM都是Oracle公司开发的，但它们也是免费的。</li><li>JDK、JRE和JVM可以在Oracle公司的网站上下载。</li></ul><hr><h3 id="sql中，通过中间表关联和通过外键关联有什么区别？"><a href="#sql中，通过中间表关联和通过外键关联有什么区别？" class="headerlink" title="sql中，通过中间表关联和通过外键关联有什么区别？"></a>sql中，通过中间表关联和通过外键关联有什么区别？</h3><ol><li><p><strong>关联类型：</strong></p><ul><li><strong>中间表关联：</strong> 使用一个中间表来建立两个表之间的关系。中间表包含两个表的主键作为外键，并且通过这些外键连接两个表。</li><li><strong>外键关联：</strong> 在两个表中，一个表的主键作为另一个表的列（外键）。外键关联不需要中间表，而是在两个表之间直接建立关系。</li></ul></li><li><p><strong>性能：</strong></p><ul><li><strong>中间表关联：</strong> 性能通常比外键关联差。这是因为中间表关联需要在三个表之间进行连接，而外键关联只需要在两个表之间进行连接。</li><li><strong>外键关联：</strong> 性能通常比中间表关联好。这是因为外键关联只需要在两个表之间进行连接，并且外键索引可以提高查询的性能。</li></ul></li><li><p><strong>维护：</strong></p><ul><li><strong>中间表关联：</strong> 维护起来更复杂。这是因为中间表需要额外的维护，例如添加、删除和更新记录。</li><li><strong>外键关联：</strong> 维护起来更简单。这是因为外键关联不需要额外的维护，并且外键约束可以确保数据的一致性。</li></ul></li><li><p><strong>灵活性：</strong></p><ul><li><strong>中间表关联：</strong> 更灵活。这是因为中间表可以存储更多信息，并且可以用于创建更复杂的查询。</li><li><strong>外键关联：</strong> 不那么灵活。这是因为外键关联只能存储两个表的主键，并且只能用于创建简单的查询。</li></ul></li><li><p><strong>安全性：</strong></p><ul><li><strong>中间表关联：</strong> 更安全。这是因为中间表可以存储敏感信息，并且可以防止未经授权的用户访问这些信息。</li><li><strong>外键关联：</strong> 不那么安全。这是因为外键关联不能存储敏感信息，并且未经授权的用户可以访问这些信息。</li></ul></li></ol><p>总的来说，中间表关联和外键关联都有自己的优缺点。在选择哪种关联类型时，需要考虑以下因素：</p><ul><li>性能要求</li><li>维护要求</li><li>灵活性要求</li><li>安全性要求</li></ul><hr><h3 id="数据库表设计中，当出现多对多的关系时，是用中间表进行关联还是通过外键进行关联，为什么？"><a href="#数据库表设计中，当出现多对多的关系时，是用中间表进行关联还是通过外键进行关联，为什么？" class="headerlink" title="数据库表设计中，当出现多对多的关系时，是用中间表进行关联还是通过外键进行关联，为什么？"></a>数据库表设计中，当出现多对多的关系时，是用中间表进行关联还是通过外键进行关联，为什么？</h3><p>当数据库表设计中存在多对多的关系时，通常使用中间表进行关联，而不是直接通过外键进行关联。这是因为使用中间表可以更好地表示和处理多对多关系，同时也更灵活和易于扩展。</p><p>使用中间表进行多对多关系的关联的主要优点包括：</p><ol><li><p>灵活性和扩展性：中间表可以存储额外的信息，如关联关系的属性或元数据。如果直接通过外键进行关联，这种灵活性和扩展性就难以实现。</p></li><li><p>更好地符合关系数据库范式：通过中间表可以更好地符合数据库的范式要求，使得数据存储结构更为规范化和清晰。</p></li><li><p>更容易处理复杂的多对多关系：通过中间表可以更容易地处理复杂的多对多关系，如“多个实体与多个实体之间的关系”。</p></li><li><p>更好的性能：中间表可以更好地优化查询性能，减少关联查询的复杂度，尤其在数据量较大的情况下，能够提高查询效率。</p></li></ol><p>总之，通过中间表进行多对多关系的关联能够更好地满足数据库设计范式要求，同时也更加灵活、易于扩展和优化查询性能。因此，通常在数据库表设计中出现多对多的关系时，使用中间表进行关联是更为合适的选择。</p><hr><h3 id="java开发中常用标记有哪些？适用于什么场景，例如：-TODO"><a href="#java开发中常用标记有哪些？适用于什么场景，例如：-TODO" class="headerlink" title="java开发中常用标记有哪些？适用于什么场景，例如：@TODO"></a>java开发中常用标记有哪些？适用于什么场景，例如：@TODO</h3><p>在Java开发中，常用的标记包括：</p><ol><li><p>@TODO：用于标记代码中需要未来完成或改进的地方，便于开发人员定位和跟踪待办事项。</p></li><li><p>@Deprecated：用于标记代码中已经过时或不推荐使用的部分，提醒开发人员应该使用替代方案。</p></li><li><p>@Override：标记被注解的方法是重写父类的方法，能够提高代码可读性和可维护性。</p></li><li><p>@SuppressWarnings：用于抑制特定类型的编译器警告，如未检查的类型转换、废弃等警告。</p></li><li><p>@SuppressWarnings：用于抑制特定类型的编译器警告，如未检查的类型转换、废弃等警告。</p></li><li><p>@Override：标记被注解的方法是重写父类的方法，能够提高代码可读性和可维护性。</p></li></ol><p>这些标记能够提高代码的可读性、可维护性和可靠性，对于代码的维护和开发过程中都很有帮助。</p><hr><h3 id="java中，泛型的上限和下限是指的什么？有什么作用？"><a href="#java中，泛型的上限和下限是指的什么？有什么作用？" class="headerlink" title="java中，泛型的上限和下限是指的什么？有什么作用？"></a>java中，泛型的上限和下限是指的什么？有什么作用？</h3><p>在Java中，泛型的上限和下限是指在定义泛型类、泛型接口或泛型方法时，限定泛型的范围的语法。上限和下限分别使用<code>extends</code>和<code>super</code>关键字进行定义。</p><ul><li><p>上限（Upper Bound）：使用 <code>extends</code> 关键字来定义，表示泛型参数必须是指定类型或其子类型。例如，<code>&lt;? extends Number&gt;</code> 表示泛型参数必须是<code>Number</code>或其子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(List&lt;T&gt; list)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>下限（Lower Bound）：使用 <code>super</code> 关键字来定义，表示泛型参数必须是指定类型或其父类型。例如，<code>&lt;? super Integer&gt;</code> 表示泛型参数必须是<code>Integer</code>或其父类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addToList</span><span class="params">(List&lt;? <span class="built_in">super</span> Integer&gt; list)</span> &#123;</span><br><span class="line">    list.add(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>作用：</p><ol><li><p><strong>安全性</strong>：通过使用上限和下限可以在编译时进行类型检查，确保只能传入符合要求的类型，从而避免在运行时发生类型错误。</p></li><li><p><strong>灵活性</strong>：通过泛型的上限和下限，可以在一定程度上增加泛型类型的灵活性，允许在不同的场景下使用不同的类型约束，从而使得泛型更具有通用性。</p></li><li><p><strong>代码复用</strong>：通过定义泛型的上限和下限，可以使得代码更加灵活，从而提高代码的可重用性和扩展性。</p></li></ol><hr><h3 id="RabbitMQ和RocketMQ的异同点？"><a href="#RabbitMQ和RocketMQ的异同点？" class="headerlink" title="RabbitMQ和RocketMQ的异同点？"></a>RabbitMQ和RocketMQ的异同点？</h3><p>RabbitMQ和RocketMQ都是消息中间件系统，用于实现分布式系统之间的消息传递和交换。它们在功能和特性上有一些相似之处，但也有一些明显的区别。</p><p>异同点：</p><ol><li>开发语言：RabbitMQ是使用Erlang语言开发的，而RocketMQ是使用Java语言开发的。</li><li>支持的协议：RabbitMQ支持AMQP协议，而RocketMQ支持自定义的MQTT协议。</li><li>分布式特性：RocketMQ专注于支持大规模分布式部署，并提供了高可用性和高性能的特性，而RabbitMQ的分布式特性相对较弱。</li><li>消息顺序性：RocketMQ具有较好的消息顺序性，能够保证消息的有序性，而RabbitMQ在消息顺序性上不如RocketMQ。</li><li>集成方式：RabbitMQ更加适用于与各种编程语言和平台集成，而RocketMQ更适用于Java生态系统。</li></ol><p>总的来说，RabbitMQ更适合实现轻量级的消息传递系统，而RocketMQ更适合构建大规模分布式系统的消息通信。选择哪个取决于具体的需求和项目背景。</p><hr><h3 id="java，定时任务的解决方案有哪些？给出示例"><a href="#java，定时任务的解决方案有哪些？给出示例" class="headerlink" title="java，定时任务的解决方案有哪些？给出示例"></a>java，定时任务的解决方案有哪些？给出示例</h3><p>在Java中，有多种方式可以实现定时任务的解决方案。以下是一些常见的解决方案，以及它们的简单示例：</p><ol><li><p>使用Timer类和TimerTask类：<br>Timer类和TimerTask类是java.util包中提供的定时任务调度器。Timer类用于安排指定的任务在指定的时间执行，而TimerTask类则表示一个可以被Timer调度的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerTaskExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TimerTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;定时任务执行&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">        timer.schedule(task, <span class="number">1000</span>, <span class="number">1000</span>); <span class="comment">// 1秒后开始执行，每隔1秒执行一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用ScheduledExecutorService类：<br>ScheduledExecutorService是Java 5中新增加的类，用于安排任务在指定的时间执行，支持固定频率或者固定延迟执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledExecutorServiceExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">        executor.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;定时任务执行&quot;</span>);</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS); <span class="comment">// 1秒后开始执行，每隔1秒执行一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用Spring的@Scheduled注解：<br>在Spring框架中，可以使用@Scheduled注解来定义定时执行的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledTask</span> &#123;</span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = 1000)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scheduledTask</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;定时任务执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这些示例展示了不同的方式来实现定时任务，在实际应用中可以根据具体的需求选择合适的解决方案。</p><hr><h3 id="java开发的在线课堂系统中，怎样设置课程置顶功能"><a href="#java开发的在线课堂系统中，怎样设置课程置顶功能" class="headerlink" title="java开发的在线课堂系统中，怎样设置课程置顶功能"></a>java开发的在线课堂系统中，怎样设置课程置顶功能</h3><p>在Java开发的在线课堂系统中，要设置课程置顶功能，可以按照以下步骤进行操作：</p><ol><li><p>在数据库中创建一个字段用来标识课程是否置顶，例如可以创建一个名为 “isTop” 的布尔类型字段。</p></li><li><p>在后端的课程管理模块中，添加一个设置课程置顶的接口，通过这个接口可以将指定课程设置为置顶状态。在接口中，需要更新对应课程的 “isTop” 字段为 true。</p></li><li><p>在前端的课程列表页面中，为每个课程项添加置顶按钮或者选项，用户可以通过点击按钮或者勾选选项来设置课程置顶。</p></li><li><p>在前端的课程展示页面中，根据课程的 “isTop” 字段来进行展示排序，将置顶的课程显示在列表的最上方。</p></li><li><p>可以根据需求，设定置顶的课程数量限制，例如只有前几个置顶的课程会显示在最上方。</p></li></ol><p>通过以上步骤的设置，用户可以通过简单的操作来使自己感兴趣或者重要的课程显示在最上方，提高了系统的灵活性和用户体验。</p><hr><h3 id="java项目中，微服务拆分原则？"><a href="#java项目中，微服务拆分原则？" class="headerlink" title="java项目中，微服务拆分原则？"></a>java项目中，微服务拆分原则？</h3><p>在Java项目中，进行微服务拆分时应该遵循以下原则：</p><ol><li><p>单一职责原则：每个微服务应该专注于解决特定的业务问题，而不是试图处理多个不相关的功能。这样可以使每个微服务的功能单一化，易于维护和扩展。</p></li><li><p>高内聚低耦合原则：微服务之间应该有清晰的边界和接口定义，各个微服务之间的耦合应尽可能低，这样可以使每个微服务能够独立开发、测试和部署。</p></li><li><p>可独立演化原则：每个微服务应该能够独立地进行演化和升级，而不受其他微服务的影响。这样可以避免因为某个微服务的改动导致整个系统出现故障或停止运行。</p></li><li><p>安全边界原则：微服务之间应该有清晰的安全边界，每个微服务都应该对外部提供良好定义的接口，并且能够对接口进行权限控制和安全防护。</p></li><li><p>宜小不宜大原则：微服务的粒度应该适中，不宜过大也不宜过小。微服务过大会导致开发、测试、部署和运维复杂度增加，微服务过小则会导致服务间调用频繁、网络开销增加。</p></li><li><p>业务边界原则：微服务应该根据业务边界进行拆分，每个微服务应该对应一个业务功能模块，这样可以达到业务与技术的匹配，方便团队的协作和沟通。</p></li></ol><p>遵循以上原则进行微服务拆分，能够有效地提高系统的灵活性、可维护性和可扩展性，使得整个系统更易于开发、测试和部署。</p><hr><h3 id="java开发微服务项目中，什么时候用事务消息？什么时候用分布式事务？"><a href="#java开发微服务项目中，什么时候用事务消息？什么时候用分布式事务？" class="headerlink" title="java开发微服务项目中，什么时候用事务消息？什么时候用分布式事务？"></a>java开发微服务项目中，什么时候用事务消息？什么时候用分布式事务？</h3><p>在Java开发微服务项目中，可以根据以下几个方面来决定何时使用事务消息或分布式事务：</p><ol><li>异步场景：如果你的微服务之间的交互是异步的，即发送消息后不需要立即得到响应，可以考虑使用事务消息。例如，订单服务下单成功后需要发送通知给用户，此时可以将发送通知的操作封装成一个消息，通过消息队列来实现异步通知。</li><li>数据一致性要求不高：如果你的业务对数据一致性要求不是非常高，可以容忍一定程度的数据不一致，可以选择使用事务消息。因为事务消息的机制是通过消息队列来保证最终一致性，可能会有一定的延迟和数据不一致的风险。</li><li>同步场景：如果你的微服务之间的交互是同步的，即需要立即得到响应并保证数据一致性，可以考虑使用分布式事务。例如，支付服务调用库存服务进行库存扣减和订单服务进行订单创建，这个过程需要保证库存扣减和订单创建的操作要么同时成功，要么同时失败，就需要使用分布式事务来保证数据的一致性。</li><li>数据一致性要求高：如果你的业务对数据一致性要求非常高，不能容忍任何数据不一致的情况，那么分布式事务是比较合适的选择。因为分布式事务可以保证多个服务之间的数据操作要么全部成功，要么全部失败。</li></ol><p>总结来说，如果你的交互是异步的、对数据一致性要求不高，可以考虑使用事务消息；如果交互是同步的、对数据一致性要求高，可以考虑使用分布式事务。但是需要根据具体业务场景和需求来选择适合的方案。</p><hr><h3 id="要保障ES和MySQL之间数据的一致性，可以用什么技术来实现？"><a href="#要保障ES和MySQL之间数据的一致性，可以用什么技术来实现？" class="headerlink" title="要保障ES和MySQL之间数据的一致性，可以用什么技术来实现？"></a>要保障ES和MySQL之间数据的一致性，可以用什么技术来实现？</h3><p>要保障Elasticsearch（ES）和MySQL之间数据的一致性，可以使用以下技术来实现：</p><ol><li><p>双写：在数据写入过程中，同时将数据写入到MySQL和Elasticsearch中。这种方式确保了数据的实时一致性，但会增加写入的时间和资源消耗。</p></li><li><p>变更数据捕获（CDC）：使用CDC技术实时捕获MySQL的数据变更，并将这些变更同步到Elasticsearch中。这可以保证数据的实时同步，并且减少对MySQL的额外压力。</p></li><li><p>事件驱动架构：基于事件的架构可以将MySQL中的数据变更当作事件，触发相关的数据同步到Elasticsearch中。使用消息队列或事件总线来实现事件的传递和处理。</p></li><li><p>使用中间件：引入数据同步中间件，如Debezium等，来实现数据的实时同步和一致性保障。</p></li><li><p>定时同步：定期（如每隔一段时间）从MySQL中取出最新的数据进行同步到Elasticsearch中，以保障数据最终一致性。</p></li></ol><p>无论采用哪种技术，都需要对数据同步过程进行监控和容错处理，以确保数据的一致性和可靠性。选择合适的技术取决于系统的需求、可用资源和技术团队的实际情况。</p><hr><h3 id="在商品等的上下架处理中，我们是通过RocketMQ的事务消息来保证MySQL和ES之间数据的一致性的"><a href="#在商品等的上下架处理中，我们是通过RocketMQ的事务消息来保证MySQL和ES之间数据的一致性的" class="headerlink" title="在商品等的上下架处理中，我们是通过RocketMQ的事务消息来保证MySQL和ES之间数据的一致性的"></a>在商品等的上下架处理中，我们是通过RocketMQ的事务消息来保证MySQL和ES之间数据的一致性的</h3><hr><h3 id="RocketMQ的事务消息的作用？"><a href="#RocketMQ的事务消息的作用？" class="headerlink" title="RocketMQ的事务消息的作用？"></a>RocketMQ的事务消息的作用？</h3><p>RocketMQ的事务消息是一种特殊类型的消息，可以用于实现分布式事务的一致性。它的作用包括：</p><ol><li><p>分布式事务的一致性：RocketMQ事务消息可以确保在消息发送和消息确认的过程中，与具体业务的数据库事务一起保证分布式事务的一致性，从而避免了因为分布式事务问题而导致的数据不一致的情况。</p></li><li><p>事务补偿：在发送事务消息的业务发起方，当业务执行成功后，消息将会被提交，同时执行本地事务操作。如果本地事务执行成功，则提交消息，如果本地事务执行失败，则回滚消息。这种机制可以保证事务的最终一致性，并且保证了消息的可靠性投递。</p></li><li><p>可靠的消息投递：事务消息可以确保消息在发送之后不会立即被消费，只有在本地事务执行成功后，消息才会被提交并投递给消费者。这保证了消息的可靠性投递，不会因为本地事务失败而导致消息的丢失或重复消费的问题。</p></li></ol><p>总的来说，RocketMQ的事务消息可以帮助开发人员实现分布式事务、确保消息的可靠性投递以及保证最终一致性，为分布式系统的设计和实现提供了很大的帮助。</p><hr><h3 id="spu和sku的区别？"><a href="#spu和sku的区别？" class="headerlink" title="spu和sku的区别？"></a>spu和sku的区别？</h3><p>SPU（Standard Product Unit）和SKU（Stock Keeping Unit）是在商品管理领域常见的两个概念，它们之间的区别在于：</p><ol><li><p>SPU（Standard Product Unit）：SPU是标准产品单元的缩写，它通常指的是一类产品的总称，具有相同的基本属性和特征。比如，一款手机的SPU包含了手机的通用属性，如品牌、型号、颜色、尺寸、功能等。SPU可以看作是产品的一个抽象，描述了产品的共性特征。</p></li><li><p>SKU（Stock Keeping Unit）：SKU是库存量单位的缩写，它是指具体的商品库存单元，通常是指商品的具体型号、规格、颜色和尺寸等特定属性的组合。比如，同一款手机的不同颜色和存储容量就可以被视为不同的SKU。SKU通常用于区分和跟踪产品的具体库存情况。</p></li></ol><p>简而言之，SPU描述了产品的通用特征和属性，是一个产品的逻辑单元；而SKU则是根据实际库存情况划分的具体库存单元，用于管理和跟踪商品的具体库存。在商品管理中，SPU和SKU是相辅相成的概念，帮助企业对产品进行分类、管理和销售。</p><hr><hr><h3 id="学成在线相关面试题"><a href="#学成在线相关面试题" class="headerlink" title="学成在线相关面试题"></a>学成在线相关面试题</h3><h4 id="1-详细说说你的项目吧"><a href="#1-详细说说你的项目吧" class="headerlink" title="1 详细说说你的项目吧"></a>1 详细说说你的项目吧</h4><p>从以下几个方面进行项目介绍：</p><p>1、项目的背景，包括：是自研还是外包、什么业务、服务的客户群是谁、谁去运营等问题。</p><p>2、项目的业务流程</p><p>3、项目的功能模块</p><p>4、项目的技术架构</p><p>5、个人工作职责</p><p>6、个人负责模块的详细说明，包括模块的设计，所用到的技术，技术的实现方案等。</p><p>一个例子：</p><p>我最近参与的项目是我们公司自研的专门针对成人职业技能教育的网络课堂系统，网站提供了成人职业技能培训的相关课程，如：软件开发培训、职业资格证书培训、成人学历教育培训等课程。项目基于B2B2C的业务模式，培训机构可以在平台入驻、发布课程，我们公司作为运营方由专门的人员对发布的课程进行审核，审核通过后课程才可以发布成功，课程包括免费和收费两种形式，对于免费课程普通用户可以直接选课学习，对于收费课程在选课后需要支付成功才可以继续学习。</p><p>本项目包括用户端、机构端、运营端三个端。</p><p>核心模块包括：内容管理、媒资管理、课程搜索、订单支付、选课管理、认证授权等。</p><p>本项目采用前后端分离架构，后端采用SpringBoot、SpringCloud技术栈开发，数据库使用了MySQL，还使用的Redis、消息队列、分布式文件系统、Elasticsearch等中间件系统。</p><p>划分的微服务包括：内容管理服务、媒资管理服务、搜索服务、订单支付服务、 学习中心服务、系统管理服务、认证授权服务、网关服务、注册中心服务、配置中心服务等。</p><p>我在这个项目中负责了内容管理、媒资管理、订单支付模块的设计与开发。</p><p>内容管理模块，是对平台上的课程进行管理，课程的相关信息比较多这里在数据库设计了课程基本信息表、课程营销表、课程计划、课程师资表进行存储 ，培训机构要发布一门课程需要填写课程基本信息、课程营销信息、课程计划信息、课程师资信息，填写完毕后需要提交审核，由运营人员进行课程信息的审核，整个审核过程是程序自动审核加人工确认的方式，通常24小时审核完成。课程审核通过即可发布课程，课程的相关信息会聚合到课程发布表中，这里不仅要将课程信息写到课程发布表还要将课程信息写到索引库、分布式文件系统中，所以这里存在分布式事务的问题，项目使用本地消息表加任务调度的方式去解决这里的分布式事务，保存数据的最终一致性。</p><hr><h4 id="2-Git相关面试题"><a href="#2-Git相关面试题" class="headerlink" title="2 Git相关面试题"></a>2 Git相关面试题</h4><h5 id="2-1-Git代码冲突怎么处理？"><a href="#2-1-Git代码冲突怎么处理？" class="headerlink" title="2.1 Git代码冲突怎么处理？"></a>2.1 Git代码冲突怎么处理？</h5><p>我们在使用Git时难免会出现代码冲突的问题，出现冲突的原因是因为当本地文件的版本与目标分支中文件的版本不一致时，当存在同一行的内容不同时，在进行合并时会出现冲突。</p><p>代码冲突一般发生在以下情况：</p><ol><li>多个分支向主分支合并时</li><li>同一个分支下pull或push操作时</li></ol><p>当发生了冲突后，需要手动合并代码，选择最终的版本，可以通过图形界面，如下：</p><p><img src="/breeze/f77810a8/image-20230527134607827.png" alt="image-20230527134607827"></p><p>点击merge</p><p><img src="/breeze/f77810a8/image-20230527135125744.png" alt="image-20230527135125744"></p><p>可以看到上面有三个区域的代码。其中，最左边的表示本地有冲突的代码；最右边表示远程有冲突的代码；中间的表示最终的结果，也就是解决冲突后的结果。想要以本地或者远程的为准，就点击对应的箭头即可。（也可以手动修改中间的区域）</p><p>选择版本后，点击Apply，提交代码并push到远程仓库。</p><p>不通过图形化界面处理冲突，当出现冲突后在代码中自动添加了版本标识，如下：</p><p><img src="/breeze/f77810a8/image-20230527135618243.png" alt="image-20230527135618243"></p><p>手动修改代码如下（就是删除掉乱码部分，然后手动输入最终的代码）：</p><p><img src="/breeze/f77810a8/image-20230527135647265.png" alt="image-20230527135647265"></p><p>然后，将文件添加到暂存区，提交文件，push到远程仓库即可。</p><hr><h5 id="2-2-你是在那个分支开发？"><a href="#2-2-你是在那个分支开发？" class="headerlink" title="2.2 你是在那个分支开发？"></a>2.2 你是在那个分支开发？</h5><p>我们不是直接在主分支开发，由技术经理创建独立的开发分支，我们是在独立的开发分支中进行开发，最后由技术经理将开发分支合并到主分支。</p><hr><h4 id="3、maven相关面试题"><a href="#3、maven相关面试题" class="headerlink" title="3、maven相关面试题"></a>3、maven相关面试题</h4><h5 id="3-1-maven依赖版本冲突怎么处理？"><a href="#3-1-maven依赖版本冲突怎么处理？" class="headerlink" title="3.1 maven依赖版本冲突怎么处理？"></a>3.1 maven依赖版本冲突怎么处理？</h5><p>maven依赖版本冲突一般是由于间接依赖导致一个jar包中由多个不同的版本，比如：A依赖了B的1.0版本；C依赖了B的2.0版本，项目依赖A和C从而间接依赖了B的1.0和2.0版本，此时B有两个版本引入到了项目中，当存在版本冲突时可能会出现<code>ClassNotFoundException</code>、<code>NoSuchMethodError</code>等错误。</p><p>处理版本冲突时可以使用以下方法：</p><ol><li><p>使用exclusions排除依赖</p><p>比如：我们只依赖B的1.0版本，此时可以在依赖C时排除对B的依赖。</p><p><img src="/breeze/f77810a8/image-20230527142137928.png" alt="image-20230527142137928"></p></li><li><p>使用<code>dependencyManagement</code>锁定版本号</p><p>通常在父工程对依赖的版本进行统一管理。</p><p>比如：我们只依赖B的1.0版本，此时可以在父工程中限定B的版本为1.0。</p></li></ol><hr><h5 id="3-2-maven常用命令"><a href="#3-2-maven常用命令" class="headerlink" title="3.2 maven常用命令"></a>3.2 maven常用命令</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mvn clean   # 清除target目录生成的结果</span><br><span class="line"></span><br><span class="line">mvn compile # 编译源代码</span><br><span class="line"></span><br><span class="line">mvn test 	# 执行单元测试</span><br><span class="line"></span><br><span class="line">mvn package	 # 打包</span><br><span class="line"></span><br><span class="line">mvn install  # 打包并把打好的包保存到本地仓库</span><br><span class="line"></span><br><span class="line">mvn deploy   # 打包并把打好的包上传到远程仓库</span><br></pre></td></tr></table></figure><hr><h4 id="4-MySQL相关面试题"><a href="#4-MySQL相关面试题" class="headerlink" title="4 MySQL相关面试题"></a>4 MySQL相关面试题</h4><h5 id="4-1-MySQL常见的存储引擎及区别？"><a href="#4-1-MySQL常见的存储引擎及区别？" class="headerlink" title="4.1 MySQL常见的存储引擎及区别？"></a>4.1 MySQL常见的存储引擎及区别？</h5><p>一、 <strong>InnoDB</strong></p><ol><li>支持事务。</li><li>使用的锁粒度默认为行级锁，可以支持更高的并发；也支持表锁。</li><li>支持外键约束；外键约束其实降低了表的查询速度，增加了表之间的耦合度。</li></ol><p>二、MyISAM</p><ol><li>不提供事务支持</li><li>只支持表级锁</li><li>不支持外键</li></ol><p>三、memory</p><ol><li>数据存储在内存中</li></ol><p><strong>总结：</strong></p><ul><li>MyISAM管理非事务表，提供高速存储和检索以及全文搜索能力，如果在应用中执行大量select操作，应该选择MyISAM</li><li>InnoDB用于事务处理，具有ACID事务支持等特性，如果在应用中执行大量的insert和update操作，应该选择InnoDB</li></ul><h5 id="4-2-MySQL建表时需要注意什么？"><a href="#4-2-MySQL建表时需要注意什么？" class="headerlink" title="4.2 MySQL建表时需要注意什么？"></a>4.2 MySQL建表时需要注意什么？</h5><ol><li>注意选择存储引擎，如果要支持事务需要选择InnoDB。</li><li>注意字段类型的选择，对于日期类型，如果要记录时、分、秒，建议使用<code>datetime</code>；只记录年、月、日，使用date类型;对于字符类型的选择，固定长度字段选择<code>char</code>，不固定长度字段使用<code>varchar</code>，<code>varchar</code>比<code>char</code>节省空间，但速度没有<code>char</code>快；对于内容介绍类的长广文本字段使用<code>text</code>或<code>longtext</code>类型；如果存储图片等二进制数据使用<code>blob</code>或<code>longblob</code>类型；对金额字段建议使用<code>DECILAL</code>；对于数值类型的字段在确保取值范围足够的前提下尽量使用占用空间较小的类型。</li><li>主键字段建议使用自然主键，不要有业务意义，建议使用<code>int unsigned</code>类型，特殊场景使用<code>bigint</code>类型。</li><li>如果要存储<code>text</code>、<code>blob</code>字段建议单独建一张表，使用外键关联。</li><li>尽量不要定义外键，保证表的独立性，可以存在外键意义的字段。</li><li>设置字段默认值，比如：状态、创建时间等。</li><li>每个字段写清除注释。</li><li>注意字段的约束，比如：非空、唯一、主键等。</li></ol><h5 id="4-3-树形表的标记字段是什么？"><a href="#4-3-树形表的标记字段是什么？" class="headerlink" title="4.3 树形表的标记字段是什么？"></a>4.3 树形表的标记字段是什么？</h5><ol><li><p>树形表的标记字段是什么？如何查询MySQL树形表？</p><p>树形表的标记字段是<code>parentid</code>，即父节点的id</p><p>查询一个树形表的方法：</p><ul><li>当层级固定时可以用表的自链接进行查询</li><li>如果想灵活查询每个层级可以是哟个MySQL递归方法，使用<code>with RECURSIVE</code></li></ul></li></ol><hr><h4 id="5-SpringBoot接口开发的常用注解有哪些？"><a href="#5-SpringBoot接口开发的常用注解有哪些？" class="headerlink" title="5 SpringBoot接口开发的常用注解有哪些？"></a>5 SpringBoot接口开发的常用注解有哪些？</h4><ol><li>@Controller 标记此类是一个控制器，可以返回视图解析器指定的html页面，通过 @ResponseBody 可以将结果返回 json、xml 数据。</li><li>@RestController 相当于 @ResponseBody 加 @Controller，实现rest接口开发，返回json数据，不能返回html页面。</li><li>@RequestMapping 定义接口地址，可以标记在类上，也可以标记在方法上，支持http的post、put、get等方法。</li><li>@PostMapping 定义post接口，只能标记在方法上，用于添加记录或<strong>复杂条件的<font color="red">查询</font>接口</strong>。</li><li>@GetMapping 定义get接口，只能标记在方法上，用于查询接口的定义。</li><li>@PutMapping 定义put接口，只能标记在方法上，用于修改接口的定义。</li><li>@DeleteMapping 定义delete接口，只能标记在方法上，用于删除接口的定义。</li><li>@RequestBody 定义在方法上，用于将前端传递的json串转为java对象。</li><li>@PathVarible 接收请求路径中占位符的值。</li><li>@ApiOperation，这是swagger的注解，对接口方法进行说明。</li><li>@Api，这是swagger的注解，对接口类进行说明。</li><li>@Autowired 基于类型注入。</li><li>@Resource 基于名称注入，如果基于名称注入失败，就转为基于类型注入。</li></ol><hr><h4 id="5-项目的开发流程是什么？"><a href="#5-项目的开发流程是什么？" class="headerlink" title="5 项目的开发流程是什么？"></a>5 项目的开发流程是什么？</h4><ol><li>产品人员设计产品原型。</li><li>讨论需求。</li><li>分模块设计接口。</li><li>出接口文档。</li><li>将接口文档给到前端人员，前后端分离开发。</li><li>开发完毕进行测试。</li><li>测试完毕发布项目，由运维人员进行部署安装。</li></ol><hr><h4 id="6-Mybatis相关面试题"><a href="#6-Mybatis相关面试题" class="headerlink" title="6 Mybatis相关面试题"></a>6 Mybatis相关面试题</h4><h5 id="6-1-Mybatis分页插件的原理？"><a href="#6-1-Mybatis分页插件的原理？" class="headerlink" title="6.1 Mybatis分页插件的原理？"></a>6.1 Mybatis分页插件的原理？</h5><ul><li><p>配置mybatis分页插件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义分页插件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.xuecheng.content.mapper&quot;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>首先分页参数放到ThreadLocal中，拦截执行的sql，根据数据库类型添加对应的sql语句重写sql，例如：<code>select * from talbel where a</code>转换为：<code>select count(*) from table where a</code>和<code>select * from table where a limit</code></p><p>计算出了total总条数，<code>pageNum</code>表示当前第几页，<code>pageSize</code>表示每页大小和当前页的数值，是否为首页、是否为尾页、总页数等。</p><p>如果是mysql就使用mysql的limit，如果是oracle,就是用oracle的romnum</p></li></ul><h5 id="6-2-MyBatis的ResultType和ResultMap的区别？"><a href="#6-2-MyBatis的ResultType和ResultMap的区别？" class="headerlink" title="6.2 MyBatis的ResultType和ResultMap的区别？"></a>6.2 MyBatis的ResultType和ResultMap的区别？</h5><p><code>ResultType</code>：指定映射类型，只要查询的字段名和类型的属性名匹配就可以自动映射。</p><p><code>ResultMap</code>：自定义映射规则，当查询的字段名和映射类型的属性不匹配时可以通过<code>ResultMap</code>自定义映射规则，也可以实现一对多、一对一映射。</p><h5 id="6-3-和-有什么区别？"><a href="#6-3-和-有什么区别？" class="headerlink" title="6.3 #{} 和 ${} 有什么区别？"></a>6.3 <code>#&#123;&#125;</code> 和 <code>$&#123;&#125;</code> 有什么区别？</h5><p><code>#&#123;&#125;</code>标记一个占位符，可以防止sql注入。</p><p><code>$&#123;&#125;</code>用于在动态sql中拼接字符串，可能导致sql注入。</p><hr><h4 id="7-系统如何处理异常？"><a href="#7-系统如何处理异常？" class="headerlink" title="7 系统如何处理异常？"></a>7 系统如何处理异常？</h4><p>我们自定义一个统一的异常处理器去捕获并处理异常</p><p>使用控制器增加注解<code>@ControllerAdvice</code>和异常处理注解来实现<code>@ExceptionHandler来实现</code></p><ol><li><p>处理自定义异常</p><p>程序在编写代码时根据校验结果主动抛出自定义异常类对象，抛出异常时指定详细的异常信息，异常处理器捕获异常信息，记录异常日志并响应给用户。</p></li><li><p>处理未知异常</p><p>接口执行过程中的一些运行时异常也会由异常处理器统一捕获，记录异常日志，统一响应给用户500错误。在异常处理器中还可以针对某个异常类型进行单独处理。</p></li></ol><hr><h4 id="8-请求参数的合法性校验如何做？"><a href="#8-请求参数的合法性校验如何做？" class="headerlink" title="8 请求参数的合法性校验如何做？"></a>8 请求参数的合法性校验如何做？</h4><p>使用基于JSR303的校验框架实现，<code>SpringBoot</code>提供了<code>JSR-303</code>的支持，它就是<code>spring-boot-starter-validation</code>，它包括了很多校验规则，只需要在模型类中通过注解指定校验规则，在Controller方法上开启校验。</p><hr><h4 id="9-什么情况下事务会失效？"><a href="#9-什么情况下事务会失效？" class="headerlink" title="9 什么情况下事务会失效？"></a>9 什么情况下事务会失效？</h4><ul><li><p>在方法中捕获异常没有抛出去</p></li><li><p>非事务方法调用事务方法</p><blockquote><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/smallfa/p/14379346.html">同一个Service类中非事务方法调用事务方法，解决方法（3种）</a></p><p><strong>总结：</strong><font color="red">spring是采用动态代理机制实现事务控制的，而动态代理最终都是要调用原始对象的，而原始对象在调用方法的时候不会在触发代理了。所以，同一个类中，非事务方法调用事务方法是使用的原始对象去调用而不是代理对象，所以事务会失效。</font></p><p>使用@Autowired注入的对象也是代理对象，所以可以直接在service中注入自己（也是一个代理对象），然后在非事务方法中使用注入的代理对象去调用事务方法。（这里的事务方法得在接口中进行定义）</p></blockquote></li><li><p>@Transactional标记的方法不是public修饰的</p></li><li><p>抛出的异常与rollbackFor指定的异常不匹配，默认rollbackFor指定的异常为RuntimeException</p><p><code>@Transactional(rollbackFor=XueChengPlusException.class)</code></p></li><li><p>数据库表不支持事务，比如MySQL的MyISAM</p></li><li><p>Spring的传播行为导致事务失效，比如：<code>PROPAGATION_NEVER</code>、<code>PROPAGATION_NOT_SUPPORT</code></p><p><code>PROPAGATION_REQUIRED</code>– 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择</p><p><code>PROPAGATION_SUPPORTS</code>– 支持当前事务，如果当前没有事务，就以非事务方法执行</p><p><code>PROPAGATION_MANDATORY</code>– 支持当前事务，如果当前没有事务，就抛出异常</p><p><code>PROPAGATION_REQUIRES_NEW</code>– 新建事务，如果当前存在事务，把当前事务挂起</p><p><code>PROPAGATION_NOT_SUPPORTED</code>– 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</p><p><code>PROPAGATION_NEVER</code>– 以非事务方式执行，如果当前存在事务，则抛出异常</p><p><code>PROPAGATION_NESTED</code>– 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则与<code>PROPAGATION_REQUIRED</code>类似的操作。</p></li></ul><hr><h4 id="10-什么是minio，为什么使用minio？"><a href="#10-什么是minio，为什么使用minio？" class="headerlink" title="10 什么是minio，为什么使用minio？"></a>10 什么是minio，为什么使用minio？</h4><p>Minio是一个开源的、兼容Amazon S3云存储服务API的对象存储服务器。它可以用于存储和管理大量非结构化数据，例如文本、图片、视频和二进制数据等。</p><p>使用Minio的好处在于：</p><ol><li>可扩展性：Minio的设计目标是可扩展性和高可用性，用户可以非常容易地增加、减少并部署多个节点以构建分布式存储方案，并实现数据备份和恢复。</li><li>易于集成：由于Minio采用了Amazon S3 API作为标准接口，因此兼容AWS S3的应用程序可以直接使用Minio存储数据，而无需进行任何修改。</li><li>安全性：Minio支持HTTP和HTTPS等多种通信协议，并且可以配置SSL证书，从而提供加密通信通道。此外，Minio还提供了访问控制策略和身份验证机制来保护数据安全。</li><li>开源免费：Minio是一个完全开源的软件，用户可以自由地使用、修改和分发。</li></ol><p><strong>综上所述，Minio提供了一种简单、可扩展、高可用、安全且具有极佳兼容性的对象存储解决方案，适用于不同规模的企业和组织，因此使用Minio是一个值得考虑的选择。</strong></p><hr><h4 id="11-文件上传相关面试题"><a href="#11-文件上传相关面试题" class="headerlink" title="11 文件上传相关面试题"></a>11 文件上传相关面试题</h4><h5 id="11-1-断点续传是怎么实现的？"><a href="#11-1-断点续传是怎么实现的？" class="headerlink" title="11.1 断点续传是怎么实现的？"></a>11.1 断点续传是怎么实现的？</h5><p>我们是基于分块上传的模式实现断点续传的需求，当文件上传一部分断网后，前边已经上传过的不再上传。（所以每次上传文件之前都会进行检测，检测本次分块文件是否已经被上传，若已上传过了，就跳过该分块文件）</p><p>1）前端对文件进行分块</p><p>2）前端使用多线程一块一块上传，上传前给服务端发一个消息校验该分块是否已经上传，如果已上传则不再上传。</p><p>3）等所有分块上传完毕，服务端合并所有分块，校验文件的完整性。&#x3D;&#x3D;因为分块全部上传到了服务器，服务器将所有分块按顺序进行合并，就是写每个分块文件内容按顺序依次写入一个文件中。使用字节流去读写文件&#x3D;&#x3D;</p><p>4）前端给服务传了一个md5值，服务端合并文件后计算合并后文件的md5值，是否和前端传的一样，如果一样则说明文件完整，如果不一样说明有可能由于网络丢包导致文件不完整，这时上传失败，需要重新上传。</p><h5 id="11-2-分块文件清理问题？"><a href="#11-2-分块文件清理问题？" class="headerlink" title="11.2 分块文件清理问题？"></a>11.2 分块文件清理问题？</h5><p>上传一个文件进行分块上传，上传一半不传了 ，之前上传到minio的分块文件要清理吗?怎么做的?<br>1）在数据库中有一张文件表记录minio中存储的文件信息。<br>2）文件开始上传时会写入文件表,状态为上传中，上传完成会更 新状态为上传完成。<br>3）当一个文件传了一半不再上传了说明该文件没有上传完成，会有定时任务去查询文件表中的记录,如果文件未上传完成则删除minio中没有上传成功的文件目录。</p><hr><h4 id="12-xxl-job相关面试题"><a href="#12-xxl-job相关面试题" class="headerlink" title="12 xxl-job相关面试题"></a>12 xxl-job相关面试题</h4><h5 id="12-1-的工作原理是什么？xxl-job是什么工作？"><a href="#12-1-的工作原理是什么？xxl-job是什么工作？" class="headerlink" title="12.1 的工作原理是什么？xxl-job是什么工作？"></a>12.1 的工作原理是什么？xxl-job是什么工作？</h5><p>XXL-JOB分布式任务调度服务由调用中心和执行器组成，调用中心负责按任务调度策略向执行器下发任务，执行器负责接收任务执行任务。</p><p>1）首先部署并启动xxl-job调度中心。（一个java工程）</p><p>2）然后在微服务中添加xxl-job依赖，在微服务中配置执行器。</p><p>3）启动微服务，执行器向调度中心上报自己。</p><p>4）在微服务中写一个任务方法并用xxl-job的注解去标记执行任务的方法名称。</p><p>5）在调度中心配置任务调度策略，调度策略就是每隔多长时间执行还是在每天或每月的固定时间去执行，比如每天0点执行，或每隔一小时执行一次等。</p><p>6）在调度中心启动任务。</p><p>7）调度中心根据任务调度策略，到达时间就开始下发任务给执行器。</p><p>8）执行器收到任务就开始执行任务。</p><h4 id="12-2-如何保证任务不重复执行？"><a href="#12-2-如何保证任务不重复执行？" class="headerlink" title="12.2 如何保证任务不重复执行？"></a>12.2 如何保证任务不重复执行？</h4><p>1）调度中心按分片广播的方式去下发任务</p><p>2）执行器收到作业分片广播的参数：分片总数和分片序号，计算任务id除以分片总数得到一个余数，如果余数等于分片序号这时就去执行这个任务，这里保证了不同的执行器执行不同的任务。</p><p>3）配置调度过期策略为”忽略“，避免同一个执行器多次重复执行同一个任务。</p><p>4）配置任务阻塞策略为”丢弃后续调度“，注意：丢弃也没事，下一次调度就又可以执行了。</p><p>5）另外还有保证任务处理的幂等性，执行过的任务可以打一个状态标记已完成。下次在调度执行该任务判断该任务已完成，不再执行。</p><h4 id="12-3-任务幂等性如何保证？"><a href="#12-3-任务幂等性如何保证？" class="headerlink" title="12.3 任务幂等性如何保证？"></a>12.3 任务幂等性如何保证？</h4><p>它描述了一次和多次请求某一个资源对于资源本身应该具有同样的结果。</p><p>幂等性是为了解决重复提交问题，比如：恶意刷单，重复支付等。</p><p>解决幂等性常用的方案：</p><p>1）数据库约束，比如：唯一索引，主键。同一个主键不可能两次都插入成功。</p><p>2）乐观锁，常用于数据库，更新数据时根据乐观锁状态去更新。</p><p>3）唯一序列号，请求前生成唯一的序列号，携带序列号去请求，执行时在redis记录该序列号表示以该序列号的请求已经执行过了，如果相同的序列号再次来执行说明时重复执行。</p><p>这里我们在数据库视频处理表中，添加处理状态字段，视频处理完成，状态更新为完成。执行视频处理前判断状态是否完成，如果完成则不再处理。</p><hr><hr><h3 id="线程池是怎么创建线程的，给出代码"><a href="#线程池是怎么创建线程的，给出代码" class="headerlink" title="线程池是怎么创建线程的，给出代码"></a>线程池是怎么创建线程的，给出代码</h3><p>线程池是用来管理和复用线程的一种机制，它可以在应用程序中预先创建一定数量的线程，并在需要时分配这些线程来执行任务，从而避免频繁地创建和销毁线程的开销。下面是一个使用Java语言创建线程池的简单示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个固定大小的线程池，大小为5</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务给线程池执行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Task &quot;</span> + taskId + <span class="string">&quot; is being executed&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们使用<code>Executors.newFixedThreadPool(5)</code>方法创建了一个固定大小为5的线程池。然后使用<code>threadPool.execute()</code>方法向线程池提交了10个任务，每个任务都是一个实现了<code>Runnable</code>接口的匿名内部类。最后，调用<code>threadPool.shutdown()</code>方法关闭线程池。</p><p>这个代码创建了一个固定大小的线程池，并使用线程池来执行任务。如果任务数量超过了线程池的容量，那么多出来的任务会被放入等待队列中，直到有空闲线程来执行它们。</p><hr><h3 id="quartz和xxl-job的区别？在分布式环境中用哪个好？为什么？"><a href="#quartz和xxl-job的区别？在分布式环境中用哪个好？为什么？" class="headerlink" title="quartz和xxl-job的区别？在分布式环境中用哪个好？为什么？"></a>quartz和xxl-job的区别？在分布式环境中用哪个好？为什么？</h3><p>Quartz和XXL-Job是两个常用的作业调度框架，二者有一些区别：</p><ol><li><p>架构：Quartz是一个功能强大的、开源的作业调度库，适用于Java应用程序。它可以在单点和集群环境下运行。而XXL-Job是一个分布式任务调度平台，专门针对大规模分布式任务调度进行优化，提供了任务调度中心、执行器、调度任务的配套解决方案。</p></li><li><p>功能丰富性：Quartz提供了丰富的功能和灵活的配置选项，支持多种调度策略、任务监听器、集群模式等。XXL-Job也提供了类似的功能，但其专注于分布式环境下的任务调度和管理，提供了可视化的任务管理界面。</p></li></ol><p>在分布式环境中，通常建议使用XXL-Job作为任务调度框架。原因如下：</p><ol><li><p>分布式支持：XXL-Job天生支持分布式环境下的任务调度和管理，可以轻松实现多台服务器的任务调度协调，保证任务的高可用性和高性能。</p></li><li><p>可视化管理：XXL-Job提供了可视化的任务管理界面，方便用户查看任务状态、执行日志等，并且支持任务的动态添加、停止、修改等操作。</p></li><li><p>高扩展性：XXL-Job提供了丰富的API接口和插件机制，可以方便地进行定制化扩展。</p></li></ol><p>因此，对于分布式环境中的任务调度需求，建议使用XXL-Job来实现，它针对分布式任务调度进行了优化，并提供了便于管理和扩展的特性。</p><hr><hr><h3 id="面试题实战（RH）"><a href="#面试题实战（RH）" class="headerlink" title="面试题实战（RH）"></a>面试题实战（RH）</h3><h4 id="SpringBoot项目中，单元测试是怎么做的？给出具体代码"><a href="#SpringBoot项目中，单元测试是怎么做的？给出具体代码" class="headerlink" title="SpringBoot项目中，单元测试是怎么做的？给出具体代码"></a>SpringBoot项目中，单元测试是怎么做的？给出具体代码</h4><p>在SpringBoot项目中，单元测试通常使用JUnit框架来进行，可以使用<code>@RunWith</code>注解来指定测试运行器，使用<code>@SpringBootTest</code>注解来指定启动Spring应用上下文。以下是一个简单的SpringBoot项目中的单元测试示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.assertEquals;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span> <span class="comment">// 运行测试时使用SpringRunner</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServiceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyService myService; <span class="comment">// 要测试的服务</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMyServiceMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 执行要测试的方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> myService.myMethod();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用断言来验证结果</span></span><br><span class="line">        assertEquals(<span class="string">&quot;expected result&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们使用<code>@RunWith(SpringRunner.class)</code>注解来指定测试运行器为SpringRunner，使用<code>@SpringBootTest</code>注解来启动Spring应用上下文。我们还使用了<code>@Autowired</code>注解来注入要测试的服务。在<code>testMyServiceMethod</code>方法中，我们调用了要测试的服务方法，并使用<code>assertEquals</code>断言来验证方法返回的结果是否符合预期。</p><p>这只是一个简单的示例，实际的单元测试还需要针对具体的业务逻辑编写不同的测试用例来覆盖不同的情况。</p><hr><h4 id="java中多态的实现方式"><a href="#java中多态的实现方式" class="headerlink" title="java中多态的实现方式"></a>java中多态的实现方式</h4><p>在Java中，多态可以通过以下几种方式来实现：</p><ol><li>方法重写（Override）：当子类继承父类时，子类可以重写父类的方法，并且通过父类引用指向子类对象，从而达到覆盖的效果。当调用方法时，根据对象的实际类型来确定调用的具体方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Some sound&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bark&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>方法重载（Overload）：在同一个类中定义多个具有相同名称但参数列表不同的方法，根据调用时传递的参数类型和数量来确定具体调用的方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>接口（Interface）：多个类实现同一个接口，并且每个类都可以有自己的实现方式。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a circle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a square&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些方式都体现了Java中多态的实现方式，都能让代码更加灵活和可扩展。其中方法重写和接口是最常见的多态实现方式。</p><hr><h4 id="java中，线程在运行过程中出错会怎样？"><a href="#java中，线程在运行过程中出错会怎样？" class="headerlink" title="java中，线程在运行过程中出错会怎样？"></a>java中，线程在运行过程中出错会怎样？</h4><p>在Java中，线程在运行过程中可能会出现各种错误，如NullPointerException、ArrayIndexOutOfBoundsException、ConcurrentModificationException等。当线程出现错误时，可能会导致程序崩溃或产生不可预测的结果。</p><p>通常情况下，线程出错会抛出异常。如果该异常没有在线程的代码中得到捕获和处理，那么该线程可能会被终止。另外，线程中抛出的未捕获异常可以通过Thread类的setDefaultUncaughtExceptionHandler方法设置默认的未捕获异常处理器来处理。</p><p>当线程出现错误时，可以通过以下方式来处理：</p><ol><li>捕获和处理异常：在线程的run方法中捕获并处理异常，以避免线程被强制终止。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 线程的执行代码</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 处理异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li>设置未捕获异常处理器：可以通过Thread类的setDefaultUncaughtExceptionHandler方法为整个应用程序设置一个统一的未捕获异常处理器。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread.setDefaultUncaughtExceptionHandler((thread, e) -&gt; &#123;</span><br><span class="line">    <span class="comment">// 处理未捕获异常</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li>使用try-catch-finally块：在启动线程的地方加入try-catch-finally块，以捕获并处理线程中出现的异常。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    thread.start();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 进行清理工作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，线程在运行过程中出错可能会导致程序不稳定，因此在编写多线程代码时需要注意合理地处理异常，以确保程序的可靠性和稳定性。</p><hr><h4 id="mybatis和mybatisplus的区别？"><a href="#mybatis和mybatisplus的区别？" class="headerlink" title="mybatis和mybatisplus的区别？"></a>mybatis和mybatisplus的区别？</h4><p>MyBatis和MyBatis-Plus是两个Java持久层框架，它们在实际应用中有一些区别，包括功能、用法和特点等方面：</p><ol><li><p>MyBatis是一个优秀的持久层框架，它使用XML或注解配置来映射Java对象和SQL语句，提供了灵活的SQL语句编写和数据库操作功能。</p></li><li><p>MyBatis-Plus是在MyBatis的基础上进行了封装和扩展的增强工具，提供了更便捷的操作数据库的方法和功能。</p></li></ol><p>下面是它们的一些主要区别：</p><p>功能特点：</p><ul><li>MyBatis需要程序员手动编写SQL语句，可以使用XML或注解来定义映射关系和SQL操作。</li><li>MyBatis-Plus提供了强大的代码生成器和便捷的SQL构建器等功能，可以更加快速地进行CRUD操作，还提供了Lambda表达式查询、条件构造器、分页插件等功能。</li></ul><p>灵活性：</p><ul><li>MyBatis具有更高的灵活性，可以直接编写SQL语句，适用于对SQL操作有较高要求的场景。</li><li>MyBatis-Plus在一些常见的数据库操作上提供了更加快速和便捷的解决方案，封装了常见的CRUD操作，减少重复代码。</li></ul><p>使用难度：</p><ul><li>MyBatis相对灵活，但需要手动编写大量SQL语句和映射文件，对于复杂查询和操作需要编写较多的代码。</li><li>MyBatis-Plus提供了更加便捷和高效的数据库操作方法，减少了程序员的开发量，提升了开发效率。</li></ul><p>综上所述，MyBatis和MyBatis-Plus都是优秀的持久层框架，在实际应用中可以根据具体的项目需求和开发风格来选择合适的框架。如果需要更加便捷和高效的数据库操作方法，可以考虑使用MyBatis-Plus，而如果对SQL操作有高要求或者需要更大的灵活性，可以选择MyBatis。</p><hr><h4 id="java中，多线程串行执行，其他线程需要线程池的数据如何解决？"><a href="#java中，多线程串行执行，其他线程需要线程池的数据如何解决？" class="headerlink" title="java中，多线程串行执行，其他线程需要线程池的数据如何解决？"></a><font color="purple">java中，多线程串行执行，其他线程需要线程池的数据如何解决？</font></h4><p>在Java中，如果多线程需要串行执行，并且有线程池的数据需求，可以使用以下方法来解决：</p><ol><li><p>使用线程池的回调机制：在线程池中执行的任务可以通过回调机制将结果传递给主线程，主线程可以在收到结果后继续执行下一个任务。</p></li><li><p>使用Future模式：线程池中的任务可以返回一个Future对象，主线程可以通过Future对象获取任务的结果，并在获取到结果后继续执行下一个任务。</p></li><li><p>使用CountDownLatch或CyclicBarrier同步工具：主线程可以等待线程池中的任务执行完成后再继续执行下一个任务，可以使用CountDownLatch或CyclicBarrier来实现线程的同步。</p></li><li><p>使用阻塞队列：线程池中的任务可以将结果放入一个共享的阻塞队列中，主线程可以从队列中获取结果，并在获取到结果后继续执行下一个任务。</p></li></ol><p>总之，在多线程串行执行并且需要线程池的数据时，可以通过以上几种方式来解决线程间数据的交互和同步问题。</p><hr><h4 id="java中，多线程生成唯一订单号，如何保证订单号不重复？"><a href="#java中，多线程生成唯一订单号，如何保证订单号不重复？" class="headerlink" title="java中，多线程生成唯一订单号，如何保证订单号不重复？"></a>java中，多线程生成唯一订单号，如何保证订单号不重复？</h4><p>在Java中，可以通过以下几种方式来保证多线程生成的订单号不重复：</p><ol><li>使用AtomicLong类：可以使用AtomicLong类来生成唯一的订单号，AtomicLong类能够保证在多线程环境下对long类型数据的原子性操作，从而避免重复。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicLong</span> <span class="variable">orderId</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">generateOrderId</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> orderId.incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用UUID：UUID是通用唯一识别码，它是一个128位的值，在理论上具有唯一性。可以使用UUID类来生成唯一的订单号。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generateOrderId</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> UUID.randomUUID().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>使用数据库唯一索引：在数据库中创建一个唯一索引的订单号字段，保证订单号的唯一性。在插入订单数据时，利用数据库的唯一索引机制来避免订单号重复。</p></li><li><p>使用分布式系统生成订单号：使用分布式系统生成唯一的订单号，例如使用雪花算法（Snowflake）生成全局唯一的ID。</p></li></ol><p>无论使用何种方式生成唯一订单号，都应该进行充分的测试来验证订单号的唯一性，特别是在高并发的情况下。</p><hr><h4 id="java中，bootstrap和application配置文件的区别？"><a href="#java中，bootstrap和application配置文件的区别？" class="headerlink" title="java中，bootstrap和application配置文件的区别？"></a>java中，bootstrap和application配置文件的区别？</h4><p>在Java中，Spring Boot框架中的配置文件分为两类：bootstrap配置文件和application配置文件。它们之间的区别主要在于加载顺序和作用范围。</p><ol><li><p>Bootstrap配置文件：</p><ul><li>加载顺序：bootstrap配置文件是Spring Boot应用程序启动时第一个被加载的配置文件，它的加载顺序优先于application配置文件。</li><li>作用范围：bootstrap配置文件中通常放置一些对整个应用生命周期都具有影响的配置，比如用于连接配置中心，加密解密等。</li><li>文件名：默认情况下，bootstrap配置文件的文件名是bootstrap.properties或bootstrap.yml。</li></ul></li><li><p>Application配置文件：</p><ul><li>加载顺序：application配置文件会在bootstrap配置文件加载完成之后被加载，可以有多个application配置文件，在加载时会按照约定进行合并。</li><li>作用范围：application配置文件用于定义应用程序特定的配置，例如数据库连接、日志配置、端口设置等。</li><li>文件名：默认情况下，application配置文件的文件名是application.properties或application.yml。</li></ul></li></ol><p>总的来说，bootstrap配置文件和application配置文件都用于配置Spring Boot应用程序的参数，区别在于加载顺序和作用范围。通过合理使用这两种配置文件，能够更好地管理应用程序的配置信息。</p><hr><h3 id="RocketMQMessageListener-，-RocketMQTransactionListener-，这两个注解有什么区别？适用于哪些地方？"><a href="#RocketMQMessageListener-，-RocketMQTransactionListener-，这两个注解有什么区别？适用于哪些地方？" class="headerlink" title="@RocketMQMessageListener()，@RocketMQTransactionListener()，这两个注解有什么区别？适用于哪些地方？"></a>@RocketMQMessageListener()，@RocketMQTransactionListener()，这两个注解有什么区别？适用于哪些地方？</h3><p>@RocketMQMessageListener注解用于标记一个类为RocketMQ的消息监听器，指定监听的Topic、Tags和消费者组等属性，并可以指定消费模式和最大消费线程数等。该注解适用于消息消费者中，用于监听并消费RocketMQ中的消息。</p><p>@RocketMQTransactionListener注解用于标记一个类为RocketMQ事务消息的监听器，指定监听的Topic和消费者组等属性。该注解适用于事务消息的生产者中，用于监听并处理RocketMQ中的事务消息。</p><p>两者的区别在于@RocketMQMessageListener用于普通消息的消费，而@RocketMQTransactionListener用于事务性消息的消费。根据实际业务需求和使用RocketMQ消息中间件的场景来选择使用相应的注解。</p><hr><h4 id="springboot项目数据库密码如何加密"><a href="#springboot项目数据库密码如何加密" class="headerlink" title="springboot项目数据库密码如何加密"></a>springboot项目数据库密码如何加密</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/387105432">聊聊springboot项目数据库密码如何加密 - 知乎 (zhihu.com)</a></p><hr><h4 id="HTTP和HTTPS的区别？"><a href="#HTTP和HTTPS的区别？" class="headerlink" title="HTTP和HTTPS的区别？"></a>HTTP和HTTPS的区别？</h4><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19577317">http 和 https 有何区别？如何灵活使用？ - 知乎 (zhihu.com)</a></p><hr><h4 id="JSR303校验中，-NotNull和-NotBlank有什么区别"><a href="#JSR303校验中，-NotNull和-NotBlank有什么区别" class="headerlink" title="JSR303校验中，@NotNull和@NotBlank有什么区别"></a>JSR303校验中，@NotNull和@NotBlank有什么区别</h4><p>在JSR303校验中，@NotNull和@NotBlank是两个常用的注解，用于对字段进行非空校验。它们的区别如下：</p><ol><li><p>@NotNull：这个注解用于检查字段是否为null。如果字段为null，校验将失败并返回错误信息。</p></li><li><p>@NotBlank：这个注解用于检查字段是否不为空，并且去除首尾空格后是否还有字符。它适用于字符串类型的字段。如果字段为null、空字符串或只包含空格，校验将失败并返回错误信息。</p></li></ol><p>总结来说，@NotNull只检查字段是否为null，而@NotBlank不仅会检查字段是否为null，还会对字符串字段进行空串和空格的校验。因此，根据具体需求，选择合适的注解来进行校验。</p><hr><h3 id="为什么非关系型数据库比关系型数据库更易扩展？"><a href="#为什么非关系型数据库比关系型数据库更易扩展？" class="headerlink" title="为什么非关系型数据库比关系型数据库更易扩展？"></a>为什么非关系型数据库比关系型数据库更易扩展？</h3><p>因为关系型数据库维护的是表结构，数据结构比较固定，表结构的行和列是固定的，不易扩展或者说扩展的代价非常大；而非关系型数据库的结构就比较松散，易于扩展。</p><hr><h3 id="如何在websocket中注入service的对象？"><a href="#如何在websocket中注入service的对象？" class="headerlink" title="如何在websocket中注入service的对象？"></a><font color="red">如何在websocket中注入service的对象？</font></h3><p>因为websockt和spring的生命周期不一致，所以在websocket中使用@Autowired和@Resource注解都没能注入service的对象，使用构造注入的方式也不行。</p><p>最后是通过在websocket的配置类中才注入成功的，相关步骤如下：</p><ol><li><p>在WebSocketServer中将要注入的Service声明成静态变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ServerEndpoint(&quot;/webSocket/&#123;sid&#125;&quot;)</span></span><br><span class="line"><span class="comment">//@ServerEndpoint(&quot;/webSocket&quot;)</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebsocketServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IOrderGiftService orderGiftService;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在WebSocketConfig中注入Service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mliutm.gift.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mliutm.gift.service.IOrderGiftService;</span><br><span class="line"><span class="keyword">import</span> com.mliutm.gift.websocket.WebsocketServer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScans;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.server.standard.ServerEndpointExporter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 开启websocket</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/1/12 18:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ServerEndpointExporter 作用</span></span><br><span class="line"><span class="comment">     * 这个Bean会自动注册使用<span class="doctag">@ServerEndpoint</span>注解声明的websocket endpoint</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServerEndpointExporter <span class="title function_">serverEndpointExporter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServerEndpointExporter</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSenderService</span><span class="params">(IOrderGiftService orderGiftService)</span>&#123;</span><br><span class="line">        WebsocketServer.orderGiftService = orderGiftService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="线程池如何使用？"><a href="#线程池如何使用？" class="headerlink" title="线程池如何使用？"></a><font color="red">线程池如何使用？</font></h3><ol><li><p>创建线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mliutm.gift.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 服务实现类</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mliutm</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2024-01-18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderGiftServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;OrderGiftMapper, OrderGift&gt; <span class="keyword">implements</span> <span class="title class_">IOrderGiftService</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程池</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>创建任务</p><p><font color="purple">@这里使用Autowired和@Resource也不能注入service对象，也不能使用@Value注解读取yaml中的属性，所以我在这个任务类中创建了一个构造方法用来给需要的对象和属性赋值，在调用任务的时候调用这个任务类的构造方法把这个类需要的数据传递过来。然后在任务类的构造方法中，启动任务</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mliutm.gift.task;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.afterturn.easypoi.excel.ExcelExportUtil;</span><br><span class="line"><span class="keyword">import</span> cn.afterturn.easypoi.excel.entity.ExportParams;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.mapper.EntityWrapper;</span><br><span class="line"><span class="keyword">import</span> com.mliutm.gift.domain.OrderGift;</span><br><span class="line"><span class="keyword">import</span> com.mliutm.gift.service.IOrderGiftService;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.ss.usermodel.Workbook;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: mliutm</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024年01月25日 14:08:22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@describe</span>: 订单导出任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderExportTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String pathInServer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String fileName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IOrderGiftService orderGiftService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderExportTask</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderExportTask</span><span class="params">(IOrderGiftService orderGiftService,</span></span><br><span class="line"><span class="params">                           String pathInServer, String fileName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.orderGiftService = orderGiftService;</span><br><span class="line">        <span class="built_in">this</span>.pathInServer = pathInServer;</span><br><span class="line">        <span class="built_in">this</span>.fileName = fileName;</span><br><span class="line">        <span class="built_in">this</span>.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span> * <span class="number">10</span>);</span><br><span class="line">            <span class="comment">// 执行导出逻辑</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="comment">// ExportParams() 两个参数，一个是title 表格标题, 一个是sheetName</span></span><br><span class="line">            EntityWrapper&lt;OrderGift&gt; wrapper = <span class="keyword">new</span> <span class="title class_">EntityWrapper</span>&lt;&gt;();</span><br><span class="line">            List&lt;OrderGift&gt; lists = orderGiftService.selectList(wrapper);</span><br><span class="line">            <span class="type">Workbook</span> <span class="variable">workbook</span> <span class="operator">=</span> ExcelExportUtil.exportExcel(<span class="keyword">new</span> <span class="title class_">ExportParams</span>(fileName, <span class="string">&quot;订单表&quot;</span>), OrderGift.class, lists);</span><br><span class="line">            <span class="comment">//导出文件到指定位置</span></span><br><span class="line">            path = pathInServer + fileName + <span class="string">&quot;.xlsx&quot;</span>;</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(path);</span><br><span class="line">            workbook.write(outputStream);</span><br><span class="line">            outputStream.close();</span><br><span class="line">            workbook.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mliutm.gift.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 服务实现类</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mliutm</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2024-01-18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderGiftServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;OrderGiftMapper, OrderGift&gt; <span class="keyword">implements</span> <span class="title class_">IOrderGiftService</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;export.path&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String pathInServer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;export.fileName&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String fileName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程池</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startExport</span><span class="params">()</span> &#123;</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> <span class="title class_">OrderExportTask</span>(<span class="built_in">this</span>, pathInServer, fileName));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>附带yaml中的相关配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">export:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">D:\gitSpace\gift-parent\gift-order\order\savePath\</span></span><br><span class="line">  <span class="attr">fileName:</span> <span class="string">订单列表数据</span></span><br></pre></td></tr></table></figure><h3 id="knife4j集成示范相关例子"><a href="#knife4j集成示范相关例子" class="headerlink" title="knife4j集成示范相关例子"></a>knife4j集成示范相关例子</h3><p>[knife4j集成示范相关例子](<a target="_blank" rel="noopener" href="https://gitee.com/xiaoym/swagger-bootstrap-ui-demo/tree/master/knife4j-spring-mvc-demo">swagger-bootstrap-ui-demo: knife4j 以及swagger-bootstrap-ui 集成框架示例项目 - Gitee.com</a>)</p><hr><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>jdk1.7中：</p><p>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。Segment 是一种可重入锁 ReentrantLock，在 ConcurrentHashMap 里扮演锁的角色，HashEntry 则用于存储键值对数据。</p><p>Segment数组的意义就是将一个大的table分割成多个小的table来进行加锁，也就是上面的提到的锁分离技术，而每一个Segment元素存储的是HashEntry数组+链表，这个和HashMap的数据存储结构一样。</p><p><img src="/breeze/f77810a8/v2-d8cc7dcb4af87b8146f591aea276400d_720w.png" alt="img"></p><p>1.8 中：</p><p>放弃了Segment，直接用 Node数组+链表+红黑树 的数据结构来实现，并发控制使用Synchronized + CAS来操作，整个看起来就像是优化过且线程安全的HashMap。</p><p><img src="/breeze/f77810a8/v2-f79b2da9b987bf4ca653fa099c4bda32_720w.png" alt="img"></p><p>[15常见集合面试题](<a href="https%E9%81%93://zhuanlan.zhihu.com/p/267545042">15道常见的 Java集合类 面试题 - 知乎 (zhihu.com)</a>)</p><hr><h3 id="微服务架构怎么理解"><a href="#微服务架构怎么理解" class="headerlink" title="微服务架构怎么理解"></a>微服务架构怎么理解</h3><p>微服务也是一个分布式系统，它将单体应用进行细粒度拆分，形成多个微服务，每个服务独立运行，每个服务也都可以有自己的数据库，服务之间使用HTTP通信，互相协调完成整个系统的业务。<br>它的优点是服务之间解耦合，不同的服务可以有不同的编程语言，技术选型多元化，支持敏捷开发<br>他的缺点是分布式事务很复杂，部署麻烦，技术成本高，服务间通信对性能也有一定的损耗</p><hr><h3 id="使用什么技术实现微服务架构的，常用组件"><a href="#使用什么技术实现微服务架构的，常用组件" class="headerlink" title="使用什么技术实现微服务架构的，常用组件"></a>使用什么技术实现微服务架构的，常用组件</h3><p>​	常用组件：nacos、gateway、sentinel、openFeign</p><h4 id="注册中心的工作原理"><a href="#注册中心的工作原理" class="headerlink" title="注册中心的工作原理"></a>注册中心的工作原理</h4><p>​ 服务注册与发现： Nacos Discovery负责服务的注册和发现。服务提供者在启动时向Nacos注册自己的服务信息（IP、端口、服务名），而服务消费者可以通过Nacos查询可用的服务列表。<br>​ 健康检查： Nacos能够对注册的服务进行健康检查。当服务提供者不健康或不可用时，Nacos能够自动将其从服务列表中剔除，确保服务消费者只会访问到可用的服务。<br>​ 负载均衡： Nacos提供负载均衡功能，确保请求能够被分发到多个可用的服务实例上，提高系统的稳定性和性能。<br>​ 集群管理： Nacos支持搭建多个节点的集群，通过集群来提高系统的可用性和扩展性。</p><h4 id="nacos多长时间续约一次-5s"><a href="#nacos多长时间续约一次-5s" class="headerlink" title="nacos多长时间续约一次 5s"></a>nacos多长时间续约一次 5s</h4><h4 id="openFeign在项目中哪里使用到"><a href="#openFeign在项目中哪里使用到" class="headerlink" title="openFeign在项目中哪里使用到"></a>openFeign在项目中哪里使用到</h4><p>订单服务中创建订单 需要通过菜品skuIds获取对应菜品sku信息，需要使用openFeign调用菜品服务feign接口</p><h4 id="网络闪断怎么解决，"><a href="#网络闪断怎么解决，" class="headerlink" title="网络闪断怎么解决，"></a>网络闪断怎么解决，</h4><p>openFeign会自动重试，重试多次失败了熔断降级，除此之外还可以做集群</p><h4 id="重试有什么问题，幂等性校验-怎么校验"><a href="#重试有什么问题，幂等性校验-怎么校验" class="headerlink" title="重试有什么问题，幂等性校验 怎么校验"></a>重试有什么问题，幂等性校验 怎么校验</h4><p>每个请求都附带一个唯一标识符，在处理请求前先检查该标识符是否已经被处理过。这个标识符可以是请求的ID、一个单独生成的token或者请求中的某个唯一字段。</p><hr><h3 id="你们项目支持多少并发"><a href="#你们项目支持多少并发" class="headerlink" title="你们项目支持多少并发? "></a><mark>你们项目支持多少并发?</mark></h3><p>我们的项目预计是支持50W,<br>我们项目使用的是微服务架构，对并发比较高微服务（比如搜索服务等）进行集群，我们也对服务依赖对的组件redis，es，mq等进行集群，<br>并且也使用了相关的优化技术，比如mysql，jvm优化，分布式优化等，所以支持50W并发是没有问题的。<br>我们测试也做过性能测试支持50W并发是没有问题的。</p><hr><h3 id="项目开发有没有什么流程？-codearts，"><a href="#项目开发有没有什么流程？-codearts，" class="headerlink" title="项目开发有没有什么流程？  codearts，"></a><mark>项目开发有没有什么流程？ codearts，</mark></h3><p>使用的是敏捷开发模式</p><ul><li>获取需求</li><li>分析需求并且设置优先级</li><li>制定迭代计划</li><li>执行每个迭代<ul><li>分配需求</li><li>开发</li><li>测试</li></ul></li><li>集成测试</li><li>上线</li></ul><hr><h3 id="测试发现问题怎么办？-bug管理系统（是codearts的一个模块）"><a href="#测试发现问题怎么办？-bug管理系统（是codearts的一个模块）" class="headerlink" title="测试发现问题怎么办？ bug管理系统（是codearts的一个模块）"></a><mark>测试发现问题怎么办？ bug管理系统（是codearts的一个模块）</mark></h3><ul><li><p>测试发现问题</p></li><li><p>找开发确认是问题</p></li><li><p>测试就在系统里面体问题单走给开发</p></li><li><p>开发就修改bug,代码转测后</p></li><li><p>把这个问题单走给测试,上面会写在那个版本进行测试</p></li><li><p>测试在那个版本进行测试,如果没有问题了,直接关闭问题单了.</p></li></ul><hr><h3 id="hashmap为什么要使用红黑树不使用自平衡二叉树？"><a href="#hashmap为什么要使用红黑树不使用自平衡二叉树？" class="headerlink" title="hashmap为什么要使用红黑树不使用自平衡二叉树？"></a>hashmap为什么要使用红黑树不使用自平衡二叉树？</h3><p>HashMap 在 Java 中使用红黑树来处理哈希冲突的情况，而不是使用自平衡二叉树，是因为红黑树具有更好的平衡性能。红黑树是一种特殊的二叉搜索树，它可以在保持相对平衡的同时，提供较快的插入、删除和查找操作。</p><p>相比之下，普通的自平衡二叉树（如 AVL 树）虽然也能够保持树的平衡，但在某些特定场景下会出现性能问题。例如，AVL 树在进行插入和删除操作时可能需要频繁地进行旋转操作，这会增加操作的时间复杂度。而红黑树通过引入额外的约束条件和旋转操作，可以更好地维护树的平衡性，并且在大多数情况下保持较好的性能表现。</p><p>因此，HashMap 使用红黑树作为解决哈希冲突的一种方式，可以更好地平衡性能和空间的需求，提高整体的运行效率。</p><hr><h3 id="红黑树特性"><a href="#红黑树特性" class="headerlink" title="红黑树特性"></a>红黑树特性</h3><p>红黑树是一种自平衡的二叉搜索树，它具有以下特性：</p><ol><li><p><strong>节点颜色：</strong> 每个节点要么是红色，要么是黑色。</p></li><li><p><strong>根节点特性：</strong> 根节点是黑色的。</p></li><li><p><strong>叶子节点特性：</strong> 叶子节点（NIL 节点）都是黑色的。注意，这里的叶子节点指的是空节点（null）或者没有子节点的节点。</p></li><li><p><strong>节点颜色规则：</strong> 红色节点的父节点和子节点都必须是黑色的。换句话说，红色节点不能连续出现，红色节点只能有黑色的父节点和黑色的子节点。</p></li><li><p><strong>路径特性：</strong> 从任一节点到其每个叶子节点的所有路径上，必须包含相同数量的黑色节点。这个特性保证了红黑树的平衡，因为任意路径上的黑色节点数量都是相等的。</p></li></ol><p>通过这些特性，红黑树可以保持相对平衡，避免树的高度过高，从而保证了插入、删除和查找等操作的时间复杂度始终保持在 O(log n) 的范围内，其中 n 是树中节点的数量。因此，红黑树在实际应用中被广泛使用，例如在数据结构中的 Map、Set 和数据库索引等场景中。</p><hr><h3 id="CRUD中，具体哪些操作需要做幂等性校验？"><a href="#CRUD中，具体哪些操作需要做幂等性校验？" class="headerlink" title="CRUD中，具体哪些操作需要做幂等性校验？"></a>CRUD中，具体哪些操作需要做幂等性校验？</h3><p>在RESTful API中，通常需要对以下几种操作进行幂等性校验：</p><ol><li><p>创建（Create）操作（POST）：确保每次相同的创建请求都能产生相同的结果，避免因为重复请求导致资源的多次创建。可以使用唯一标识符或幂等性标识符（Idempotency Key）来进行校验。</p></li><li><p>更新（Update）操作（PUT&#x2F;PATCH）：确保每次相同的更新请求都能产生相同的结果，避免因为重复请求导致资源的多次更新。需要使用版本控制或乐观锁来确保并发更新时的一致性。</p></li><li><p>删除（Delete）操作（DELETE）：确保多次相同的删除请求都能产生相同的结果，重复的删除请求不会导致错误结果。</p></li></ol><p>除此之外，读取（Read）操作（GET）通常是幂等的，即进行多次相同的读操作会得到相同的结果，因此不需要进行特殊的幂等性校验。</p><p>在进行幂等性校验时，可以使用标识符（如唯一标识符、幂等性标识符）或者通过版本控制、乐观锁等方式来确保每次请求的幂等性。这些措施能确保系统在处理重复请求时能够产生一致的结果，避免产生冲突或错误的操作。</p><hr><h3 id="spring中，用了哪些设计模式？"><a href="#spring中，用了哪些设计模式？" class="headerlink" title="spring中，用了哪些设计模式？"></a>spring中，用了哪些设计模式？</h3><p>Spring框架中使用了多种设计模式，其中一些主要的设计模式包括：</p><ol><li><p>依赖注入（Dependency Injection）：Spring使用依赖注入设计模式，通过IoC容器管理和注入对象之间的依赖关系。这样可以实现松耦合、可替换依赖和更好的可测试性。</p></li><li><p>单例模式（Singleton Pattern）：Spring框架中的Bean默认是单例的，从容器中获取的实例都是同一个实例。这样可以节省资源，提高性能。</p></li><li><p>工厂模式（Factory Pattern）：Spring使用工厂模式创建和管理Bean实例，通过Bean工厂来创建和提供对象，实现了对象的创建和获取的分离。</p></li><li><p>观察者模式（Observer Pattern）：Spring框架中的事件机制使用了观察者模式，当特定事件发生时，被监听的对象会收到通知并做出相应的处理。</p></li><li><p>模板模式（Template Pattern）：Spring框架中的JdbcTemplate和HibernateTemplate等模板类，使用了模板模式来封装一组通用的操作流程，简化了数据库访问和ORM操作。</p></li><li><p>代理模式（Proxy Pattern）：Spring AOP（面向切面编程）中使用了代理模式来实现切面（Aspect）的横切逻辑，实现了横切关注点和业务逻辑的分离。</p></li><li><p>适配器模式（Adapter Pattern）：Spring中的适配器模式用于处理各种不同的数据源或接口，使它们能够适配到统一的接口进行统一访问。</p></li></ol><p>这些设计模式的应用使得Spring框架具有高扩展性、灵活性和可维护性，极大地简化了应用程序的开发和管理。</p><hr><h3 id="factorybean和beanfactory的区别？"><a href="#factorybean和beanfactory的区别？" class="headerlink" title="factorybean和beanfactory的区别？"></a>factorybean和beanfactory的区别？</h3><p>FactoryBean和BeanFactory是Spring框架中两个不同的概念，它们有着不同的作用和功能。</p><ol><li><p>FactoryBean：</p><ul><li>FactoryBean是一个接口，它是一个工厂bean，它可以用来产生其他bean实例。</li><li>实现FactoryBean接口的类需要提供自定义的逻辑来创建和返回特定的bean实例，这意味着可以在FactoryBean的实现类中进行一些特定的逻辑来创建bean，例如条件化的创建，使用缓存等。</li><li>FactoryBean在Spring配置文件中被声明为一个bean，在使用时，通过FactoryBean的getObject()方法来获取所需的bean实例。</li></ul></li><li><p>BeanFactory：</p><ul><li>BeanFactory是Spring框架的核心接口之一，用于管理bean的生命周期和依赖注入等操作。</li><li>BeanFactory负责实例化、定位、配置应用程序中的bean对象，其中包括单例、原型、懒加载、依赖注入等功能。</li><li>Spring框架的IoC容器（如ApplicationContext）是BeanFactory接口的一个具体实现，它负责加载和管理Bean对象。</li></ul></li></ol><p>总结起来，FactoryBean是一个专门用于创建bean的工厂接口，并且通常需要开发者来自定义实现；而BeanFactory是Spring框架提供的用于管理bean的核心接口，管理整个应用程序中的bean对象，并提供依赖注入和生命周期管理等功能。</p><hr><h3 id="老杜Spring文档（重点关注切面）"><a href="#老杜Spring文档（重点关注切面）" class="headerlink" title="老杜Spring文档（重点关注切面）"></a>老杜Spring文档（重点关注切面）</h3><p><a target="_blank" rel="noopener" href="https://www.yuque.com/dujubin/ltckqu/kipzgd#">老杜Spring6文档-mg9b</a></p><hr><h3 id="解释一下什么是servlet"><a href="#解释一下什么是servlet" class="headerlink" title="解释一下什么是servlet"></a>解释一下什么是servlet</h3><p>Servlet是一种在Web服务器上运行的Java程序。它可以接收来自客户端的请求并生成相应的响应。Servlet通常用于处理动态Web页面的生成和交互，可以进行数据库访问、用户认证、数据处理等。Servlet在服务器端运行，可以与客户端的浏览器进行通信，提供动态内容和交互功能。</p><p>Servlet通常被用于处理HTTP请求和响应，可以生成HTML内容或者与客户端进行交互。在Java EE（Enterprise Edition）中，Servlet是一种被广泛应用的技术，可以作为构建企业级Web应用的基础组件。通过Servlet技术，开发人员可以编写灵活、可扩展和高性能的Web应用。</p><p>Servlet通常被部署在Servlet容器中，最常见的Servlet容器包括Tomcat、Jetty、Weblogic等。这些Servlet容器负责管理和执行Servlet程序，提供了一系列的API和工具来简化Servlet的开发和部署。</p><hr><h3 id="构造器是否可被override"><a href="#构造器是否可被override" class="headerlink" title="构造器是否可被override"></a>构造器是否可被override</h3><p>在Java中，构造器（Constructor）不能被重写（override）。构造器是用来初始化对象的特殊方法，它们与普通方法不同，没有返回类型，并且与类同名。当创建一个类的对象时，构造器会被自动调用以初始化对象的状态。</p><p>虽然构造器不能被重写，但是可以通过方法的重载来实现类似的功能。方法的重载是指在同一个类中允许存在多个同名的方法，它们的参数列表不同。因此，如果需要在不同情况下初始化对象的方式不同，可以使用多个不同参数列表的构造器（方法重载）来达到类似效果。</p><p>总之，在Java中构造器是不能被重写的，但可以通过方法的重载来实现类似的功能。</p><hr><h3 id="throw和throws的区别？"><a href="#throw和throws的区别？" class="headerlink" title="throw和throws的区别？"></a>throw和throws的区别？</h3><p>在Java中，throw和throws是两个关键字，用于处理异常，但它们有不同的作用和用法。</p><ol><li><p>throw：</p><ul><li>throw关键字用于手动抛出一个异常对象。即，当程序中发生某种错误或不符合条件的情况时，可以使用throw关键字来创建并抛出一个异常对象。</li><li>例如：<code>throw new IllegalArgumentException(&quot;Invalid input&quot;)</code>，这个语句会抛出一个IllegalArgumentException异常。</li></ul></li><li><p>throws：</p><ul><li>throws关键字用于在方法签名中声明可能会抛出的异常，用在方法的参数列表后面。</li><li>它表示该方法可能会抛出指定类型的异常，调用这个方法的代码需要处理这个异常，通常通过try-catch块或者再次使用throws关键字来将异常抛给上层调用者。</li><li>例如：<code>public void readFile() throws IOException &#123; ... &#125;</code>，这个方法声明了可能会抛出IOException异常。</li></ul></li></ol><p>总结：</p><ul><li>throw用于手动抛出异常对象。</li><li>throws用于在方法签名中声明可能会抛出的异常类型。</li></ul><hr><h3 id="软件开发中，什么是一次会话？"><a href="#软件开发中，什么是一次会话？" class="headerlink" title="软件开发中，什么是一次会话？"></a>软件开发中，什么是一次会话？</h3><p>[会话技术——Cookies和Session详解](<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/80832251">会话技术——Cookies和Session详解 - 知乎 (zhihu.com)</a>)</p><hr><h3 id="什么是Refresh-token"><a href="#什么是Refresh-token" class="headerlink" title="什么是Refresh token?"></a>什么是Refresh token?</h3><p>[JWT中RefreshToken的应用场景及刷新token的具体实现思路](<a target="_blank" rel="noopener" href="https://blog.csdn.net/isFuong/article/details/114946766#:~:text=%E5%9C%A8JWT">https://blog.csdn.net/isFuong/article/details/114946766#:~:text=在JWT</a> token中，refreshToken的作用主要是避免token过期时，前端用户突然退出登录产生不良体验。,试想，如果你正访问某基于jwt token机制的网站，该网站token过期时间是24小时， 你在23小时59分前已经登录过了，现在你访问某页面时，正好处于token过期时间24小时的临界点，)</p><hr><h3 id="在微服务项目中，用户服务和授权服务的关系以及各自的职责"><a href="#在微服务项目中，用户服务和授权服务的关系以及各自的职责" class="headerlink" title="在微服务项目中，用户服务和授权服务的关系以及各自的职责?"></a><font color="red">在微服务项目中，用户服务和授权服务的关系以及各自的职责?</font></h3><p>在一个微服务架构中，用户服务和授权服务通常有不同的职责和功能。下面是它们通常的关系和职责：</p><p>用户服务：</p><ul><li>负责管理用户的注册、登录、个人信息管理等功能。</li><li>可能包括用户管理、密码管理、权限设置、用户资料管理等功能。</li><li>提供用户信息的存储和管理，可能会包括用户数据的CRUD操作。</li><li>可能还负责与其他服务交互，如订单服务、支付服务等，需要验证和识别用户身份信息。</li></ul><p>授权服务（认证和授权服务）：</p><ul><li>负责实现登录认证和授权功能，包括用户身份验证、令牌颁发、令牌验证等。</li><li>可能包括实现单点登录（SSO）、多因素认证（MFA）等高级认证功能。</li><li>提供用于生成和验证访问令牌（access token）、刷新令牌（refresh token）等授权相关功能。</li><li>可能还负责与其他服务交互，向其他服务提供认证和授权服务，确保受保护资源只能被授权的用户访问。</li></ul><p>两个服务之间的关系：</p><ul><li>用户服务可能需要调用授权服务的接口来验证用户的身份和权限，以确保用户在访问受保护资源时，具有适当的访问权限。</li><li>授权服务通常会与用户服务进行集成，从用户服务获取用户信息，并根据这些信息进行身份验证和授权。</li></ul><p>总的来说，用户服务负责用户管理和个人信息相关功能，而授权服务则关注用户身份认证和资源访问控制。两者一起协同工作，确保用户的身份信息得到合适的验证和授权，使得整个微服务系统的安全性得以确保。</p><hr><h3 id="用JS实现对数组的去重？"><a href="#用JS实现对数组的去重？" class="headerlink" title="用JS实现对数组的去重？"></a>用JS实现对数组的去重？</h3><p>使用 JavaScript 实现数组去重可以通过几种方法，包括使用 Set、使用 filter 方法以及使用 reduce 方法。</p><p>以下是使用 Set 方法实现数组去重的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">33</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">const</span> b = [...<span class="keyword">new</span> <span class="title class_">Set</span>(a)];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// [1, 2, 3, 33, 4, 5, 6, 7]</span></span><br></pre></td></tr></table></figure><p>使用 Set 方法可以创建一个新的 Set 对象，它具有唯一的值，然后将原数组中的元素通过拓展运算符 (…) 放入 Set 中，最后将 Set 转换回数组即可得到去重后的数组。</p><p>另外，使用 filter 方法实现数组去重的示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">33</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">const</span> b = a.<span class="title function_">filter</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> a.<span class="title function_">indexOf</span>(item) === index);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// [1, 2, 3, 33, 4, 5, 6, 7]</span></span><br></pre></td></tr></table></figure><p>在这个示例中，使用 filter 方法遍历数组并利用 indexOf 方法来判断元素第一次出现的位置，只保留第一次出现的元素。</p><p>最后，使用 reduce 方法实现数组去重的示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">33</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">const</span> b = a.<span class="title function_">reduce</span>(<span class="function">(<span class="params">uniqueArr, item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!uniqueArr.<span class="title function_">includes</span>(item)) &#123;</span><br><span class="line">    uniqueArr.<span class="title function_">push</span>(item);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> uniqueArr;</span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// [1, 2, 3, 33, 4, 5, 6, 7]</span></span><br></pre></td></tr></table></figure><p>在这个示例中，使用 reduce 方法遍历数组，并对每个元素判断是否已经存在于结果数组中，如果不存在则添加到结果数组中。</p><p>以上是几种常见的数组去重方法，你可以根据实际情况选择适合的方法来实现数组去重。</p><hr><h3 id="在高并发情况下，如何保证系统的高可用？"><a href="#在高并发情况下，如何保证系统的高可用？" class="headerlink" title="在高并发情况下，如何保证系统的高可用？"></a>在高并发情况下，如何保证系统的高可用？</h3><p>在高并发情况下，为了保证系统的高可用性，可以采取以下一些措施：</p><ol><li><p>负载均衡：使用负载均衡器来均衡请求分发到不同的服务器上，确保每台服务器的负载都在可接受的范围内。</p></li><li><p>水平扩展：通过增加服务器的数量来处理更多的并发请求，从而提高系统的整体处理能力。</p></li><li><p>缓存：使用缓存来减轻数据库和其他资源的压力，提高系统的响应速度。</p></li><li><p>异步处理：将一些耗时的操作改为异步处理，避免阻塞线程和影响系统的响应速度。</p></li><li><p>数据库优化：对数据库进行优化，包括使用索引、分片和缓存等技术来提高数据库的性能和并发处理能力。</p></li><li><p>容灾备份：建立容灾备份系统，确保在服务器或网络故障的情况下，系统还能保持正常运行。</p></li><li><p>限流控制：对请求进行限流，避免过多请求导致系统崩溃或负载过高。</p></li></ol><p>以上这些措施可以结合使用，来保证系统在高并发情况下的高可用性和稳定性。</p><hr><h3 id="Mysql数据库中join-的inner-join-left-join-right-join-区别"><a href="#Mysql数据库中join-的inner-join-left-join-right-join-区别" class="headerlink" title="Mysql数据库中join 的inner join,left join,right join 区别?"></a>Mysql数据库中join 的inner join,left join,right join 区别?</h3><p>以 A，B 两张表为例<br>查询A 和 B交集的数据用______<br>查询 A 中所有数据，B中和A表相关联的数据用______<br>查询 B中所有数据，A中和B表相关联的数据用______</p><p>在 MySQL 数据库中，JOIN 用于将多个表中的行相互连接起来。</p><ul><li><p>INNER JOIN（内连接）：返回在两个表中存在匹配关系的行。即返回 A 和 B 两张表中有交集的数据。一般使用 ON 或 USING 子句指定连接条件。</p><p>例如：SELECT * FROM A INNER JOIN B ON A.id &#x3D; B.id;</p></li><li><p>LEFT JOIN（左连接）：返回左表（A）的所有行，以及右表（B）中与左表关联的行。如果右表中没有匹配的行，则返回 NULL 值。</p><p>例如：SELECT * FROM A LEFT JOIN B ON A.id &#x3D; B.id;</p></li><li><p>RIGHT JOIN（右连接）：返回右表（B）的所有行，以及左表（A）中与右表关联的行。如果左表中没有匹配的行，则也返回 NULL 值。</p><p>例如：SELECT * FROM A RIGHT JOIN B ON A.id &#x3D; B.id;</p></li></ul><p>具体到你提到的问题上：</p><ul><li><p>查询 A 和 B 交集的数据用内连接（INNER JOIN）：</p><p>例如：SELECT * FROM A INNER JOIN B ON A.id &#x3D; B.id;</p></li><li><p>查询 A 中所有数据，B 中和 A 表相关联的数据用左连接（LEFT JOIN）：</p><p>例如：SELECT * FROM A LEFT JOIN B ON A.id &#x3D; B.id;</p></li><li><p>查询 B 中所有数据，A 中和 B 表相关联的数据用右连接（RIGHT JOIN）：</p><p>例如：SELECT * FROM A RIGHT JOIN B ON A.id &#x3D; B.id;</p></li></ul><p>其中，A 和 B 是两个表的名称，A.id 和 B.id 是连接条件。你可以根据实际情况调整连接条件和查询字段。</p><hr><h3 id="MYSQL的两种存储引擎-MYISAM-和INNODB-的区别，各自的适用场景"><a href="#MYSQL的两种存储引擎-MYISAM-和INNODB-的区别，各自的适用场景" class="headerlink" title="MYSQL的两种存储引擎 MYISAM 和INNODB 的区别，各自的适用场景?"></a>MYSQL的两种存储引擎 MYISAM 和INNODB 的区别，各自的适用场景?</h3><p>MySQL 提供了多种存储引擎，其中两种较为常用的是 MyISAM 和 InnoDB。</p><p>以下是 MyISAM 和 InnoDB 的区别以及适用场景：</p><ol><li><p>存储结构：</p><ul><li>MyISAM：采用非聚集索引(Clustered Index)，数据文件和索引文件是分开存储的。</li><li>InnoDB：采用聚集索引（Clustered Index），数据文件和索引文件是紧密相连的。</li></ul></li><li><p>事务支持：</p><ul><li>MyISAM：不支持事务处理，不支持回滚操作，所以不具备 ACID 特性。</li><li>InnoDB：支持事务处理，支持回滚操作，具备 ACID 特性。</li></ul></li><li><p>并发性能：</p><ul><li>MyISAM：采用表级锁定，当操作一条记录时，会锁定整个表，对于读密集型任务效果较好，但对于写密集型任务则会有并发性能问题。</li><li>InnoDB：采用行级锁定，可以支持更高的并发性，多个事务可以同时读写不同的行。</li></ul></li><li><p>外键支持：</p><ul><li>MyISAM：不支持外键约束，需要在应用层面进行处理。</li><li>InnoDB：支持外键约束，可以保证数据的一致性，增强数据完整性。</li></ul></li><li><p>数据完整性：</p><ul><li>MyISAM：不支持崩溃后的数据恢复，容易发生数据损坏。</li><li>InnoDB：支持崩溃后的数据恢复，具备更高的数据完整性。</li></ul></li></ol><p>根据上述区别，可以根据不同的需求和场景来选择适合的存储引擎：</p><ul><li>如果需要高速读取，不需要事务支持，并且对于数据完整性和并发性能要求不高，可以选择 MyISAM。</li><li>如果需要支持事务处理，具备较高的数据完整性和并发性能，并且对于崩溃后的数据恢复有要求，可以选择 InnoDB。</li></ul><p>需要注意的是，在 MySQL 5.5.5 版本之后，InnoDB 成为了默认的存储引擎，因为它提供了更好的特性和性能。因此，大多数情况下，推荐使用 InnoDB 存储引擎。但是，在某些特定场景下，如只有读取操作的数据仓库，MyISAM 可能会更适合。</p><hr><h3 id="java中，String类的常用方法"><a href="#java中，String类的常用方法" class="headerlink" title="java中，String类的常用方法"></a>java中，String类的常用方法</h3><ol><li>length() - 返回字符串的长度</li><li>charAt(int index) - 返回指定索引位置的字符</li><li>isEmpty() - 判断字符串是否为空</li><li>toUpperCase() - 将字符串转换为大写</li><li>toLowerCase() - 将字符串转换为小写</li><li>equals(Object obj) - 比较字符串是否相等</li><li>indexOf(String str) - 返回指定子字符串在字符串中第一次出现的位置</li><li>lastIndexOf(String str) - 返回指定子字符串在字符串中最后一次出现的位置</li><li>substring(int beginIndex) - 返回从指定索引位置开始到字符串末尾的子字符串</li><li>substring(int beginIndex, int endIndex) - 返回从指定索引位置开始到指定索引位置结束的子字符串</li><li>replace(char oldChar, char newChar) - 替换字符</li><li>replace(CharSequence target, CharSequence replacement) - 替换指定子字符串</li><li>trim() - 去除字符串两端的空白字符</li><li>split(String regex) - 按指定正则表达式分割字符串为字符串数组</li><li>contains(CharSequence s) - 判断字符串是否包含指定的字符序列</li><li>startsWith(String prefix) - 判断字符串是否以指定前缀开头</li><li>endsWith(String suffix) - 判断字符串是否以指定后缀结尾</li><li>compareTo(String anotherString) - 比较两个字符串的大小关系</li><li>valueOf(dataType x) - 将指定数据类型转换为字符串</li><li>format(String format, Object… args) - 根据指定格式进行字符串格式化</li><li>join(CharSequence delimiter, CharSequence… elements) - 将多个字符串用指定分隔符连接起来</li></ol><hr><h3 id="什么是ES脑裂问题？如何解决？"><a href="#什么是ES脑裂问题？如何解决？" class="headerlink" title="什么是ES脑裂问题？如何解决？"></a>什么是ES脑裂问题？如何解决？</h3><p>ES（Elasticsearch）脑裂问题指的是在分布式集群中出现网络分区或节点故障等情况导致集群内部的节点形成多个独立的子群，每个子群都认为自己是整个集群的合法主节点，从而导致数据一致性和集群稳定性的问题。</p><p>脑裂问题的解决方法主要有以下几种：</p><ol><li><p>投票机制：通过引入仲裁节点（Arbiter）或者使用一致性算法进行投票，集群节点通过多数票数来决定合法的主节点。这样可以避免脑裂问题出现。</p></li><li><p>心跳检测：通过设置心跳检测机制，检测节点是否存活或者是否与集群内的其他节点保持连接。当节点超过一定时间没有发送心跳信号，则认为节点宕机，集群会将宕机节点剔除，从而避免脑裂问题。</p></li><li><p>数据同步机制：通过配置合适的数据同步策略和备份机制，确保节点之间的数据一致性。例如，使用复制机制（replication）或者分片机制（sharding）来保证数据在多个节点之间的同步和备份。</p></li><li><p>配置优化：根据实际情况，合理配置集群的相关属性，例如调整超时设置、网络连接数、节点优先级等，以提高集群的稳定性和容错性。</p></li><li><p>监控和自动恢复：通过实时监控集群状态和节点健康状况，及时发现脑裂问题或异常情况，并采取自动化的措施进行恢复，例如自动重新分配副本、重新选举主节点等。</p></li></ol><p>需要注意的是，脑裂问题是一个复杂的分布式系统挑战，解决方案需要结合具体的应用场景和需求来进行选择和调整。同时，定期进行集群的测试和性能评估，以确保系统在面临网络分区等异常情况时能够有效地处理和恢复。</p><hr><h3 id="Redis集群有脑裂问题吗？"><a href="#Redis集群有脑裂问题吗？" class="headerlink" title="Redis集群有脑裂问题吗？"></a>Redis集群有脑裂问题吗？</h3><p>在Redis集群中也存在脑裂问题的风险。脑裂问题是一个普遍存在于分布式系统中的挑战，它可能是由网络分区、节点故障或通信延迟等引起的，这些问题可能导致集群内的节点形成多个子集群并且各自认为自己是合法的主节点。</p><p>为了减少Redis集群出现脑裂问题的可能性，可以采取以下一些措施：</p><ol><li><p>Quorum（法定人数）：确保集群中的节点达成共识，例如通过Quorum机制，集群在做出决定时需要超过半数节点的同意，这样就能够避免脑裂问题的发生。</p></li><li><p>心跳机制：使用心跳检测来监视节点的健康状况，及时发现节点故障或网络分区，以便采取相应的措施来保证集群的稳定性。</p></li><li><p>数据同步和副本机制：通过合理配置Redis的复制和持久化机制，确保各个节点之间数据的一致性和可靠性，能够有效地减少脑裂问题的发生。</p></li><li><p>自动故障转移：通过设置自动故障转移机制，当节点发生故障时能够及时地自动进行主从节点的切换，保证集群的可用性。</p></li></ol><p>需要注意的是，虽然这些措施可以帮助减少Redis集群出现脑裂问题的可能性，但并不能完全消除脑裂问题。因此，设计和配置一个鲁棒性强、可靠性高的Redis集群对于确保数据安全和系统稳定性非常重要。</p><hr><h3 id="springboot整合ES的步骤？"><a href="#springboot整合ES的步骤？" class="headerlink" title="springboot整合ES的步骤？"></a>springboot整合ES的步骤？</h3><p>将Spring Boot与Elasticsearch（ES）进行整合的步骤如下：</p><ol><li>添加Elasticsearch依赖：打开pom.xml文件，添加以下依赖：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>配置Elasticsearch连接：在application.properties文件中添加以下配置，根据实际情况进行调整：</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.data.elasticsearch.cluster-nodes</span>=<span class="string">localhost:9200</span></span><br><span class="line"><span class="attr">spring.data.elasticsearch.cluster-name</span>=<span class="string">my-application</span></span><br></pre></td></tr></table></figure><ol start="3"><li>创建实体类：创建一个用于映射ES文档的实体类，例如：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.Id;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.annotations.Document;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Document(indexName = &quot;myindex&quot;, type = &quot;mytype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyEntity</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String field1;</span><br><span class="line">    <span class="keyword">private</span> String field2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略构造方法和Getter/Setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>创建ES的Repository接口：创建一个接口，继承自ElasticsearchRepository，用于实现对ES的操作，例如：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.repository.ElasticsearchRepository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyEntityRepository</span> <span class="keyword">extends</span> <span class="title class_">ElasticsearchRepository</span>&lt;MyEntity, String&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>编写业务逻辑：在Service层中，使用MyEntityRepository进行CRUD操作。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyEntityService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyEntityRepository myEntityRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyEntityService</span><span class="params">(MyEntityRepository myEntityRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.myEntityRepository = myEntityRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveMyEntity</span><span class="params">(MyEntity myEntity)</span> &#123;</span><br><span class="line">        myEntityRepository.save(myEntity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他业务方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，Spring Boot与Elasticsearch的整合就完成了。现在您可以使用MyEntityService来进行对ES文档的增删改查操作。</p><p>请注意，上述步骤仅为一个简单示例，实际应用可能需要更多配置和实现。您可以根据自己的需求进行调整和扩展。</p><hr><h4 id="nginx正向代理和反向代理"><a href="#nginx正向代理和反向代理" class="headerlink" title="nginx正向代理和反向代理"></a>nginx正向代理和反向代理</h4><p>Nginx是一款高性能的Web服务器和反向代理服务器，它支持正向代理和反向代理两种模式。</p><ol><li>正向代理：当客户端需要访问互联网时，可以配置Nginx作为正向代理服务器。客户端向Nginx发送请求，Nginx会代为向目标服务器发送请求，并将响应返回给客户端。在这种模式下，目标服务器无法直接访问客户端，它只知道Nginx作为代理服务器发起的请求。</li></ol><p>正向代理的一些应用场景包括：</p><ul><li>绕过防火墙：在访问一些被墙的网站时，可以通过配置Nginx作为正向代理来绕过防火墙限制。</li><li>缓存加速：Nginx可以缓存请求的响应，提高后续请求的速度。</li><li>隐藏客户端IP：客户端可以通过Nginx作为正向代理来隐藏真实的IP地址，保护隐私。</li></ul><ol start="2"><li>反向代理：当有多个服务器提供相同的服务时，可以配置Nginx作为反向代理服务器。客户端向Nginx发送请求，Nginx会根据一定的规则将请求转发给后端的目标服务器，并将目标服务器的响应返回给客户端。客户端无法直接感知到后端的目标服务器，只看到Nginx作为反向代理服务器的响应。</li></ol><p>反向代理的一些应用场景包括：</p><ul><li>负载均衡：Nginx可以根据一定的算法将请求分发给多个后端服务器，以实现负载均衡，提高系统的并发能力和稳定性。</li><li>缓存加速：类似于正向代理，Nginx也可以缓存后端服务器的响应，优化性能。</li><li>高可用性和故障转移：当后端服务器发生故障时，Nginx可以动态地将请求转发给其他可用的服务器，保证服务的可用性。</li></ul><p>综上所述，Nginx既可以作为正向代理服务器，也可以作为反向代理服务器，根据不同的需求来应用它的代理功能。</p><hr><hr><h4 id="TCP通信原理"><a href="#TCP通信原理" class="headerlink" title="TCP通信原理"></a>TCP通信原理</h4><p>TCP（Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层协议，用于在网络上的两个应用程序之间进行通信。TCP协议是互联网协议栈中的一部分，它提供了可靠的数据传输，确保数据的顺序和完整性。</p><p>TCP通信的原理可以简单概括为以下几个步骤：</p><ol><li><p>连接建立：在TCP通信开始之前，客户端和服务器端需要建立连接。客户端发送一个连接请求给服务器，服务器收到请求后回复一个连接确认。一旦连接建立，双方就可以开始互相发送数据了。</p></li><li><p>数据传输：一旦连接建立，数据可以在客户端和服务器之间自由传输。数据被分割成小的数据段，每个数据段带有序号，并在接收端重新组装成完整的数据。</p></li><li><p>可靠性和流量控制：TCP协议提供了可靠的数据传输，确保数据不会丢失和损坏。它还使用流量控制机制，确保发送端不会发送过多的数据导致接收端处理不过来。</p></li><li><p>连接结束：通信结束后，客户端和服务器可以选择终止TCP连接。终止连接时，双方会发送一个终止连接请求给对方，并等待对方的确认之后再关闭连接。</p></li></ol><p>总的来说，TCP通信通过连接建立、数据传输、可靠性和流量控制以及连接结束这几个步骤实现可靠的数据传输和通信。这使得TCP成为了互联网上最常用的传输协议之一。</p><hr><h4 id="4层TCP-IP协议"><a href="#4层TCP-IP协议" class="headerlink" title="4层TCP&#x2F;IP协议"></a>4层TCP&#x2F;IP协议</h4><p>TCP&#x2F;IP协议栈是一个通信协议的集合，它在计算机网络通信中起着关键作用。TCP&#x2F;IP协议栈被分为四个层级，分别是：</p><ol><li><p>应用层：应用层是整个TCP&#x2F;IP协议栈中的最高层，提供了用户接口，使不同的应用程序能够通过网络进行通信。常见的应用层协议包括HTTP、FTP、SMTP、DNS等，它们负责将数据传输到网络上并且确保其以适当的格式传输。</p></li><li><p>传输层：传输层负责在网络中的两个主机之间建立连接、传输和结束数据，同时也控制数据传输的可靠性。TCP (Transmission Control Protocol) 和 UDP (User Datagram Protocol) 是传输层的两个主要协议。TCP提供了可靠的、面向连接的数据传输，而UDP则是无连接的、不可靠的数据传输。</p></li><li><p>网络层：网络层用于在网络上的不同主机之间进行数据传输，并提供了路由和转发的功能。IP（Internet Protocol）是网络层中最重要的协议，它负责实现数据包的交换和传输。</p></li><li><p>链路层：链路层负责对物理网络进行管理，包括将数据帧发送到物理介质上，管理网络访问和错误检测。在不同的物理网络中，链路层使用不同的协议，包括以太网、Wi-Fi、PPP等。</p></li></ol><p>这些四个层级共同协作，使得TCP&#x2F;IP协议栈能够实现从网络应用到物理传输的端到端数据传输功能。它们为互联网上的数据通信提供了完整的解决方案和通信能力。</p><hr><h4 id="TCP和UDP的区别？"><a href="#TCP和UDP的区别？" class="headerlink" title="TCP和UDP的区别？"></a>TCP和UDP的区别？</h4><p>TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）是两种不同的传输层协议，它们在数据传输时具有一些重要的区别：</p><ol><li><p>连接和可靠性：TCP是面向连接的协议，它在数据传输之前需要先建立连接，确保数据的可靠性和完整性。它使用确认和重传机制，以确保数据包的顺序和准确性。而UDP是无连接的协议，不会建立连接，也不会进行数据的确认和重传，因此传输的数据没有可靠性保证。</p></li><li><p>数据包顺序：TCP会保证数据包按发送的顺序到达目的地，并在接收端重新组装数据包。而UDP不保证数据包按发送顺序到达目的地，因此在接收端需要自行处理数据包的顺序和完整性。</p></li><li><p>传输效率：由于TCP提供的数据可靠性保证和连接管理，它可能会引入一定的延迟和额外的开销。而UDP则没有这些额外的开销，因此它的传输效率可能更高。</p></li><li><p>应用场景：由于TCP提供了可靠的数据传输，因此更适合要求数据完整性和有序性的应用，例如文件传输、电子邮件、网页下载等。而UDP更适合实时性要求较高的应用，例如视频流、音频通话等，因为它不保证数据的完整性，但传输延迟更低。</p></li></ol><p>总的来说，TCP和UDP在数据传输可靠性、连接管理、传输效率和应用场景等方面有明显的区别，应用场景和需求不同时选择合适的协议是非常重要的。</p><hr><h4 id="http通信原理？"><a href="#http通信原理？" class="headerlink" title="http通信原理？"></a>http通信原理？</h4><p>HTTP（Hypertext Transfer Protocol）是一种用于传输超文本数据（如HTML）的应用层协议，是Web上数据传输的基础。以下是HTTP通信的原理：</p><ol><li><p>客户端发起请求：HTTP通信始于客户端发起一个HTTP请求。该请求通常由一个URL（Uniform Resource Locator）标识要获取的资源，如网页、图像、视频等。</p></li><li><p>服务器响应请求：一旦客户端发送了HTTP请求，服务器就会收到该请求并进行处理。服务器会根据请求中的URL和其他信息来定位所需的资源，然后生成一个HTTP响应，包含了所请求资源的数据和相关的元数据。</p></li><li><p>建立TCP连接：在HTTP通信中，客户端和服务器之间的通信是通过TCP&#x2F;IP进行的。在发送HTTP请求之前，客户端需要与服务器建立TCP连接。一旦连接建立成功，客户端就可以通过该连接向服务器发送HTTP请求，并等待服务器的响应。</p></li><li><p>发送HTTP请求：客户端向服务器发送HTTP请求，请求中包含了不同的信息，如请求的方法（GET、POST、PUT、DELETE等）、目标资源的URL、请求头部等。一旦服务器接收到请求，就会根据请求的内容来处理并生成响应。</p></li><li><p>接收HTTP响应：一旦服务器收到了HTTP请求并处理完毕，就会生成一个HTTP响应，包含了所请求资源的数据和相关的元数据。服务器通过TCP连接将HTTP响应发送给客户端。</p></li><li><p>关闭连接：一旦客户端收到了完整的HTTP响应，TCP连接可以被关闭，这样就释放了网络资源。在某些情况下，TCP连接可能会被保持活动一段时间，以便快速发送其他请求。</p></li></ol><p>总的来说，HTTP通信是通过客户端和服务器之间的HTTP请求和响应来实现的，它是建立在TCP连接之上的，用于在Web上进行数据传输和资源获取。</p><hr><h4 id="http和https的区别？"><a href="#http和https的区别？" class="headerlink" title="http和https的区别？"></a>http和https的区别？</h4><p>HTTP（Hypertext Transfer Protocol）和HTTPS（Hypertext Transfer Protocol Secure）是两种不同的通信协议，它们在数据传输的安全性和加密方面有重要的区别。</p><ol><li><p>安全性：HTTP是一种不安全的传输协议，通过HTTP传输的数据在网络上传输时是明文的，容易被攻击者窃取或篡改。而HTTPS使用了SSL&#x2F;TLS协议进行加密传输，能够确保数据在传输过程中是加密的，提高了数据的安全性。</p></li><li><p>加密方式：HTTPS使用SSL（Secure Sockets Layer）或其升级版TLS（Transport Layer Security）协议来加密数据。一旦连接建立，客户端和服务器之间的通信就是加密的。HTTP没有加密机制，传输的数据是明文的。</p></li><li><p>默认端口：HTTP默认使用端口80进行通信，而HTTPS默认使用端口443进行安全通信。</p></li><li><p>证书要求：使用HTTPS协议的网站需要获得SSL证书，证明其身份的真实性，证书的发放由权威的CA（Certificate Authority，证书颁发机构）机构进行，可以确保通信双方的身份和数据的完整性。</p></li></ol><p>总的来说，HTTPS是HTTP协议的安全版本，使用了加密保护机制，能够确保数据在传输过程中是加密的，提高了数据的安全性和完整性。相比之下，HTTP不具备加密能力，传输的数据是明文的，安全性较低。因此，对于需要保护隐私和安全性的数据通信，特别是在Web上进行敏感数据传输时，推荐使用HTTPS协议。</p><hr><h4 id="java中，List转Array调用什么方法？Array转List调用什么方法？"><a href="#java中，List转Array调用什么方法？Array转List调用什么方法？" class="headerlink" title="java中，List转Array调用什么方法？Array转List调用什么方法？"></a>java中，List转Array调用什么方法？Array转List调用什么方法？</h4><p>在Java中，可以使用以下方法来进行List和数组之间的转换：</p><ol><li>List转Array：可以使用List接口的toArray方法，该方法可以将List转换为数组。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 添加元素到list中</span></span><br><span class="line">String[] array = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[list.size()]);</span><br></pre></td></tr></table></figure><ol start="2"><li>Array转List：可以使用Arrays类中的asList方法，该方法可以将数组转换为List。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] array = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(array);</span><br></pre></td></tr></table></figure><p>需要注意的是，List转Array时，需要指定数组的类型以及数组的大小；而Array转List时，返回的List是一个固定长度的List，不能进行增删操作，因为asList方法返回的List是一个不可变的列表。</p><hr><h4 id="java中，过滤器和拦截器的作用与区别？"><a href="#java中，过滤器和拦截器的作用与区别？" class="headerlink" title="java中，过滤器和拦截器的作用与区别？"></a>java中，过滤器和拦截器的作用与区别？</h4><p>在Java中，过滤器（Filter）和拦截器（Interceptor）都用于对HTTP请求进行处理，但它们的作用和区别如下：</p><ol><li>过滤器（Filter）：</li></ol><ul><li>过滤器是Servlet规范中定义的对象，用于在请求进入Servlet之前或响应返回客户端之前执行一些预处理或后处理任务。</li><li>过滤器可以用来实现诸如日志记录、字符编码转换、鉴权、数据压缩等功能。</li><li>过滤器在web.xml中配置，可以对所有的请求进行过滤处理。</li></ul><ol start="2"><li>拦截器（Interceptor）：</li></ol><ul><li>拦截器是Spring框架中的概念，用于在方法调用前后、异常抛出前后执行一些处理任务。</li><li>拦截器通常与Spring的AOP（面向切面编程）结合使用，可以更精细地控制方法的调用。</li><li>拦截器主要用于业务逻辑层的方法拦截，例如权限验证、日志记录、事务管理等。</li></ul><p>区别：</p><ol><li>过滤器属于Servlet规范，而拦截器属于Spring框架。</li><li>过滤器工作在Servlet之前或之后，而拦截器工作在方法调用前后。</li><li>过滤器只能对所有请求进行处理，而拦截器可以更精细地控制方法的调用。</li><li>过滤器主要用于请求和响应的预处理和后处理，而拦截器主要用于业务逻辑层的方法拦截。</li></ol><hr><h4 id="controller中，用于接收请求参数的注解？"><a href="#controller中，用于接收请求参数的注解？" class="headerlink" title="controller中，用于接收请求参数的注解？"></a>controller中，用于接收请求参数的注解？</h4><p>在Java的Spring框架中，用于接收请求参数的注解主要有以下几种：</p><ol><li>@RequestParam：用于将HTTP请求中的参数绑定到控制器方法的参数上，可以指定参数的名称、是否必需、默认值等信息。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUserInfo</span><span class="params">(<span class="meta">@RequestParam</span> String userId)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>@PathVariable：用于从URI模板中提取参数值，并将其绑定到控制器方法的参数上。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/user/&#123;userId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUserInfo</span><span class="params">(<span class="meta">@PathVariable</span> String userId)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>@RequestBody：用于将HTTP请求的body部分的JSON或XML请求体绑定到控制器方法的参数上。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>@RequestHeader：用于将HTTP请求头部的信息绑定到控制器方法的参数上。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUserInfo</span><span class="params">(<span class="meta">@RequestHeader(&quot;User-Agent&quot;)</span> String userAgent)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些注解可以根据具体的需求，灵活地从HTTP请求中获取请求参数、请求体、请求头等信息，方便地进行参数绑定和处理。</p><hr><h4 id="java性能优化怎么做？"><a href="#java性能优化怎么做？" class="headerlink" title="java性能优化怎么做？"></a>java性能优化怎么做？</h4><p>Java 性能优化可以通过以下几种方式实现：</p><ol><li><p>使用合适的数据结构和算法：选择性能高效的数据结构和算法对于提高程序性能至关重要。比如对于大量数据的查找和插入操作，可以选择使用哈希表或树等数据结构，以减少查询时间复杂度。</p></li><li><p>减少内存占用：尽量避免创建大量临时对象，特别是在循环中频繁创建对象，可以重用对象或使用对象池来减少内存占用。</p></li><li><p>垃圾回收优化：及时释放不再使用的对象，避免内存泄漏。可以借助工具分析内存使用情况，优化垃圾回收策略。</p></li><li><p>多线程并发优化：合理使用多线程来充分利用多核CPU资源，避免线程竞争和死锁，减少线程切换开销。</p></li><li><p>编译器优化：使用合适的编译器参数进行代码编译，开启适当的优化选项，以提高生成的代码的执行效率。</p></li><li><p>使用缓存：在适当的场景下使用缓存，减少对数据库或其他资源的频繁访问，提高数据访问效率。</p></li><li><p>程序设计优化：对程序结构和逻辑进行优化，减少不必要的计算和IO操作，提高程序执行效率。</p></li><li><p>性能测试和调优：使用性能测试工具对程序进行测试和分析，发现性能瓶颈并对其进行调优。</p></li></ol><p>总之，Java 性能优化是一个系统工程，需要综合考虑软件、硬件以及网络等方面因素，通过代码层面、架构设计层面以及系统运行优化等多方面进行综合优化，提高程序性能。</p><hr></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://mliutm.github.io">清风</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://mliutm.github.io/breeze/f77810a8.html">https://mliutm.github.io/breeze/f77810a8.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://mliutm.github.io" target="_blank">清风</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%9F%A5%E8%AF%86%E6%9D%82%E8%B0%88/">知识杂谈</a></div><div class="post_share"><div class="social-share" data-image="/img/photo-1645943020355-305df166473d.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/breeze/3c4f69bd.html" title="Mybatis集合映射sql参数出错"><img class="cover" src="/img/photo-1692708632140-ee01624d558d.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Mybatis集合映射sql参数出错</div></div></a></div><div class="next-post pull-right"><a href="/breeze/b86f2c87.html" title="docker进阶-项目部署实战-RH"><img class="cover" src="/img/photo-1645943020355-305df166473d.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">docker进阶-项目部署实战-RH</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">清风</div><div class="author-info__description">清风洒六合，邈然不可攀</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">169</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">82</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:huangpan0805@163.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div><timing></timing></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%8F%AF%E4%BB%A5%E8%A2%AB%E7%BB%A7%E6%89%BF%E5%90%97%EF%BC%9F"><span class="toc-text">私有属性可以被继承吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%99%E9%87%8C%E9%9D%A2%E7%9A%84%E5%B1%9E%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="toc-text">&lt;insert id&#x3D;&quot;insert&quot; useGeneratedKeys&#x3D;&quot;true&quot; keyProperty&#x3D;&quot;id&quot; keyColumn&#x3D;&quot;id&quot;&gt;&lt;&#x2F;insert&gt;这里面的属性是什么意思？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ServletContextListener%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA%E5%92%8C%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">ServletContextListener中方法的执行时机和作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E4%B8%AD%EF%BC%8C%E5%8A%A0%E4%BA%86-Configuration%E6%B3%A8%E8%A7%A3%E7%9A%84%E7%B1%BB%E4%B8%AD%EF%BC%8C%E5%8F%88%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%8A%E5%8A%A0%E7%9A%84-Bean%E6%B3%A8%E8%A7%A3%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%E5%8F%AF%E4%BB%A5%E4%B8%8D%E5%8A%A0%E5%90%97%EF%BC%9F"><span class="toc-text">java中，加了@Configuration注解的类中，又在方法上加的@Bean注解有什么作用？可以不加吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2%E4%B8%AD%EF%BC%8C%E5%AF%B9%E8%8E%B7%E5%8F%96%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E6%8C%89%E9%92%AE%E8%BF%9B%E8%A1%8C%E5%80%92%E8%AE%A1%E6%97%B6%E7%9A%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%8F%91%E9%80%81%E9%AA%8C%E8%AF%81%E7%A0%81%EF%BC%89%EF%BC%9A"><span class="toc-text">前端登录界面中，对获取验证码的按钮进行倒计时的设计（发送验证码）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E4%B8%8B%E4%BB%A3%E7%A0%81%E4%B8%AD%EF%BC%8CThrowable%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">以下代码中，Throwable参数的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E4%B8%AD-serialVersionUID-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">java中 serialVersionUID 是什么？作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Maven%E4%B8%ADdependencyManagement%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">Maven中dependencyManagement的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%B0%81%E8%A3%85"><span class="toc-text">ThreadLocal工具类封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFQPS"><span class="toc-text">什么是QPS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89SpringMVC%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-text">如何定义SpringMVC的拦截器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HandlerInterceptor%E5%92%8CHandlerInterceptorAdapter%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">HandlerInterceptor和HandlerInterceptorAdapter的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E6%9C%BA%E4%B8%8Bredis%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E5%AD%98%E5%A4%9A%E5%B0%91%E4%B8%AAkey%EF%BC%9F"><span class="toc-text">单机下redis最多可以存多少个key？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%AE%9E%E4%BE%8B%E6%94%AF%E6%8C%81%E7%9A%84%E5%8D%95%E4%B8%AAKey%E5%92%8CValue%E6%95%B0%E6%8D%AE%E5%A4%A7%E5%B0%8F%E6%98%AF%E5%90%A6%E6%9C%89%E9%99%90%E5%88%B6%EF%BC%9F"><span class="toc-text">Redis实例支持的单个Key和Value数据大小是否有限制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVCC%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-text">MVCC机制原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVCC%E6%98%AF%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%90%97%EF%BC%9F"><span class="toc-text">MVCC是乐观锁的实现吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E4%B8%ADset%E9%9B%86%E5%90%88%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">java中set集合的遍历方式有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E4%B8%ADTreeSet%E7%9A%84%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99"><span class="toc-text">java中TreeSet的排序规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E5%BC%80%E5%8F%91%E6%B3%A8%E9%87%8A%E5%BA%94%E8%AF%A5%E5%86%99%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%EF%BC%9F%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%AF%B9%E5%BA%94%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E4%B8%8A%E9%83%BD%E9%9C%80%E8%A6%81%E5%86%99%E6%B3%A8%E9%87%8A%E5%90%97%EF%BC%9F"><span class="toc-text">java开发注释应该写在哪些地方？接口方法和接口对应的实现方法上都需要写注释吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E5%BC%80%E5%8F%91%E4%B8%AD%EF%BC%8C%E9%81%87%E5%88%B0%E9%99%8C%E7%94%9F%E7%9A%84%E7%B1%BB%E9%9C%80%E8%A6%81%E8%B0%83%E7%94%A8%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AF%B9%E6%96%B9%E6%B3%95%E7%9A%84%E5%8A%9F%E8%83%BD%E4%B8%8D%E7%86%9F%E6%82%89%EF%BC%8C%E8%AF%A5%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E7%A1%AE%E5%AE%9A%E8%B0%83%E7%94%A8%E5%93%AA%E4%B8%AA%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E8%BE%BE%E5%88%B0%E9%A2%84%E6%9C%9F%E7%9A%84%E6%95%88%E6%9E%9C%E5%91%A2%EF%BC%9F"><span class="toc-text">java开发中，遇到陌生的类需要调用类中的方法，但是对方法的功能不熟悉，该如何快速确定调用哪个方法可以达到预期的效果呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E4%B8%AD%EF%BC%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">java中，基本数据类型和引用数据类型的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rocket%E4%B8%AD%EF%BC%8CBroker%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">Rocket中，Broker是什么？有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">享元模式和常量池的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="toc-text">享元模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-text">常量池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">两者的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B"><span class="toc-text">举例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK%EF%BC%8CJRE%EF%BC%8CJVM%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="toc-text">JDK，JRE，JVM之间的区别和联系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sql%E4%B8%AD%EF%BC%8C%E9%80%9A%E8%BF%87%E4%B8%AD%E9%97%B4%E8%A1%A8%E5%85%B3%E8%81%94%E5%92%8C%E9%80%9A%E8%BF%87%E5%A4%96%E9%94%AE%E5%85%B3%E8%81%94%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">sql中，通过中间表关联和通过外键关联有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E8%AE%BE%E8%AE%A1%E4%B8%AD%EF%BC%8C%E5%BD%93%E5%87%BA%E7%8E%B0%E5%A4%9A%E5%AF%B9%E5%A4%9A%E7%9A%84%E5%85%B3%E7%B3%BB%E6%97%B6%EF%BC%8C%E6%98%AF%E7%94%A8%E4%B8%AD%E9%97%B4%E8%A1%A8%E8%BF%9B%E8%A1%8C%E5%85%B3%E8%81%94%E8%BF%98%E6%98%AF%E9%80%9A%E8%BF%87%E5%A4%96%E9%94%AE%E8%BF%9B%E8%A1%8C%E5%85%B3%E8%81%94%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">数据库表设计中，当出现多对多的关系时，是用中间表进行关联还是通过外键进行关联，为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%A0%87%E8%AE%B0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E9%80%82%E7%94%A8%E4%BA%8E%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%EF%BC%8C%E4%BE%8B%E5%A6%82%EF%BC%9A-TODO"><span class="toc-text">java开发中常用标记有哪些？适用于什么场景，例如：@TODO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E4%B8%AD%EF%BC%8C%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%B8%8A%E9%99%90%E5%92%8C%E4%B8%8B%E9%99%90%E6%98%AF%E6%8C%87%E7%9A%84%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">java中，泛型的上限和下限是指的什么？有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ%E5%92%8CRocketMQ%E7%9A%84%E5%BC%82%E5%90%8C%E7%82%B9%EF%BC%9F"><span class="toc-text">RabbitMQ和RocketMQ的异同点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%EF%BC%8C%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E7%BB%99%E5%87%BA%E7%A4%BA%E4%BE%8B"><span class="toc-text">java，定时任务的解决方案有哪些？给出示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E5%BC%80%E5%8F%91%E7%9A%84%E5%9C%A8%E7%BA%BF%E8%AF%BE%E5%A0%82%E7%B3%BB%E7%BB%9F%E4%B8%AD%EF%BC%8C%E6%80%8E%E6%A0%B7%E8%AE%BE%E7%BD%AE%E8%AF%BE%E7%A8%8B%E7%BD%AE%E9%A1%B6%E5%8A%9F%E8%83%BD"><span class="toc-text">java开发的在线课堂系统中，怎样设置课程置顶功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E9%A1%B9%E7%9B%AE%E4%B8%AD%EF%BC%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86%E5%8E%9F%E5%88%99%EF%BC%9F"><span class="toc-text">java项目中，微服务拆分原则？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E5%BC%80%E5%8F%91%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="toc-text">java开发微服务项目中，什么时候用事务消息？什么时候用分布式事务？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E4%BF%9D%E9%9A%9CES%E5%92%8CMySQL%E4%B9%8B%E9%97%B4%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%94%A8%E4%BB%80%E4%B9%88%E6%8A%80%E6%9C%AF%E6%9D%A5%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-text">要保障ES和MySQL之间数据的一致性，可以用什么技术来实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%95%86%E5%93%81%E7%AD%89%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%9E%B6%E5%A4%84%E7%90%86%E4%B8%AD%EF%BC%8C%E6%88%91%E4%BB%AC%E6%98%AF%E9%80%9A%E8%BF%87RocketMQ%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E6%9D%A5%E4%BF%9D%E8%AF%81MySQL%E5%92%8CES%E4%B9%8B%E9%97%B4%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84"><span class="toc-text">在商品等的上下架处理中，我们是通过RocketMQ的事务消息来保证MySQL和ES之间数据的一致性的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RocketMQ%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">RocketMQ的事务消息的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spu%E5%92%8Csku%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">spu和sku的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">学成在线相关面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%A6%E7%BB%86%E8%AF%B4%E8%AF%B4%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%90%A7"><span class="toc-text">1 详细说说你的项目吧</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Git%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">2 Git相关面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-Git%E4%BB%A3%E7%A0%81%E5%86%B2%E7%AA%81%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-text">2.1 Git代码冲突怎么处理？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-%E4%BD%A0%E6%98%AF%E5%9C%A8%E9%82%A3%E4%B8%AA%E5%88%86%E6%94%AF%E5%BC%80%E5%8F%91%EF%BC%9F"><span class="toc-text">2.2 你是在那个分支开发？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81maven%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">3、maven相关面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-maven%E4%BE%9D%E8%B5%96%E7%89%88%E6%9C%AC%E5%86%B2%E7%AA%81%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-text">3.1 maven依赖版本冲突怎么处理？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-maven%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">3.2 maven常用命令</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-MySQL%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">4 MySQL相关面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-MySQL%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%8F%8A%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">4.1 MySQL常见的存储引擎及区别？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-MySQL%E5%BB%BA%E8%A1%A8%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">4.2 MySQL建表时需要注意什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-%E6%A0%91%E5%BD%A2%E8%A1%A8%E7%9A%84%E6%A0%87%E8%AE%B0%E5%AD%97%E6%AE%B5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">4.3 树形表的标记字段是什么？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-SpringBoot%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91%E7%9A%84%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">5 SpringBoot接口开发的常用注解有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">5 项目的开发流程是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Mybatis%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">6 Mybatis相关面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-Mybatis%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">6.1 Mybatis分页插件的原理？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-MyBatis%E7%9A%84ResultType%E5%92%8CResultMap%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">6.2 MyBatis的ResultType和ResultMap的区别？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3-%E5%92%8C-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">6.3 #{} 和 ${} 有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%EF%BC%9F"><span class="toc-text">7 系统如何处理异常？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E5%90%88%E6%B3%95%E6%80%A7%E6%A0%A1%E9%AA%8C%E5%A6%82%E4%BD%95%E5%81%9A%EF%BC%9F"><span class="toc-text">8 请求参数的合法性校验如何做？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BA%8B%E5%8A%A1%E4%BC%9A%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="toc-text">9 什么情况下事务会失效？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E4%BB%80%E4%B9%88%E6%98%AFminio%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8minio%EF%BC%9F"><span class="toc-text">10 什么是minio，为什么使用minio？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">11 文件上传相关面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#11-1-%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-text">11.1 断点续传是怎么实现的？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-2-%E5%88%86%E5%9D%97%E6%96%87%E4%BB%B6%E6%B8%85%E7%90%86%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">11.2 分块文件清理问题？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-xxl-job%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">12 xxl-job相关面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#12-1-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9Fxxl-job%E6%98%AF%E4%BB%80%E4%B9%88%E5%B7%A5%E4%BD%9C%EF%BC%9F"><span class="toc-text">12.1 的工作原理是什么？xxl-job是什么工作？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BB%BB%E5%8A%A1%E4%B8%8D%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C%EF%BC%9F"><span class="toc-text">12.2 如何保证任务不重复执行？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-%E4%BB%BB%E5%8A%A1%E5%B9%82%E7%AD%89%E6%80%A7%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%EF%BC%9F"><span class="toc-text">12.3 任务幂等性如何保证？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%98%AF%E6%80%8E%E4%B9%88%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%8C%E7%BB%99%E5%87%BA%E4%BB%A3%E7%A0%81"><span class="toc-text">线程池是怎么创建线程的，给出代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#quartz%E5%92%8Cxxl-job%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%9C%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%94%A8%E5%93%AA%E4%B8%AA%E5%A5%BD%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">quartz和xxl-job的区别？在分布式环境中用哪个好？为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AE%9E%E6%88%98%EF%BC%88RH%EF%BC%89"><span class="toc-text">面试题实战（RH）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringBoot%E9%A1%B9%E7%9B%AE%E4%B8%AD%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%EF%BC%9F%E7%BB%99%E5%87%BA%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81"><span class="toc-text">SpringBoot项目中，单元测试是怎么做的？给出具体代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E4%B8%AD%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">java中多态的实现方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E4%B8%AD%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%9C%A8%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%87%BA%E9%94%99%E4%BC%9A%E6%80%8E%E6%A0%B7%EF%BC%9F"><span class="toc-text">java中，线程在运行过程中出错会怎样？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mybatis%E5%92%8Cmybatisplus%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">mybatis和mybatisplus的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E4%B8%AD%EF%BC%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%B2%E8%A1%8C%E6%89%A7%E8%A1%8C%EF%BC%8C%E5%85%B6%E4%BB%96%E7%BA%BF%E7%A8%8B%E9%9C%80%E8%A6%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-text">java中，多线程串行执行，其他线程需要线程池的数据如何解决？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E4%B8%AD%EF%BC%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%94%9F%E6%88%90%E5%94%AF%E4%B8%80%E8%AE%A2%E5%8D%95%E5%8F%B7%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E8%AE%A2%E5%8D%95%E5%8F%B7%E4%B8%8D%E9%87%8D%E5%A4%8D%EF%BC%9F"><span class="toc-text">java中，多线程生成唯一订单号，如何保证订单号不重复？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E4%B8%AD%EF%BC%8Cbootstrap%E5%92%8Capplication%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">java中，bootstrap和application配置文件的区别？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RocketMQMessageListener-%EF%BC%8C-RocketMQTransactionListener-%EF%BC%8C%E8%BF%99%E4%B8%A4%E4%B8%AA%E6%B3%A8%E8%A7%A3%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E9%80%82%E7%94%A8%E4%BA%8E%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%EF%BC%9F"><span class="toc-text">@RocketMQMessageListener()，@RocketMQTransactionListener()，这两个注解有什么区别？适用于哪些地方？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#springboot%E9%A1%B9%E7%9B%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%86%E7%A0%81%E5%A6%82%E4%BD%95%E5%8A%A0%E5%AF%86"><span class="toc-text">springboot项目数据库密码如何加密</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">HTTP和HTTPS的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JSR303%E6%A0%A1%E9%AA%8C%E4%B8%AD%EF%BC%8C-NotNull%E5%92%8C-NotBlank%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">JSR303校验中，@NotNull和@NotBlank有什么区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E6%AF%94%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9B%B4%E6%98%93%E6%89%A9%E5%B1%95%EF%BC%9F"><span class="toc-text">为什么非关系型数据库比关系型数据库更易扩展？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8websocket%E4%B8%AD%E6%B3%A8%E5%85%A5service%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-text">如何在websocket中注入service的对象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-text">线程池如何使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#knife4j%E9%9B%86%E6%88%90%E7%A4%BA%E8%8C%83%E7%9B%B8%E5%85%B3%E4%BE%8B%E5%AD%90"><span class="toc-text">knife4j集成示范相关例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-text">ConcurrentHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3"><span class="toc-text">微服务架构怎么理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%EF%BC%8C%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6"><span class="toc-text">使用什么技术实现微服务架构的，常用组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">注册中心的工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nacos%E5%A4%9A%E9%95%BF%E6%97%B6%E9%97%B4%E7%BB%AD%E7%BA%A6%E4%B8%80%E6%AC%A1-5s"><span class="toc-text">nacos多长时间续约一次 5s</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#openFeign%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%93%AA%E9%87%8C%E4%BD%BF%E7%94%A8%E5%88%B0"><span class="toc-text">openFeign在项目中哪里使用到</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%97%AA%E6%96%AD%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%8C"><span class="toc-text">网络闪断怎么解决，</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%AF%95%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%8C%E5%B9%82%E7%AD%89%E6%80%A7%E6%A0%A1%E9%AA%8C-%E6%80%8E%E4%B9%88%E6%A0%A1%E9%AA%8C"><span class="toc-text">重试有什么问题，幂等性校验 怎么校验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E4%BB%AC%E9%A1%B9%E7%9B%AE%E6%94%AF%E6%8C%81%E5%A4%9A%E5%B0%91%E5%B9%B6%E5%8F%91"><span class="toc-text">你们项目支持多少并发?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%9C%89%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E6%B5%81%E7%A8%8B%EF%BC%9F-codearts%EF%BC%8C"><span class="toc-text">项目开发有没有什么流程？ codearts，</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%8F%91%E7%8E%B0%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F-bug%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%88%E6%98%AFcodearts%E7%9A%84%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%EF%BC%89"><span class="toc-text">测试发现问题怎么办？ bug管理系统（是codearts的一个模块）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashmap%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8D%E4%BD%BF%E7%94%A8%E8%87%AA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9F"><span class="toc-text">hashmap为什么要使用红黑树不使用自平衡二叉树？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%89%B9%E6%80%A7"><span class="toc-text">红黑树特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CRUD%E4%B8%AD%EF%BC%8C%E5%85%B7%E4%BD%93%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E9%9C%80%E8%A6%81%E5%81%9A%E5%B9%82%E7%AD%89%E6%80%A7%E6%A0%A1%E9%AA%8C%EF%BC%9F"><span class="toc-text">CRUD中，具体哪些操作需要做幂等性校验？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spring%E4%B8%AD%EF%BC%8C%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-text">spring中，用了哪些设计模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#factorybean%E5%92%8Cbeanfactory%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">factorybean和beanfactory的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%80%81%E6%9D%9CSpring%E6%96%87%E6%A1%A3%EF%BC%88%E9%87%8D%E7%82%B9%E5%85%B3%E6%B3%A8%E5%88%87%E9%9D%A2%EF%BC%89"><span class="toc-text">老杜Spring文档（重点关注切面）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AFservlet"><span class="toc-text">解释一下什么是servlet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A2%ABoverride"><span class="toc-text">构造器是否可被override</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#throw%E5%92%8Cthrows%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">throw和throws的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E6%AC%A1%E4%BC%9A%E8%AF%9D%EF%BC%9F"><span class="toc-text">软件开发中，什么是一次会话？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRefresh-token"><span class="toc-text">什么是Refresh token?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E4%B8%AD%EF%BC%8C%E7%94%A8%E6%88%B7%E6%9C%8D%E5%8A%A1%E5%92%8C%E6%8E%88%E6%9D%83%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%85%B3%E7%B3%BB%E4%BB%A5%E5%8F%8A%E5%90%84%E8%87%AA%E7%9A%84%E8%81%8C%E8%B4%A3"><span class="toc-text">在微服务项目中，用户服务和授权服务的关系以及各自的职责?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8JS%E5%AE%9E%E7%8E%B0%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E5%8E%BB%E9%87%8D%EF%BC%9F"><span class="toc-text">用JS实现对数组的去重？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F"><span class="toc-text">在高并发情况下，如何保证系统的高可用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%ADjoin-%E7%9A%84inner-join-left-join-right-join-%E5%8C%BA%E5%88%AB"><span class="toc-text">Mysql数据库中join 的inner join,left join,right join 区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MYSQL%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-MYISAM-%E5%92%8CINNODB-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%90%84%E8%87%AA%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">MYSQL的两种存储引擎 MYISAM 和INNODB 的区别，各自的适用场景?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E4%B8%AD%EF%BC%8CString%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">java中，String类的常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFES%E8%84%91%E8%A3%82%E9%97%AE%E9%A2%98%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-text">什么是ES脑裂问题？如何解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E9%9B%86%E7%BE%A4%E6%9C%89%E8%84%91%E8%A3%82%E9%97%AE%E9%A2%98%E5%90%97%EF%BC%9F"><span class="toc-text">Redis集群有脑裂问题吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#springboot%E6%95%B4%E5%90%88ES%E7%9A%84%E6%AD%A5%E9%AA%A4%EF%BC%9F"><span class="toc-text">springboot整合ES的步骤？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#nginx%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-text">nginx正向代理和反向代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86"><span class="toc-text">TCP通信原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E5%B1%82TCP-IP%E5%8D%8F%E8%AE%AE"><span class="toc-text">4层TCP&#x2F;IP协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">TCP和UDP的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#http%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">http通信原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#http%E5%92%8Chttps%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">http和https的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E4%B8%AD%EF%BC%8CList%E8%BD%ACArray%E8%B0%83%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%EF%BC%9FArray%E8%BD%ACList%E8%B0%83%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">java中，List转Array调用什么方法？Array转List调用什么方法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E4%B8%AD%EF%BC%8C%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">java中，过滤器和拦截器的作用与区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#controller%E4%B8%AD%EF%BC%8C%E7%94%A8%E4%BA%8E%E6%8E%A5%E6%94%B6%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E6%B3%A8%E8%A7%A3%EF%BC%9F"><span class="toc-text">controller中，用于接收请求参数的注解？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="toc-text">java性能优化怎么做？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/breeze/1d13ce0d.html" title="WYDG-产品目录列表-20200506"><img src="/img/photo-1653549892896-dde02867edee.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="WYDG-产品目录列表-20200506"></a><div class="content"><a class="title" href="/breeze/1d13ce0d.html" title="WYDG-产品目录列表-20200506">WYDG-产品目录列表-20200506</a><time datetime="2025-04-13T05:43:05.000Z" title="发表于 2025-04-13 13:43:05">2025-04-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/breeze/6f268337.html" title="雨雀文件下载"><img src="/img/premium_photo-1695185954894-e9382c6f4da8.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="雨雀文件下载"></a><div class="content"><a class="title" href="/breeze/6f268337.html" title="雨雀文件下载">雨雀文件下载</a><time datetime="2024-05-22T12:25:08.000Z" title="发表于 2024-05-22 20:25:08">2024-05-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/breeze/7832219d.html" title="十万字面试总结"><img src="/img/photo-1692708632140-ee01624d558d.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="十万字面试总结"></a><div class="content"><a class="title" href="/breeze/7832219d.html" title="十万字面试总结">十万字面试总结</a><time datetime="2024-02-29T02:50:00.000Z" title="发表于 2024-02-29 10:50:00">2024-02-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/breeze/7ae0ca37.html" title="Redis_30道经典面试题"><img src="/img/photo-1653549892896-dde02867edee.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Redis_30道经典面试题"></a><div class="content"><a class="title" href="/breeze/7ae0ca37.html" title="Redis_30道经典面试题">Redis_30道经典面试题</a><time datetime="2024-02-29T02:45:00.000Z" title="发表于 2024-02-29 10:45:00">2024-02-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/breeze/2a548e97.html" title="面试实战"><img src="/img/photo-1653549892896-dde02867edee.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="面试实战"></a><div class="content"><a class="title" href="/breeze/2a548e97.html" title="面试实战">面试实战</a><time datetime="2024-02-29T02:43:59.000Z" title="发表于 2024-02-29 10:43:59">2024-02-29</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/img/photo-1645943020355-305df166473d.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 <i id="heartbeat" class="fa fas fa-heartbeat"></i> 清风</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></head></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script src="/js/timing.js"></script><script id="canvas_nest" defer color="255,0,255" opacity="0.7" zindex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!0,document.body.addEventListener("input",POWERMODE)</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="天枢,天璇,天玑,天权,玉衡,开阳,瑶光" data-fontsize="15px" data-random="true" async></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>