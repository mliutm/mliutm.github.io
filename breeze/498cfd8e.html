<!DOCTYPE html><html class="hide-aside" lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>并发编程 | 清风</title><meta name="author" content="清风"><meta name="copyright" content="清风"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="技术提升-并发编程课程内容 线程加强 线程池使用和原理 ThreadLocal原理 锁的认识 JUC并发库了解  一.线程的理解1.线程和进程1.1.什么是进程进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。 ​    Java -ja"><meta property="og:type" content="article"><meta property="og:title" content="并发编程"><meta property="og:url" content="https://mliutm.github.io/breeze/498cfd8e.html"><meta property="og:site_name" content="清风"><meta property="og:description" content="技术提升-并发编程课程内容 线程加强 线程池使用和原理 ThreadLocal原理 锁的认识 JUC并发库了解  一.线程的理解1.线程和进程1.1.什么是进程进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。 ​    Java -ja"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://mliutm.github.io/img/photo-1688475747590-d0db5e2412cb.jpg"><meta property="article:published_time" content="2024-01-14T07:29:20.000Z"><meta property="article:modified_time" content="2024-01-14T14:43:35.043Z"><meta property="article:author" content="清风"><meta property="article:tag" content="java"><meta property="article:tag" content="并发"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://mliutm.github.io/img/photo-1688475747590-d0db5e2412cb.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://mliutm.github.io/breeze/498cfd8e.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,top_n_per_article:1,unescape:!1,languages:{hits_empty:"找不到您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!1,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"并发编程",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-01-14 22:43:35"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,a){0!==a&&(a=864e5*a,t={value:t,expiry:(new Date).getTime()+a},localStorage.setItem(e,JSON.stringify(t)))},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!((new Date).getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=o=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.getCSS=(o,n=!1)=>new Promise((t,e)=>{const a=document.createElement("link");a.rel="stylesheet",a.href=o,n&&(a.id=n),a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">169</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">82</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/img/photo-1688475747590-d0db5e2412cb.jpg)"><nav id="nav"><span id="blog-info"><a href="/" title="清风"><span class="site-name">清风</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">并发编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-14T07:29:20.000Z" title="发表于 2024-01-14 15:29:20">2024-01-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-14T14:43:35.043Z" title="更新于 2024-01-14 22:43:35">2024-01-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E8%83%BD%E6%8F%90%E5%8D%87/">技能提升</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>45分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="并发编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="技术提升-并发编程"><a href="#技术提升-并发编程" class="headerlink" title="技术提升-并发编程"></a>技术提升-并发编程</h1><h3 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h3><ul><li>线程加强</li><li>线程池使用和原理</li><li>ThreadLocal原理</li><li>锁的认识</li><li>JUC并发库了解</li></ul><h2 id="一-线程的理解"><a href="#一-线程的理解" class="headerlink" title="一.线程的理解"></a>一.线程的理解</h2><h3 id="1-线程和进程"><a href="#1-线程和进程" class="headerlink" title="1.线程和进程"></a>1.线程和进程</h3><h4 id="1-1-什么是进程"><a href="#1-1-什么是进程" class="headerlink" title="1.1.什么是进程"></a>1.1.什么是进程</h4><p><strong>进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例</strong>。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。</p><p>​ Java -jar 在jvm运行一个程序的实例。 指定堆栈内存。。。</p><h4 id="1-2-什么是线程"><a href="#1-2-什么是线程" class="headerlink" title="1.2.什么是线程"></a>1.2.什么是线程</h4><p>​ <strong>线程是程序执行时的最小单位</strong>，它是进程的一个执行流，是CPU调度和分派的基本单位，<strong>一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的栈和局部变量</strong>。线程由CPU独立调度执行，在多CPU环境下就允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理。</p><p><code>进程是资源分配的最小单位，线程是程序（代码块）执行的最小单位。</code></p><p>在java通过java xxx.class就启动一个进程！ main，test，springboot，tomcat</p><h3 id="2-线程三种方式-–new-Thread子类-，new-Thread（runale或者callalbe的任务-，最终启动线程都是使用start方法，最终线程调度的都是run"><a href="#2-线程三种方式-–new-Thread子类-，new-Thread（runale或者callalbe的任务-，最终启动线程都是使用start方法，最终线程调度的都是run" class="headerlink" title="2.线程三种方式  –new Thread子类 ，new Thread（runale或者callalbe的任务) ，最终启动线程都是使用start方法，最终线程调度的都是run"></a>2.线程三种方式 –new Thread子类 ，new Thread（runale或者callalbe的任务) ，最终启动线程都是使用start方法，最终线程调度的都是run</h3><ul><li>继承Thread类 ， Thread 实现了Runnable</li><li>实现Runnable接口</li><li>Callable+Future实现有返回结果的多线程</li><li>使用ExecutorService 线程池</li></ul><p><strong>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。</strong></p><h4 id="2-1-实现-Runnable-接口"><a href="#2-1-实现-Runnable-接口" class="headerlink" title="2.1.实现 Runnable 接口"></a>2.1.实现 Runnable 接口</h4><p>需要实现 run() 方法。通过 Thread 调用 start() 方法来启动线程。</p><p><img src="/breeze/498cfd8e/1635555201517.png" alt="1635555201517"></p><h4 id="2-2-实现-Callable-接口"><a href="#2-2-实现-Callable-接口" class="headerlink" title="2.2.实现 Callable 接口"></a>2.2.实现 Callable 接口</h4><p>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。</p><p><img src="/breeze/498cfd8e/1635555378667.png" alt="1635555378667"></p><h4 id="2-3-继承-Thread-类"><a href="#2-3-继承-Thread-类" class="headerlink" title="2.3.继承 Thread 类"></a>2.3.继承 Thread 类</h4><p>同样也是需要实现 run() 方法，并且最后也是调用 start() 方法来启动线程</p><p><img src="/breeze/498cfd8e/1635555419914.png" alt="1635555419914"></p><h4 id="2-4-实现接口-VS-继承-Thread"><a href="#2-4-实现接口-VS-继承-Thread" class="headerlink" title="2.4.实现接口 VS 继承 Thread"></a>2.4.实现接口 VS 继承 Thread</h4><p>实现接口会更好一些，因为：Java 不支持多继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；类可能只要求可执行即可，继承整个 Thread 类开销会过大。</p><p><strong>Thread和Runable的区别和联系</strong></p><ul><li>Thread类实现了Runable接口。都需要重写里面Run方法。</li><li>不同：实现Runnable的类更具有健壮性，避免了<strong>单继承</strong>的局限。</li><li>Runnable更容易实现资源共享，能多个线程同时处理一个资源</li></ul><p>​ Java实现线程的方式有两种一种newThread子类和new thread，但是具体写的方式有<strong>常见</strong>如下四种</p><p>​ newThread子类</p><p>​ new thread（runable）</p><p>​ new thread（callable）</p><p>​ 线程池，就是提前new直接获取使用</p><h3 id="3-线程生命周期"><a href="#3-线程生命周期" class="headerlink" title="3.线程生命周期"></a>3.线程生命周期</h3><h4 id="3-1-线程生命周期图"><a href="#3-1-线程生命周期图" class="headerlink" title="3.1.线程生命周期图"></a>3.1.线程生命周期图</h4><p>特别注意：当调用start后，线程拥有可执行的权限，但是不一定被执行，只有抢到CPU资源才是running运行状态</p><p><img src="/breeze/498cfd8e/1635555532712.png" alt="1635555532712"></p><h4 id="3-2-线程的方法（了解）"><a href="#3-2-线程的方法（了解）" class="headerlink" title="3.2.线程的方法（了解）"></a>3.2.线程的方法（了解）</h4><ul><li><p>yield方法：使当前线程从执行状态变为就绪状态。 放弃机会</p></li><li><p>sleep方法：强制当前正在执行的线程休眠，当睡眠时间到期，则返回到可运行状态。不会放弃锁资源</p></li><li><p>join方法：通常用于在main()主线程内，等待其它线程完成再结束main()主线程,不会放弃锁资源，线程会等待</p></li><li><p>deamon：守护线程（deamon）是程序运行时在后台提供服务的线程，并不属于程序中不可或缺的部分。当所有非后台线程结束时，程序也就终止，同时会杀死所有后台线程。main() 属于非后台线程。使用 setDaemon() 方法将一个线程设置为后台线程。</p></li></ul><h4 id="3-3-线程的状态"><a href="#3-3-线程的状态" class="headerlink" title="3.3.线程的状态"></a>3.3.线程的状态</h4><p><strong>新建状态</strong></p><p>使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。</p><p><strong>就绪状态</strong></p><p>当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。</p><p><strong>运行状态</strong></p><p>如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</p><p><strong>阻塞状态</strong></p><p>如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：</p><ul><li><p>等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。</p></li><li><p>同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。</p></li><li><p>其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I&#x2F;O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I&#x2F;O 处理完毕，线程重新转入就绪状态。</p></li></ul><p><strong>死亡状态</strong></p><p>一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。</p><h4 id="3-4-线程通信"><a href="#3-4-线程通信" class="headerlink" title="3.4.线程通信"></a>3.4.线程通信</h4><p>wait,notify,notifyAll ,它们都属于 Object 的一部分，而不属于 Thread。而 sleep() 是 Thread 的静态方法；wait() 会在等待时将线程挂起，而不是忙等待，并且只有在 notify() 或者 notifyAll() 到达时才唤醒。s<strong>leep() 和 yield() 并没有释放锁，但是 wait() 会释放锁。实际上，只有在同步控制方法或同步控制块里才能调用 wait() 、notify() 和 notifyAll()。</strong></p><p><strong>notify()</strong></p><p>该方法用来通知那些可能等待该对象的对象锁的其他线程。如果有多个线程等待，则线程规划器任意挑选出其中一个 wait()状态的线程来发出通知，并使它等待获取该对象的对象锁。</p><p><strong>notifyAll()</strong></p><p>使所有原来在该对象上 wait 的线程统统退出 wait 的状态（即全部被唤醒，不再等待 notify 或 notifyAll，但由于此时还没有获取到该对象锁，因此还</p><p>不能继续往下执行），变成等待获取该对象上的锁。</p><h2 id="二-线程池使用和原理"><a href="#二-线程池使用和原理" class="headerlink" title="二.线程池使用和原理"></a>二.线程池使用和原理</h2><h3 id="1-线程池介绍"><a href="#1-线程池介绍" class="headerlink" title="1.线程池介绍"></a>1.线程池介绍</h3><h4 id="1-1-为什么用线程池"><a href="#1-1-为什么用线程池" class="headerlink" title="1.1.为什么用线程池"></a>1.1.为什么用线程池</h4><p>线程池可以看做是管理了N个线程的池子，和连接池类似。线程池的作用主要有：</p><ul><li><p>控制并发数量：线程并发数量过多，抢占系统资源从而导致阻塞，线程池可以限制线程的数量，防止服务器过载。</p></li><li><p>线程的复用：创建&#x2F;销毁线程伴随着系统开销，过于频繁的创建&#x2F;销毁线程，会很大程度上影响处理效率和速度</p></li><li><p>管理线程的生命周期：对线程进行一些简单的管理，创建，销毁等</p></li></ul><h4 id="1-2-认识线程池"><a href="#1-2-认识线程池" class="headerlink" title="1.2.认识线程池"></a>1.2.认识线程池</h4><p>创建线程和销毁线程的代价是非常高的，而使用线程池就可以很好的提高性能。线程池在系统启动时创建大量空闲的线程。程序将一个Runable对象或Callable对象传给线程池，线程池就会启动一个线程来执行他们的run()方法或call()方法，当run()方法或call()方法执行结束后，线程并不会死亡，而是再次返回线程池中成为空闲状态，等待执行下一个run()方法或call()方法。</p><p>在Java 1.5之后就提供了线程池 ThreadPoolExecutor，它的继承体系如下：</p><p><img src="/breeze/498cfd8e/1635556068040.png" alt="1635556068040"></p><p>核心类认识：</p><ul><li><p>ThreadPoolExecutor ：线程池</p></li><li><p>Executor: 线程池顶层接口，提供了execute执行线程任务的方法</p></li><li><p>Execuors: 线程池的工具类，通常使用它来创建线程池</p></li><li><p>ScheduledExecutorService ： 带定时任务的线程池(Eureka中30s&#x2F;次，服务续约，拉取注册表使用的就是该线程池)</p></li></ul><h3 id="2-线程池原理"><a href="#2-线程池原理" class="headerlink" title="2.线程池原理"></a>2.线程池原理</h3><h4 id="2-1-线程池七大参数"><a href="#2-1-线程池七大参数" class="headerlink" title="2.1.线程池七大参数"></a>2.1.线程池七大参数</h4><p>线程池源码 ThreadPoolExecutor 构造器：</p><p><img src="/breeze/498cfd8e/1635556202649.png" alt="1635556202649"></p><p>PS: 线程池7个参数的构造器非常重要[<strong>重要</strong>]</p><ul><li><p>CorePoolSize: 核心线程数，不会被销毁</p></li><li><p>WorkQueue:是一个BlockingQueue阻塞队列，超过核心线程数的任务会进入队列排队</p><ol><li>SynchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务；</li><li>LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；</li><li>ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小</li></ol></li><li><p>MaximumPoolSize : 最大线程数 (核心+非核心) ，非核心线程数用完之后达到空闲时间会被销毁</p></li><li><p>Handler: 拒绝策略，任务超过 最大线程数+队列排队数 ，多出来的任务该如何处理取决于Handler</p><ol><li>AbortPolicy丢弃任务并抛出RejectedExecutionException异常；</li><li>DiscardPolicy丢弃任务，但是不抛出异常；</li><li>DiscardOldestPolicy丢弃队列最前面的任务，然后重新尝试执行任务；</li><li>CallerRunsPolicy由调用线程处理该任务</li></ol><p>可以定义和使用其他种类的RejectedExecutionHandler类来定义拒绝策略。</p></li><li><p>KeepAliveTime: 非核心线程的最大空闲时间，到了这个空闲时间没被使用，非核心线程销毁</p></li><li><p>Unit: 空闲时间单位</p></li><li><p>ThreadFactory：使用ThreadFactory创建新线程。 推荐使用Executors.defaultThreadFactory</p></li></ul><h4 id="2-2-线程池执行流程"><a href="#2-2-线程池执行流程" class="headerlink" title="2.2.线程池执行流程"></a>2.2.线程池执行流程</h4><p>corePoolSize，maximumPoolSize，workQueue之间关系。</p><ol><li><p>当线程池中线程数小于corePoolSize时，新提交任务将创建一个新线程(使用核心)执行任务，即使此时线程池中存在空闲线程。</p></li><li><p>当线程池中线程数达到corePoolSize时(核心用完)，新提交任务将被放入workQueue中，等待线程池中任务调度执行 。</p></li><li><p><strong>当workQueue已满，且maximumPoolSize &gt; corePoolSize时，新提交任务会创建新线程(非核心)执行任务。</strong></p></li><li><p><strong>当workQueue已满，且提交任务数超过maximumPoolSize(线程用完，队列已满)，任务由RejectedExecutionHandler处理。</strong></p></li><li><p>当线程池中线程数超过corePoolSize，且超过这部分的空闲时间达到keepAliveTime时，回收这些线程。</p></li><li><p>当设置allowCoreThreadTimeOut(true)时，线程池中corePoolSize范围内的线程空闲时间达到keepAliveTime也将回收。</p></li></ol><p><strong>线程池执行流程 ：</strong> 核心线程 &#x3D;&gt; 等待队列 &#x3D;&gt; 非核心线程 &#x3D;&gt; 拒绝策略</p><h3 id="3-线程池的使用"><a href="#3-线程池的使用" class="headerlink" title="3.线程池的使用"></a>3.线程池的使用</h3><h4 id="3-1-常见的四种线程池"><a href="#3-1-常见的四种线程池" class="headerlink" title="3.1.常见的四种线程池"></a>3.1.常见的四种线程池</h4><p>Executors是一个<strong>创建线程池的工具类</strong>，可以方便快速的创建很多种类的线程池。配置一个线程池是比较复杂的，尤其对于线程池的原理不清楚的情况下，很有可能配置的线程池不是最优的，因此，在Executors类里定义了一些静态方法，生成一些常用的线程池。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建具有缓存功能的线程池，数目无限制</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool1</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"><span class="comment">//创建具有固定数目的、可重用的线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool2</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">6</span>);</span><br><span class="line"><span class="comment">//创建只有一个线程的线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool3</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建具有指定线程数的线程池，可以在指定延迟后执行线程任务</span></span><br><span class="line">ScheduledExecutorService  pool4=Executors.newScheduledThreadPool(<span class="number">6</span>);</span><br><span class="line"><span class="comment">//创建具有一个线程的线程池，可在指定延迟后执行线程任务</span></span><br><span class="line">ScheduledExecutorService  pool5=Executors.newSingleThreadScheduledExecutor();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  Java 8 新增的两个方法，这两个方法可以充分利用多CPU并行的能力，</span></span><br><span class="line"><span class="comment"> *    这两个方法生成的work stealing池，相当于后台线程池，如果所有的前台线程死亡了</span></span><br><span class="line"><span class="comment"> *  work stealing线程池中的线程会自动死亡</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ExecutorService pool6=Executors.newWorkStealingPool(<span class="number">6</span>);</span><br><span class="line">ExecutorService pool7=Executors.newWorkStealingPool();</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>newSingleThreadExecutor：创建一个单线程的线程池。这个线程池中只有一个线程在工作，即相当于单线程串行执行所有任务；如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。任务的执行顺序按照任务的提交顺序执行。</p></li><li><p>newCachedThreadPool：创建一个缓存池大小可根据需要伸缩的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步执行的程序而言，这些线程池可提高程序性能。</p></li><li><p>newFixedThreadPool(int n)：创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程</p></li><li><p>ScheduledThreadPool:带定时任务的线程池</p></li></ul><h4 id="3-2-CachedThreadPool可缓存"><a href="#3-2-CachedThreadPool可缓存" class="headerlink" title="3.2.CachedThreadPool可缓存"></a>3.2.CachedThreadPool可缓存</h4><p>可缓存线程池-可以无限制创建</p><p><img src="/breeze/498cfd8e/1635557714010.png" alt="1635557714010"></p><p>根据源码可以看出：</p><ul><li><p>这种线程池内部没有核心线程，线程的数量是有限制的 最大是Integer最大值。</p></li><li><p>在创建任务时，若有空闲的线程时则复用空闲的线程(缓存线程)，若没有则新建线程。</p></li><li><p>没有工作的线程（闲置状态）在超过了60S还不做事，就会销毁。</p></li><li><p>适用：<strong>执行很多短期异步的小程序或者负载较轻的服务器。</strong></p></li></ul><p><strong>代码示例</strong></p><ul><li>第一步：调用Executor类的静态方法创建一个ExecutorService对象</li><li>第二步：创建Runnable实现类或Callable实现类的实例，作为线程执行任务</li><li>第三步：调用ExecutorService对象的submit()方法提交Runnable类或Callable类的实例</li><li>第四步：当不想提交任何任务时，调用ExecutorService对象的shutdown()方法来关闭线程池</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">cachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//带缓存的线程，线程复用，没有核心线程，线程的最大值是 Integer.MAX_VALUE</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">150</span> ; i++)&#123;</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">//始终只有一个线程在执行</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:线程执行...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-FixedThreadPool-定长线程池"><a href="#3-3-FixedThreadPool-定长线程池" class="headerlink" title="3.3.FixedThreadPool 定长线程池"></a>3.3.FixedThreadPool 定长线程池</h4><p><img src="/breeze/498cfd8e/1635557927896.png" alt="1635557927896"></p><p>根据源码可以看出：</p><ul><li><p>该线程池的最大线程数等于核心线程数，所以在默认情况下，该线程池的线程不会因为闲置状态超时而被销毁。</p></li><li><p>如果当前线程数小于核心线程数，并且也有闲置线程的时候提交了任务，这时也不会去复用之前的闲置线程，会创建新的线程去执行任务（必须达到最大核心数才会复用线程）。如果当前执行任务数大于了核心线程数，大于的部分就会进入队列等待。等着有闲置的线程来执行这个任务。</p></li><li><p>适用：<strong>执行长期的任务，性能好很多。</strong></p></li></ul><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fixedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">150</span> ; i++)&#123;</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">//有5个线程在执行</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:线程执行...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-SingleThreadPool-单线程池"><a href="#3-4-SingleThreadPool-单线程池" class="headerlink" title="3.4.SingleThreadPool 单线程池"></a>3.4.SingleThreadPool 单线程池</h4><p><img src="/breeze/498cfd8e/1635557987220.png" alt="1635557987220"></p><p>根据源码可以看出：</p><ul><li><p>有且仅有一个工作线程执行任务</p></li><li><p>所有任务按照指定顺序执行，即遵循队列的入队出队规则。</p></li><li><p>适用：<strong>一个任务一个任务执行的场景。 如同队列</strong></p></li></ul><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单线程的线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">singleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//单线程的线程池</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">//始终只有一个线程在执行</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:线程执行...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-5-ScheduledThreadPool"><a href="#3-5-ScheduledThreadPool" class="headerlink" title="3.5. ScheduledThreadPool"></a>3.5. ScheduledThreadPool</h4><p><img src="/breeze/498cfd8e/1635558039552.png" alt="1635558039552"></p><p>根据源码可以看出：</p><ul><li><p>DEFAULT_KEEPALIVE_MILLIS就是默认10L，这里就是10秒。这个线程池有点像是CachedThreadPool和FixedThreadPool 结合了一下。</p></li><li><p>不仅设置了核心线程数，最大线程数也是Integer.MAX_VALUE。</p></li><li><p>这个线程池是上述4个中唯一一个有延迟执行和周期执行任务的线程池。</p></li><li><p>适用：周期性执行任务的场景（定期的同步数据）,Eureka就使用了该线程池</p></li></ul><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">scheduledThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//带缓存的线程，线程复用，没有核心线程，线程的最大值是 Integer.MAX_VALUE</span></span><br><span class="line">    <span class="type">ScheduledExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//延迟 n 时间后，执行一次，延迟任务</span></span><br><span class="line">    executorService.schedule(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;延迟任务执行.....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定时任务，固定 N 时间执行一次 ，按照上一次任务的开始执行时间计算下一次任务开始时间</span></span><br><span class="line">    executorService.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;定时任务 scheduleAtFixedRate 执行 time:&quot;</span>+System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="number">1</span>,<span class="number">1</span>,TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定时任务，固定 N 时间执行一次 ，按照上一次任务的结束时间计算下一次任务开始时间</span></span><br><span class="line">    executorService.scheduleWithFixedDelay(()-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;定时任务 scheduleWithFixedDelay 执行 time:&quot;</span>+System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="number">1</span>,<span class="number">1</span>,TimeUnit.SECONDS);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：除了new ScheduledThreadPool 的内部实现特殊一点之外，其它线程池内部都是基于ThreadPoolExecutor类（Executor的子类）实现的。</p><h4 id="3-6-自定义ThreadPoolExecutor"><a href="#3-6-自定义ThreadPoolExecutor" class="headerlink" title="3.6.自定义ThreadPoolExecutor"></a>3.6.自定义ThreadPoolExecutor</h4><p>通过new ThreadPoolExecutor 来自定义线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">customThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//核心 4 个 ，最大 10 个 ，60s的空闲销毁非核心6个线程， 队列最大排队 10 个   = 最多同时处理 20个拒绝</span></span><br><span class="line">    <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">4</span>, <span class="number">10</span>,</span><br><span class="line">            <span class="number">60L</span>, TimeUnit.SECONDS,  <span class="comment">//最大空闲时间</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="number">10</span>),   <span class="comment">//队列排队10个</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardPolicy());    <span class="comment">//任务满了就丢弃</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">210</span> ; i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">        threadPoolExecutor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">//始终只有一个线程在执行</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:线程执行...&quot;</span>+ finalI);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-ThreadPoolExecutor重要的方法"><a href="#4-ThreadPoolExecutor重要的方法" class="headerlink" title="4.ThreadPoolExecutor重要的方法"></a>4.ThreadPoolExecutor重要的方法</h3><h4 id="4-1-Execute-执行任务"><a href="#4-1-Execute-执行任务" class="headerlink" title="4.1.Execute 执行任务"></a>4.1.Execute 执行任务</h4><p>方法实际上是Executor中声明的方法，在ThreadPoolExecutor进行了具体的实现，这个方法是ThreadPoolExecutor的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。</p><h4 id="4-2-Submit-执行任务"><a href="#4-2-Submit-执行任务" class="headerlink" title="4.2.Submit 执行任务"></a>4.2.Submit 执行任务</h4><p>方法是在ExecutorService中声明的方法，在AbstractExecutorService就已经有了具体的实现，在ThreadPoolExecutor中并没有对其进行重写，这个方法也是用来向线程池提交任务的，实际上它还是调用的execute()方法，只不过它利用了Future来获取任务执行结果。</p><h4 id="4-3-Shutdow-终止"><a href="#4-3-Shutdow-终止" class="headerlink" title="4.3.Shutdow 终止"></a>4.3.Shutdow 终止</h4><p>不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务。</p><h4 id="4-4-shutdownNow-终止"><a href="#4-4-shutdownNow-终止" class="headerlink" title="4.4.shutdownNow 终止"></a>4.4.shutdownNow 终止</h4><p>立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务。</p><h4 id="4-5-isTerminated-是否终止"><a href="#4-5-isTerminated-是否终止" class="headerlink" title="4.5.isTerminated 是否终止"></a>4.5.isTerminated 是否终止</h4><p>调用ExecutorService.shutdown方法的时候，线程池不再接收任何新任务，但此时线程池并不会立刻退出，直到添加到线程池中的任务都已经处理完成，才会退出。在调用shutdown方法后我们可以在一个死循环里面用isTerminated方法判断是否线程池中的所有线程已经执行完毕，如果子线程都结束了，我们就可以做关闭流等后续操作了。</p><h3 id="5-线程池中的最大线程数"><a href="#5-线程池中的最大线程数" class="headerlink" title="5.线程池中的最大线程数"></a>5.线程池中的最大线程数</h3><p>一般说来，线程池的大小经验值应该这样设置：（其中N为CPU的核数）如果是CPU密集型应用，则线程池大小设置为N+1，如果是IO密集型应用，则线程池大小设置为2N+1 32<em>2+1&#x3D;65 64</em>2+1&#x3D;129，如果一台服务器上只部署这一个应用并且只有这一个线程池，那么这种估算或许合理，具体还需自行测试验证。</p><p>但是，IO优化中，这样的估算公式可能更适合：最佳线程数目 &#x3D; （（线程等待时间+线程CPU时间）&#x2F;线程CPU时间 ）* CPU数目</p><p>因为很显然，线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。创建线程的个数是还要考虑 内存资源是否足够装下相当的线程</p><p>下面举个例子：</p><p>比如平均每个线程CPU运行时间为0.5s，而线程等待时间（非CPU运行时间，比如IO）为1.5s，CPU核心数为8，那么根据上面这个公式估算得到：((0.5+1.5)&#x2F;0.5)*8&#x3D;32。</p><p><code>最佳实践：通过压测来得到最优的线程数。</code></p><h2 id="三-ThreadLocal使用和原理"><a href="#三-ThreadLocal使用和原理" class="headerlink" title="三.ThreadLocal使用和原理"></a>三.ThreadLocal使用和原理</h2><h3 id="1-ThreadLocal的认识"><a href="#1-ThreadLocal的认识" class="headerlink" title="1.ThreadLocal的认识"></a>1.ThreadLocal的认识</h3><h4 id="1-1-一个面试题引发的血案"><a href="#1-1-一个面试题引发的血案" class="headerlink" title="1.1.一个面试题引发的血案"></a>1.1.一个面试题引发的血案</h4><p>面试官问：SpringMVC的Controller是单例还是多例？用单例为了提高性能,不用每个请求来都创建一个对象!其中的成员变量是否有线程安全问题，如何解决？？？ 不用用成员变量来存放公共资源!</p><p>解决方案：一是使用局部变量[绝大多数情况–&gt;crud的请求参数都是使用形参接收]，</p><p>​ 二是使用 ThreadLcal 来实现。</p><p>1 springmvc的controller由于没有设置Scope[spring bean的作用域],所有默认是单例,这样做的目的是为提升效率,不用每个请求都创建controller对象.</p><p>2 由于是单例,我们不在使用成员变量来存在共享数据,如果要用的话,可以用锁但是效率低.那其实可以用ThreadLocal. 并不是多个线程共享数据,而是本线程中共享数据. 如果硬是要多个线程共享,就要加锁.,而仅仅是一个请求共享数据,可以ThreadLocal.</p><p><img src="/breeze/498cfd8e/1692781683120.png" alt="1692781683120"></p><p>​</p><h4 id="1-2-什么是ThreadLocal-线程内部共享数据"><a href="#1-2-什么是ThreadLocal-线程内部共享数据" class="headerlink" title="1.2.什么是ThreadLocal(线程内部共享数据)"></a>1.2.什么是ThreadLocal(线程内部共享数据)</h4><p>ThreadLocal 是解决线程安全问题一个很好的思路，<strong>它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题</strong>。在很多情况下，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。</p><p>简单理解可以把ThreadLocal看做是一个key-value结构底层维护了一个ThreadLocal.ThreadLocalMap结构，ThreadLocal自动把当前线程副本作为Key,而Value就是我们存储的值。举例：在A线程中存储一个元素到ThreadLocal，也只能在A线程中才能取出这个值，其他线程获取不到，从而就没有了线程并发问题。</p><p><strong>ThreadLocal使用场景</strong></p><p>由于ThreadLcal可以把数据绑定到当前线程，所以只要把数据设置到ThreadLcal，只要程序还是在同一个线程中执行，无论在什么地方什么时候都可以直接通过ThreadLcal取值，无效方法传递参数，非常方便，所以在众多框架中ThreadLcal的身影也我非常多的。</p><ol><li><strong>RequestContextHolder</strong> ：保存请求对象</li><li>LocaleContextHolder ：Spring国际化相关</li><li>InheritableThreadLocalSecurityContextHolderStrategy ：Security存储SecurityContext</li></ol><h4 id="1-3-ThreadLcal的API"><a href="#1-3-ThreadLcal的API" class="headerlink" title="1.3.ThreadLcal的API"></a>1.3.ThreadLcal的API</h4><p>ThreadLcal提供了两个方法</p><ul><li>threadLocal.set(“value”) ：设置值，把值和当前线程绑定</li><li>threadLocal.get() : 从当前线程中取出绑定的值。</li></ul><p>来看一个案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">   </span><br><span class="line">        threadLocal.set(<span class="string">&quot;main-value&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;main线程获取：&quot;</span>+threadLocal.get());  <span class="comment">//打印 main-value</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-ThreadLocal源码"><a href="#2-ThreadLocal源码" class="headerlink" title="2.ThreadLocal源码"></a>2.ThreadLocal源码</h3><h4 id="2-1-set方法"><a href="#2-1-set方法" class="headerlink" title="2.1.set方法"></a>2.1.set方法</h4><p>方法的执行流程如下</p><ul><li>拿到当前线程Thread对象，Thread中包含了ThreadLocal.ThreadLocalMap类型的字段threadLocals</li><li>从Thread拿到ThreadLocal.ThreadLocalMap</li><li>以this(ThreadLocal)作为key，把设置的value保存到ThreadLocal.ThreadLocalMap中,ThreadLocalMap底层使用 ThreadLocal.ThreadLocalMap.Entry 结构存储key-value</li></ul><p>源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadLocal</span>&#123; </span><br><span class="line">    ...省略...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">            <span class="comment">//1.拿到当前线程</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="comment">//2.拿到当前线程Thread中的ThreadLocal.ThreadLocalMap</span></span><br><span class="line">            <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">            <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">//3.这里的this是ThreadLocal,把ThreadLocal作为key，把传入的值作为值，存储到Thread中的ThreadLocalMap中</span></span><br><span class="line">                map.set(<span class="built_in">this</span>, value);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                createMap(t, value);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ThreadLocalMap 在 Thread中</span></span><br><span class="line">     ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thread中包含ThreadLocal.ThreadLocalMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">	ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    ...省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal在每个线程中对该变量会创建一个副本，即每个线程内部都会有一个该变量，且在线程内部任何地方都可以使用，线程之间互不影响，这样一来就不存在线程安全问题，也不会严重影响程序执行性能。所以 ThreadLocal 用于线程间的数据隔离。</p><p><img src="/breeze/498cfd8e/1635561582892.png" alt="1635561582892"></p><h4 id="2-2-put方法"><a href="#2-2-put方法" class="headerlink" title="2.2.put方法"></a>2.2.put方法</h4><p>该方法的执行流程如下</p><ul><li>拿到当前线程Thread对象，Thread中包含了ThreadLocal.ThreadLocalMap类型的字段threadLocals</li><li>从Thread拿到ThreadLocal.ThreadLocalMap</li><li>以this(ThreadLocal)作为key,拿到ThreadLocalMap.Entry，取value作为值返回</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="comment">//1.拿到线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    	<span class="comment">//2.拿到线程中的ThreadLocalMap</span></span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//以ThreadLocal作为key,</span></span><br><span class="line">            ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="comment">//3.返回值</span></span><br><span class="line">                <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-内存泄漏问题"><a href="#2-3-内存泄漏问题" class="headerlink" title="2.3.内存泄漏问题"></a>2.3.内存泄漏问题</h4><p><strong>ThreadLocalMap中用于存储数据的entry定义，使用了弱引用，下次垃圾回收就会被回收调用,可能造成内存泄漏(明明没有使用,但是jvm回收不了)。</strong></p><p>当线程没有结束，但是ThreadLocal对象已经被回收，则可能导致线程中存在ThreadLocalMap的键值对，造成内存泄露。（ThreadLocal被回收，ThreadLocal关联的线程共享变量还存在）。解决办法：</p><ul><li>使用完线程共享变量后，显式调用ThreadLocalMap.remove方法清除线程共享变量；</li><li>ThreadLocal定义为private static final，这样ThreadLocal的弱引用问题则不存在了。</li></ul><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cy0628/p/15086201.html">https://www.cnblogs.com/cy0628/p/15086201.html</a></p><p>重点:</p><p>在 Java 中，引用类型是指对象的引用，它们指向在堆上分配的对象。Java 中有四种引用类型：强引用、软引用、弱引用和虚引用。</p><ol><li>强引用：最常见的引用类型，也是默认的引用类型。当我们通过 new 关键字创建一个对象并将其赋值给一个变量时，这个变量就持有了该对象的强引用。只要强引用存在，垃圾回收器就不会回收该对象。如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CodeObject</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">//obj 是一个强引用</span></span><br></pre></td></tr></table></figure><ol><li>软引用：软引用通常用于实现内存敏感的高速缓存等功能，在系统内存不足时可以被回收。如果一个对象只有软引用与之关联，在系统内存不足时，垃圾回收器就会回收这个对象。SoftReference 类可以实现软引用，如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">SoftReference&lt;Object&gt; softRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(obj); <span class="comment">//softRef 是一个软引用</span></span><br></pre></td></tr></table></figure><ol><li>弱引用：弱引用比软引用更弱，只能生存到下一次垃圾回收发生之前。当垃圾回收器扫描到一个只有弱引用与之关联的对象时，会将这个对象标记为可回收。WeakReference 类可以实现弱引用，如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copy <span class="type">CodeObject</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">WeakReference&lt;Object&gt; weakRef = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(obj); <span class="comment">//weakRef 是一个弱引用</span></span><br></pre></td></tr></table></figure><ol><li>虚引用：也称为幽灵引用，是最弱的一种引用类型。无法通过虚引用访问对象本身，也无法通过虚引用获取一个对象实例。虚引用主要用于管理堆外内存。PhantomReference 类可以实现虚引用，如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copy <span class="type">CodeObject</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">ReferenceQueue&lt;Object&gt; refQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">PhantomReference&lt;Object&gt; phantomRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(obj, refQueue); <span class="comment">//phantomRef 是一个虚引用</span></span><br></pre></td></tr></table></figure><p>总之，在 Java 中，通过引用类型可以控制对象的声明周期和内存使用情况。不同的引用类型在处理垃圾回收和内存分配的方面有不同的特点，这些特点可以根据具体的业务场景进行选择和配置。</p><h2 id="四-锁的使用"><a href="#四-锁的使用" class="headerlink" title="四.锁的使用"></a>四.锁的使用</h2><h3 id="1-锁的认识-为什么要使用锁-多个线程并发访问共享资源-通过上锁保证数据安全"><a href="#1-锁的认识-为什么要使用锁-多个线程并发访问共享资源-通过上锁保证数据安全" class="headerlink" title="1.锁的认识    为什么要使用锁:多个线程并发访问共享资源,通过上锁保证数据安全."></a>1.锁的认识 为什么要使用锁:多个线程并发访问共享资源,通过上锁保证数据安全.</h3><h4 id="1-1-线程安全概述"><a href="#1-1-线程安全概述" class="headerlink" title="1.1.线程安全概述"></a>1.1.线程安全概述</h4><p>​	线程安全是多线程编程时的计算机程序代码中的一个概念。在拥有<strong>共享数据</strong>的多条线程并行执行的程序<strong>中，线程安全的代码会通过线程同步&amp;乐观锁等机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。</strong></p><h4 id="1-2-线程安全的实现方法"><a href="#1-2-线程安全的实现方法" class="headerlink" title="1.2.线程安全的实现方法"></a>1.2.线程安全的实现方法</h4><p>线程安全的保证一般使用<strong>锁</strong>来实现，锁的一种宏观分类方式是<strong>悲观锁和乐观锁</strong>。悲观锁与乐观锁并不是特指某个锁（Java中没有哪个Lock实现类就叫PessimisticLock或OptimisticLock），<strong>而是在并发情况下的两种不同策略</strong>。</p><h4 id="1-3-乐观锁和悲观锁"><a href="#1-3-乐观锁和悲观锁" class="headerlink" title="1.3.乐观锁和悲观锁"></a>1.3.乐观锁和悲观锁</h4><ul><li>悲观锁（Pessimistic Lock）：</li></ul><p>定义：就是很悲观，每次去拿数据的时候都认为别人会修改。所以每次在<strong>拿数据</strong>的时候都会上锁。这样别人想拿数据就被挡住，直到悲观锁被释放。</p><p>互斥同步：互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步（Blocking Synchronization）。从处理问题的方式上说，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施（例如加锁），那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p><p>举例：<strong>synchronized</strong> ，<strong>ReentrantLock</strong></p><ul><li>乐观锁（Optimistic Lock）：</li></ul><p>定义：就是很乐观，每次去拿数据的时候都认为别人不会修改。所以<strong>不会上锁，不会上锁</strong>！但是如果	想要更新数据，则会在更新前检查在读取至更新这段时间别人有没有修改过这个数据。如果修改过，	则重新读取，再次尝试更新，循环上述步骤直到更新成功（当然也允许更新失败的线程放弃操作）。</p><p>说到乐观锁，就必须提到一个概念：CAS,什么是<strong>CAS</strong>呢？Compare-and-Swap，即比较并替换，也有叫做Compare-and-Set的，比较并设置。</p><p>非阻塞同步：基于冲突检测的乐观并发策略，通俗地说，就是先进行操作，如果没有其他线程争用共	享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见	的补偿措施就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步（Non-Blocking Synchronization）。</p><p>举例：CAS ,Atomic</p><h4 id="1-4-锁相关概念"><a href="#1-4-锁相关概念" class="headerlink" title="1.4.锁相关概念"></a>1.4.锁相关概念</h4><p><strong>Java中的锁</strong></p><p><img src="/breeze/498cfd8e/1635562493585.png" alt="1635562493585"></p><p>解释：</p><p>是否要加锁</p><ul><li><p>悲观锁是要加锁的，如Synchronization ，ReentrantLock</p></li><li><p>乐观锁是不加锁的：如对于Mysql中的数据而言，可以通过版本号，时间戳等来判断数据是否被并发修改</p></li></ul><p>是否要阻塞</p><ul><li><p>互斥锁(阻塞)：如果一个线程尝试获取锁失败，可以进行阻塞等待别人释放锁后再尝试获取锁，如Synchronization</p></li><li><p>自旋锁(不阻塞)：当一个线程尝试去获取某一把锁的时候，如果这个锁此时已经被别人获取(占用)，那么此线程就无法获取到这把锁，该线程将会等待，间隔一段时间后会再次尝试获取。这种采用循环加锁 -&gt; 等待的机制被称为自旋锁(spinlock)。</p></li><li><p>适应性自旋锁(不阻塞)：在自旋锁的基础上自旋，尝试一定的次数还是获取不到锁就放弃获取锁，这种模式叫适应性自旋。</p></li></ul><p>是否要排队加锁</p><ul><li><p>公平锁(排队加锁)：多个线程都在竞锁时是否要按照先后顺序排队加锁，如果是那就是公平锁</p></li><li><p>非公平锁(不排队加锁)：多个线程都在竞锁时不需要排队加锁，是为非公平锁</p></li></ul><p>是否可重入</p><ul><li><p>可重入锁：允许同一个线程多次获取同一把锁，是为可重入锁：比如一个递归函数里有加锁操作，递归过程中这个锁会阻塞自己吗？如果不会，那么这个锁就是可重入锁（因为这个原因可重入锁也叫做递归锁）。Java里只要以Reentrant开头命名的锁都是可重入锁，Synchronization 也是可重入的</p></li><li><p>非可重入锁：一个线程在多个流程中不可用获取到同一把锁，是为非重入锁</p></li></ul><p>可否共享锁</p><ul><li><p>共享锁：多个线程可以共享一把锁，如多个线程同时读，一般是可共享读锁 ：如读锁</p></li><li><p>排他锁：多个线程不可用共享一把锁，比如修改数据时别人是不能修改的的：如写锁 (Mysql)</p></li></ul><h3 id="2-线程同步Synchronized"><a href="#2-线程同步Synchronized" class="headerlink" title="2 线程同步Synchronized"></a>2 线程同步Synchronized</h3><h4 id="2-1-Synchronized的用法"><a href="#2-1-Synchronized的用法" class="headerlink" title="2.1. Synchronized的用法"></a>2.1. Synchronized的用法</h4><p>synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种：</p><ul><li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，锁标识对象就是()里面的对象</li><li>修饰一个非静态方法，被修饰的方法称为同步方法，其作用的范围是整个方法，锁标识对象就是this</li><li>修饰一个静态的方法，其作用的范围是整个静态方法，锁标识对象就是该方法所在类的字节码对象</li></ul><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ronghuanet._04threadsafe._01sys;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SysTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开四个窗口买</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">MyTicketRunable</span> <span class="variable">ticketRunable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTicketRunable</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(ticketRunable).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTicketRunable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticketNum</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="comment">//            synchronized (this)&#123; //1 同步代码块 this锁标识对象</span></span><br><span class="line"><span class="comment">//                if (ticketNum&gt;0)&#123;</span></span><br><span class="line"><span class="comment">//                    System.out.println(ticketNum+&quot;===&quot;+Thread.currentThread().getName()+&quot;==================&quot;);</span></span><br><span class="line"><span class="comment">//                    ticketNum--;</span></span><br><span class="line"><span class="comment">//                    try &#123;</span></span><br><span class="line"><span class="comment">//                        Thread.sleep(10);</span></span><br><span class="line"><span class="comment">//                    &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//                        e.printStackTrace();</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"><span class="comment">//                &#125;else</span></span><br><span class="line"><span class="comment">//                &#123;</span></span><br><span class="line"><span class="comment">//                    return;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//this.saleTicket();</span></span><br><span class="line"></span><br><span class="line">            saleStaticTicket();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">saleTicket</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//2 同步普通方法---锁标识对象就是this</span></span><br><span class="line">        <span class="keyword">if</span> (ticketNum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(ticketNum+<span class="string">&quot;===&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;==================&quot;</span>);</span><br><span class="line">            ticketNum--;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Runtime.getRuntime().exit(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">saleStaticTicket</span><span class="params">()</span>&#123; <span class="comment">//MyTicketRunable.class</span></span><br><span class="line">        <span class="comment">//3 同步静态方法---锁标识对象就是当前类字节码对象</span></span><br><span class="line">        <span class="keyword">if</span> (ticketNum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(ticketNum+<span class="string">&quot;===&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;==================&quot;</span>);</span><br><span class="line">            ticketNum--;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Runtime.getRuntime().exit(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-Synchronized-原理"><a href="#2-2-Synchronized-原理" class="headerlink" title="2.2.Synchronized 原理"></a>2.2.Synchronized 原理</h4><p>synchronized是基于JVM内置锁实现，通过锁表示对象Monitor(监视器锁)实 现，基于进入与退出Monitor对象实现方法与代码块同步，监视器锁的实现依赖 底层操作系统的Mutex lock（互斥锁）实现，它是一个重量级锁性能较低。当 然，JVM内置锁在1.5之后版本做了重大的优化，如锁粗化（Lock Coarsening）、锁消除（Lock Elimination）、轻量级锁（Lightweight Locking）、偏向锁（Biased Locking）、适应性自旋（Adaptive Spinning）等 技术来减少锁操作的开销，内置锁的并发性能已经基本与Lock持平。Synchronized关键字在编译的字节码中加入了两条指令来进行代码的同步。</p><p><strong>monitorenter：加锁</strong></p><p>每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</p><ul><li>如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。</li><li>如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.</li><li>如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</li></ul><p><strong>Monitorexit ：释放</strong></p><p>执行monitorexit的线程必须是objectref所对应的monitor的所有者。</p><ul><li>指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。</li><li>其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。</li></ul><p>　</p><p>通过这两段描述，我们应该能很清楚的看出Synchronized的实现原理，Synchronized的语义底层是通过一个monitor的对象来完成，其实wait&#x2F;notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait&#x2F;notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。</p><p><img src="/breeze/498cfd8e/1666257405054.png" alt="1666257405054"></p><p><img src="/breeze/498cfd8e/1689733888195.png" alt="1689733888195"></p><p><strong>简单理解</strong>：Synchronized基于JVM内置锁实现，通过竞争锁标识对象Monitor(监视器锁)实现，通过进入与退出对象的Monitor来实现方法与代码块同步。对象的JDK1.5之后 ，Synchronized会从无锁升级为偏向锁，再升级为轻量级锁，最后升级为重量级锁。后续还会说到Synchronized的优化。</p><p><img src="/breeze/498cfd8e/1666257853845.png" alt="1666257853845"></p><h4 id="2-3-synchronized的优化"><a href="#2-3-synchronized的优化" class="headerlink" title="2.3.synchronized的优化"></a>2.3.synchronized的优化</h4><p><strong>用户态和内核态</strong></p><ul><li>内核态</li></ul><p>CPU可以访问内存所有数据，包括外围设备，例如硬盘，网卡。CPU也可以将自己从一个程序切换到另一个程序</p><ul><li>用户态</li></ul><p>​ 只能受限的访问内存，切不允许访问外围设备占用CPU的能力被剥夺，CPU资源可以被其他程序获取。之所以会有这样的却分是为了防止用户进程获取别的程序的内存数据，或者获取外围设备的数据。</p><p>Synchronized原本是依赖操作系统实现的，因此在使用synchronized同步锁的时候需要进行用户态到内核态的切换，简单来说在JVM中monitorenter和monitorexit字节码依赖于底层的操作系统的Mutex Lock来实现的，但是由于使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的。</p><p><strong>jdk 1.6及其之后的优化</strong></p><p>对象头：每个对象都拥有对象头，对象头由Mark World ，指向类的指针，以及数组长度三部分组成，锁升级主要依赖Mark Word中的锁标志位和释放偏向锁标识位。</p><ul><li>偏向锁</li></ul><p>大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是在某个线程	获得锁之后（线程的id会记录在对象的Mark Word锁标志位中），消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。(第二次还是这个线程进来就不需要重复加锁，基本无开销)，如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。</p><ul><li>轻量级锁（CAS）：</li></ul><p>轻量级锁是由偏向锁升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁自旋锁）；没有抢到锁的线程将自旋，获取锁的操作。轻量级锁的意图是在没有多线程竞争的情况下，通过CAS操作尝试将MarkWord锁标志位更新为指向LockRecord的指针，减少了使用重量级锁的系统互斥量产生的性能消耗。</p><p>长时间的自旋操作是非常消耗资源的，一个线程持有锁，其他线程就只能在原地空耗CPU，执行不了任何有效的任务，这种现象叫做忙等（busy-waiting）</p><ul><li>重量级锁：</li></ul><p>如果锁竞争情况严重，某个达到最大自旋次数**(10次默认)的**线程，会将轻量级锁升级为重量级锁，重量级锁则直接将自己挂起，在JDK1.6之前，synchronized直接加重量级锁，很明显现在得到了很好的优化。</p><p>虚拟机使用CAS操作尝试将MarkWord更新为指向LockRecord的指针，如果更新成功表示线程就拥有该对象的锁；如果失败，会检查MarkWord是否指向当前线程的栈帧，如果是，表示当前线程已经拥有这个锁；如果不是，说明这个锁被其他线程抢占，此时膨胀为重量级锁。</p><h3 id="3-线程并发库组成"><a href="#3-线程并发库组成" class="headerlink" title="3.线程并发库组成"></a>3.线程并发库组成</h3><p>​	其实，显示锁（Lock）是属于线程并发库（java.util.concurrent）里面一种功能，java.util.concurrent是专门Java并发设计编程包。作者Doug Lea,所以先来看一下线程并发库的一些功能。</p><h4 id="3-1-显示锁-java-util-concurrent-locks"><a href="#3-1-显示锁-java-util-concurrent-locks" class="headerlink" title="3.1. 显示锁 java.util.concurrent.locks"></a>3.1. 显示锁 java.util.concurrent.locks</h4><p>显示锁：需要自己显示的加锁，比如 Synchronized 使用的是JVM内置锁实现的，它就不是显示锁</p><p><img src="/breeze/498cfd8e/1635562880150.png" alt="1635562880150"></p><h4 id="3-2-原子变量类-（乐观锁）"><a href="#3-2-原子变量类-（乐观锁）" class="headerlink" title="3.2. 原子变量类 （乐观锁）"></a>3.2. 原子变量类 （乐观锁）</h4><p>java.util.concurrent.atomic：为了实现原子性操作提供的一些原子类，使用的是乐观锁实现</p><p><img src="/breeze/498cfd8e/1635562906741.png" alt="1635562906741"></p><h4 id="3-3-线程池相关-java-util-concurrent"><a href="#3-3-线程池相关-java-util-concurrent" class="headerlink" title="3.3.线程池相关 java.util.concurrent"></a>3.3.线程池相关 java.util.concurrent</h4><p>通过线程池操作线程可以增加线程的复用性，防止频繁的创建，销毁线程。</p><p><img src="/breeze/498cfd8e/1635562956683.png" alt="1635562956683"></p><h4 id="3-4-并发容器类-java-util-concurrent"><a href="#3-4-并发容器类-java-util-concurrent" class="headerlink" title="3.4.并发容器类  java.util.concurrent"></a>3.4.并发容器类 java.util.concurrent</h4><p>并发容器都是线程安全的，比如在多线程中可以使用ConcurrentHashMap代替HashMap</p><p><img src="/breeze/498cfd8e/1635562982710.png" alt="1635562982710"></p><h4 id="3-5-同步工具类-java-util-concurrent"><a href="#3-5-同步工具类-java-util-concurrent" class="headerlink" title="3.5.同步工具类 java.util.concurrent"></a>3.5.同步工具类 java.util.concurrent</h4><p><img src="/breeze/498cfd8e/1635563011932.png" alt="1635563011932"></p><h3 id="4-线程同步-lock"><a href="#4-线程同步-lock" class="headerlink" title="4.线程同步-lock"></a>4.线程同步-lock</h3><h4 id="4-1-Lock概述"><a href="#4-1-Lock概述" class="headerlink" title="4.1.Lock概述"></a>4.1.Lock概述</h4><p>在java中锁的实现主要有两类：内部锁 synchronized（对象内置的monitor锁）和显示锁java.util.concurrent.locks.<strong>Lock</strong>。在 java.util.concurrent.locks 包中有很多Lock的实现类，常用的有 <strong>ReentrantLock</strong> 和<strong>ReentrantReadWriteLock</strong>，其实现都依赖 java.util.concurrent.AbstractQueuedSynchronizer(AQS) 类。</p><h4 id="4-2-Lock的使用"><a href="#4-2-Lock的使用" class="headerlink" title="4.2.Lock的使用"></a>4.2.Lock的使用</h4><p>lock是一个接口，主要有以下几个方法：</p><ul><li><p>lock()：获取锁，如果锁被占用则一直等待</p></li><li><p>unlock():释放锁</p></li><li><p>tryLock(): 注意返回类型是boolean，如果获取锁的时候锁被占用就返回false，否则返回true</p></li><li><p>tryLock(long time, TimeUnit unit)：比起tryLock()就是给了一个时间期限，操作这个时间期限拿不到锁就返回false。</p></li></ul><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    RunnableDemo(String name)&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建锁对象</span></span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;线程:&quot;</span>+<span class="built_in">this</span>.name+<span class="string">&quot; 执行...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span>  <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">100</span> ; i++)&#123;</span><br><span class="line">            <span class="comment">//加锁</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(number &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;：卖出：&quot;</span>+number);</span><br><span class="line">                    number = number - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//释放锁</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RunnableDemo</span> <span class="variable">runnableDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunnableDemo</span>(<span class="string">&quot;RunnableDemo&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(runnableDemo).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(runnableDemo).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-synchronized（隐式锁）与Lock（显示）的区别"><a href="#4-3-synchronized（隐式锁）与Lock（显示）的区别" class="headerlink" title="4.3. synchronized（隐式锁）与Lock（显示）的区别"></a>4.3. synchronized（隐式锁）与Lock（显示）的区别</h4><p>联系:都是悲观锁,都是jvm级别</p><p>区别:</p><p>（1）Lock的加锁和解锁都是由java代码实现的（api），而synchronize的加锁和解锁的过程是由JVM管理的。(jvm)</p><p>（2）synchronized能锁住类、方法和代码块，而Lock是代码执行块范围内的。</p><p>（3）Lock能提高多个线程读操作的效率； 在jdk1.6之前lock的效率远远高于sys，但是之后竞争少的情况效率差不多。</p><p><img src="/breeze/498cfd8e/1635563493780.png" alt="1635563493780"></p><p><strong>①sync是个关键字,lock是个类</strong></p><p><strong>②sys上锁和释放锁都是由jvm,没法在代码中干预,而lock需要手动加锁和释放锁</strong></p><p><strong>③sync没法判断锁的状态,lock可以通过trylock方法判断状态</strong></p><p><strong>④reentrenlock是默认是非公平,支持公平锁</strong>,sys是非公平</p><h4 id="4-4-Lock的底层原理"><a href="#4-4-Lock的底层原理" class="headerlink" title="4.4. Lock的底层原理"></a>4.4. Lock的底层原理</h4><p>​ AbstractQueuedSynchronizer(AQS)：抽象队列同步器！ 参考vip的pdf文档!</p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43141726/article/details/121562620">https://blog.csdn.net/qq_43141726/article/details/121562620</a></p><p><img src="/breeze/498cfd8e/1692776930338.png" alt="1692776930338"></p><h3 id="5-线程安全-乐观锁"><a href="#5-线程安全-乐观锁" class="headerlink" title="5.线程安全-乐观锁"></a>5.线程安全-乐观锁</h3><h4 id="5-1-乐观锁概述"><a href="#5-1-乐观锁概述" class="headerlink" title="5.1.乐观锁概述"></a>5.1.乐观锁概述</h4><p>​	乐观锁是不加锁的，只是在修改数据的时候先做判断，如果数据没被别人修改即可提交修改，否则不做修改，做出重试或其他的补偿行为，在Java中 Atomic开头的类就是基于CAS实现的乐观锁。</p><h4 id="5-2-Atomic案例"><a href="#5-2-Atomic案例" class="headerlink" title="5.2.Atomic案例"></a>5.2.Atomic案例</h4><p><strong>AtomicInteger</strong></p><p>AtomicInteger使用了CAS实现的乐观锁。即：比较和交换， 乐观锁全程不加锁，但在做数据交换的时候会先比较一下原本数据是否被别的线程修改(是否有线程并发)，如果没有，就修改数据，否则就不做修改。源码如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mliutm._04threadsafe._03atomic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开四个窗口买</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">MyTicketRunable</span> <span class="variable">ticketRunable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTicketRunable</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(ticketRunable).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTicketRunable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">ticketNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ticketNum.getAndDecrement(); <span class="comment">//i-- --i</span></span><br><span class="line">            <span class="keyword">if</span> (result&lt;<span class="number">1</span>)</span><br><span class="line">                System.exit(-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;买了&quot;</span>+result+<span class="string">&quot;票&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-乐观锁使用场景"><a href="#5-3-乐观锁使用场景" class="headerlink" title="5.3.乐观锁使用场景"></a>5.3.乐观锁使用场景</h4><p><strong>数据库通过version控制</strong></p><p>在数据库层面我们也通常使用乐观锁来保证数据的并发修改问题，通常是在每一行数据增加 version,或时间戳 ，每次数据修改增加 where version &#x3D; #{version} 条件，判断数据库中的版本号和修改之间读出来的版本号是否一致，其实是在判断从读数据，到修改数据的时间段内，别的事物是否修改了该数据，如果version匹配，说明没有问题，可以直接修改，否则可以作出重试，或者回滚事物等处理方式，案例如：</p><ol><li>查询对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sql</span></span><br><span class="line">select id,version,username from t_user <span class="type">where</span> <span class="variable">id</span> <span class="operator">=</span> #&#123;id&#125;</span><br><span class="line"><span class="comment">//代码调用</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(<span class="number">1L</span>);</span><br></pre></td></tr></table></figure><p>2.修改数据库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码调用</span></span><br><span class="line">user.setUsername(“zs”);</span><br><span class="line">userMapper.updateById(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">//sql</span></span><br><span class="line">Update t_user <span class="type">set</span> <span class="variable">username</span> <span class="operator">=</span> #&#123;username&#125; , version = version + <span class="number">1</span> <span class="type">where</span> <span class="variable">id</span> <span class="operator">=</span> #&#123;id&#125; <span class="type">and</span> <span class="variable">version</span> <span class="operator">=</span> #&#123;version&#125; </span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;乐观锁</p><p>当然也可以使用UUDI，时间戳的方式控制乐观锁。另外ES也是维护了一个Version来保证并发安全。</p><h4 id="5-3-atomic"><a href="#5-3-atomic" class="headerlink" title="5.3.atomic"></a>5.3.atomic</h4><p>​ cas机制—&gt;cpu原语</p><p>在JDK<strong>1.5之后</strong>，Java<strong>程序</strong>中<strong>才可以使用CAS操作</strong>，该操作由sun.misc.Unsafe类里面的compareAndSwapInt()和compareAndSwapLong()等几个方法包装提供，虚拟机在内部对这些方法做了特殊处理，即时编译出来的结果就是一条平台相关的处理器CAS指令，没有方法调用的过程，或者可以认为是无条件内联进去了。</p><p>由于Unsafe类不是提供给用户提供调用的类（Unsafe.getUnsafe()的代码中限制了只有启动类加载器（Bootstrap ClassLoader）加载的Class才能访问它），因此，如果不采用反射手段，我们只能通过其他的Java API来间接使用它，如J.U.C包里面的整数原子类，其中的 compareAndSet()和 getAndIncrement()等方法都使用了 Unsafe 类的 CAS 操作。</p><h3 id="6-并发控制工具类"><a href="#6-并发控制工具类" class="headerlink" title="6 并发控制工具类"></a>6 并发控制工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mliutm._04concurrenttool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在java中提供控制并发的一些工具类常见的如下：</span></span><br><span class="line"><span class="comment"> *   CountDownLatch：倒计时门栓,批量数据写入 80W数据量 单线程 --&gt;多线程写入, 其中一个线程写入的时候执行报错 -要么回滚,提交</span></span><br><span class="line"><span class="comment"> *   Semaphore</span></span><br><span class="line"><span class="comment"> *   CyclicBarrier</span></span><br><span class="line"><span class="comment"> *   ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaintTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    countDownLatch.countDown();<span class="comment">//减去1</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;拴住。。。&quot;</span>);</span><br><span class="line">        countDownLatch.await(); <span class="comment">//等待</span></span><br><span class="line">        System.out.println(<span class="string">&quot;和返回耗费&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaintTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义semaphore实例，设置许可数为3，即停车位为3个</span></span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//创建五个线程，即有5辆汽车准备进入停车场停车</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;尝试进入停车场...&quot;</span>);</span><br><span class="line">                    <span class="comment">//尝试获取许可</span></span><br><span class="line">                    semaphore.acquire();<span class="comment">//-1</span></span><br><span class="line">                    <span class="comment">//模拟停车</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> (<span class="type">long</span>) (Math.random() * <span class="number">10</span> + <span class="number">1</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;进入了停车场，停车&quot;</span> + time +</span><br><span class="line">                            <span class="string">&quot;秒...&quot;</span>);</span><br><span class="line">                    Thread.sleep(time);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始驶离停车场...&quot;</span>);</span><br><span class="line">                    <span class="comment">//释放许可</span></span><br><span class="line">                    semaphore.release(); <span class="comment">//+1</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;离开了停车场！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, i + <span class="string">&quot;号汽车&quot;</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​ 信号量：多个线程竞争特定个数资源，做<strong>秒杀！限流</strong>！</p><p>克隆</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1  为什么需要克隆！！！</span></span><br><span class="line"><span class="comment">              期望保存当前对象当前一些状态,其实不克隆也可以,新建一个新的,把它属性全部拷贝过去.</span></span><br><span class="line"><span class="comment">        2 浅克隆:  对于引用类型,拷贝的是地址!  两个对象引用像同一个.改了共同对象会一起变,</span></span><br><span class="line"><span class="comment">               但是赋值一个新的给他,改变了引用地址,也就是两个不指向同一个(String)</span></span><br><span class="line"><span class="comment">        3 深度克隆:  在自己克隆方法里面要调用引用对象的克隆方法,赋值给自己属性</span></span><br><span class="line"><span class="comment">        ==========</span></span><br><span class="line"><span class="comment">        对于基本数据库类型来说,两种克隆没有区别! 但是对于引用类型,浅克隆拷贝是地址指向同一个!</span></span><br><span class="line"><span class="comment">        为了相互一点都不影响,要使用深克隆, 被引用的类型要使用Cloneable,覆写clone方法,并发在引用的类的克隆方法里面单独调用它的克隆方法克隆一个对象,赋值给这个引用类型的属性</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">package</span> cn.mliutm._07clone;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 引用类型的深度克隆</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Address</span> <span class="variable">addr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>();</span><br><span class="line">        addr.setAdd(<span class="string">&quot;杭州市&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        stu1.setNumber(<span class="number">123</span>);</span><br><span class="line">        stu1.setAddr(addr);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu2</span> <span class="operator">=</span> (Student)stu1.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;学生1：&quot;</span> + stu1.getNumber() + <span class="string">&quot;，地址：&quot;</span> + stu1.getAddr().getAdd());</span><br><span class="line">        System.out.println(<span class="string">&quot;学生2：&quot;</span> + stu2.getNumber() + <span class="string">&quot;，地址：&quot;</span> + stu2.getAddr().getAdd());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line">        addr.setAdd(<span class="string">&quot;成都市&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;学生1：&quot;</span> + stu1.getNumber() + <span class="string">&quot;，地址：&quot;</span> + stu1.getAddr().getAdd());</span><br><span class="line">        System.out.println(<span class="string">&quot;学生2：&quot;</span> + stu2.getNumber() + <span class="string">&quot;，地址：&quot;</span> + stu2.getAddr().getAdd());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line">        <span class="keyword">private</span> Address addr;</span><br><span class="line">        <span class="keyword">public</span> Address <span class="title function_">getAddr</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> addr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddr</span><span class="params">(Address addr)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.addr = addr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> number;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNumber</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.number = number;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                stu = (Student)<span class="built_in">super</span>.clone();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(CloneNotSupportedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//对于引用类型,需要在克隆方法里面调用对象的克隆方法获取新的对象</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stu.addr = (Address) addr.clone();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>  &#123;</span><br><span class="line">        <span class="keyword">private</span> String add;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getAdd</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> add;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAdd</span><span class="params">(String add)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.add = add;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>常用快速开发框架(低代码平台)</p><p>基本不写代码就能完成功能开发, 可视化代码生成器 . 有没有用过低代码平台…. 用过.</p><p>​</p><p><strong>若依(最多)</strong> jfinal(次之) spring blade……</p><p><a target="_blank" rel="noopener" href="http://ruoyi.vip/">http://ruoyi.vip/</a></p><p><strong>作业: 在若依前后端分离单体平台开发一个客户管理(t_consumer(id,name))</strong></p><p><a target="_blank" rel="noopener" href="https://gitee.com/jfinal">https://gitee.com/jfinal</a></p><p><a target="_blank" rel="noopener" href="https://bladex.cn/#/">https://bladex.cn/#/</a></p><p>终端:</p><p>​ pc浏览器(element ui,ant design pro) pc客户端(C++,java awt&#x2F;swing) 手机浏览器(专门ui组件库) 手机app(原生,混合式(React Navie,uniapp)) 各种小程序(原生,uniapp) 微信公众号(手机浏览器)</p><h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五.总结"></a>五.总结</h2><h3 id="1-重点内容"><a href="#1-重点内容" class="headerlink" title="1.重点内容"></a>1.重点内容</h3><ul><li>线程池7个参数</li><li>四种线程池</li><li>定时任务线程池</li><li>乐观锁和悲观锁</li><li>Atomic原子类</li><li>Synchronized原理</li><li>Lock的使用</li><li>CAS&amp;AQS</li><li>线程三种方式</li></ul><h3 id="2-面试必备"><a href="#2-面试必备" class="headerlink" title="2.面试必备"></a>2.面试必备</h3><ul><li>创建线程有几种方式</li><li>thread中的run和start方法有什么区别</li><li>Thread和Runnable的区别</li><li>哪种线程有返回值</li><li>Synchronized 和 lock的区别</li><li>Synchronized 锁升级原理</li><li>说一下悲观锁和乐观锁</li><li>乐观锁的使用场景&amp;你用过的框架中哪儿用到了乐观锁&amp;或者你在什么场景用到了乐观锁</li><li>线程没有抢到锁，可以作出哪些反映</li><li>线程的生命周期&amp;几种状态</li><li>sleep 和 wait的区别</li><li>Synchronized 加在方法上 锁的对象是什么 ? 加在静态方法上锁住的对象是什么？</li><li>Synchronized(this) 和 Synchronized (User.class) 的区别</li><li>Synchronized 和 volatitle 关键字的区别</li><li>一个类中两个方法中都有Synchronized(this) 请问能锁住吗？为什么</li><li>讲几个线程并发库中的类</li><li>你对ConcurrentHashMap的理解</li><li>ThreadLocal的作用&amp;使用场景</li><li>ThreadLocal底层结构了解吗？</li><li>线程池的7大参数</li><li>线程池的执行流程</li><li>你在什么业务中使用到了线程池</li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://mliutm.github.io">清风</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://mliutm.github.io/breeze/498cfd8e.html">https://mliutm.github.io/breeze/498cfd8e.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://mliutm.github.io" target="_blank">清风</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a></div><div class="post_share"><div class="social-share" data-image="/img/photo-1688475747590-d0db5e2412cb.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/breeze/797f8627.html" title="MySQL单机优化"><img class="cover" src="/img/premium_photo-1695185954894-e9382c6f4da8.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL单机优化</div></div></a></div><div class="next-post pull-right"><a href="/breeze/4ccc5345.html" title="蓉礼购-认证授权（十）"><img class="cover" src="/img/photo-1692708632140-ee01624d558d.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">蓉礼购-认证授权（十）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/breeze/c8b66f0a.html" title="File类"><img class="cover" src="/img/photo-1692708632140-ee01624d558d.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-15</div><div class="title">File类</div></div></a></div><div><a href="/breeze/ecebeadb.html" title="BIO-NIO-AIO深入剖析"><img class="cover" src="/img/photo-1692708632140-ee01624d558d.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-15</div><div class="title">BIO-NIO-AIO深入剖析</div></div></a></div><div><a href="/breeze/fed4c017.html" title="IO流"><img class="cover" src="/img/photo-1692708632140-ee01624d558d.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-15</div><div class="title">IO流</div></div></a></div><div><a href="/breeze/a4950fb1.html" title="Redis实战-黑马点评"><img class="cover" src="/img/photo-1688475747590-d0db5e2412cb.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-24</div><div class="title">Redis实战-黑马点评</div></div></a></div><div><a href="/breeze/ab319c68.html" title="SpringCloud-Alibaba快速入门"><img class="cover" src="/img/photo-1645943020355-305df166473d.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-13</div><div class="title">SpringCloud-Alibaba快速入门</div></div></a></div><div><a href="/breeze/4c9bef51.html" title="base抽取与代码生成器（三）"><img class="cover" src="/img/premium_photo-1695185954894-e9382c6f4da8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-28</div><div class="title">base抽取与代码生成器（三）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">清风</div><div class="author-info__description">清风洒六合，邈然不可攀</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">169</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">82</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:huangpan0805@163.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div><timing></timing></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-text">技术提升-并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9"><span class="toc-text">课程内容</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">一.线程的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="toc-text">1.线程和进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B"><span class="toc-text">1.1.什么是进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B"><span class="toc-text">1.2.什么是线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F-%E2%80%93new-Thread%E5%AD%90%E7%B1%BB-%EF%BC%8Cnew-Thread%EF%BC%88runale%E6%88%96%E8%80%85callalbe%E7%9A%84%E4%BB%BB%E5%8A%A1-%EF%BC%8C%E6%9C%80%E7%BB%88%E5%90%AF%E5%8A%A8%E7%BA%BF%E7%A8%8B%E9%83%BD%E6%98%AF%E4%BD%BF%E7%94%A8start%E6%96%B9%E6%B3%95%EF%BC%8C%E6%9C%80%E7%BB%88%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E9%83%BD%E6%98%AFrun"><span class="toc-text">2.线程三种方式 –new Thread子类 ，new Thread（runale或者callalbe的任务) ，最终启动线程都是使用start方法，最终线程调度的都是run</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%AE%9E%E7%8E%B0-Runnable-%E6%8E%A5%E5%8F%A3"><span class="toc-text">2.1.实现 Runnable 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%AE%9E%E7%8E%B0-Callable-%E6%8E%A5%E5%8F%A3"><span class="toc-text">2.2.实现 Callable 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E7%BB%A7%E6%89%BF-Thread-%E7%B1%BB"><span class="toc-text">2.3.继承 Thread 类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3-VS-%E7%BB%A7%E6%89%BF-Thread"><span class="toc-text">2.4.实现接口 VS 继承 Thread</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">3.线程生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE"><span class="toc-text">3.1.线程生命周期图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">3.2.线程的方法（了解）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-text">3.3.线程的状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-text">3.4.线程通信</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-text">二.线程池使用和原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%8B%E7%BB%8D"><span class="toc-text">1.线程池介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">1.1.为什么用线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E8%AE%A4%E8%AF%86%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">1.2.认识线程池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86"><span class="toc-text">2.线程池原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%83%E5%A4%A7%E5%8F%82%E6%95%B0"><span class="toc-text">2.1.线程池七大参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">2.2.线程池执行流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">3.线程池的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">3.1.常见的四种线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-CachedThreadPool%E5%8F%AF%E7%BC%93%E5%AD%98"><span class="toc-text">3.2.CachedThreadPool可缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-FixedThreadPool-%E5%AE%9A%E9%95%BF%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">3.3.FixedThreadPool 定长线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-SingleThreadPool-%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">3.4.SingleThreadPool 单线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-ScheduledThreadPool"><span class="toc-text">3.5. ScheduledThreadPool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-%E8%87%AA%E5%AE%9A%E4%B9%89ThreadPoolExecutor"><span class="toc-text">3.6.自定义ThreadPoolExecutor</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-ThreadPoolExecutor%E9%87%8D%E8%A6%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">4.ThreadPoolExecutor重要的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-Execute-%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1"><span class="toc-text">4.1.Execute 执行任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-Submit-%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1"><span class="toc-text">4.2.Submit 执行任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-Shutdow-%E7%BB%88%E6%AD%A2"><span class="toc-text">4.3.Shutdow 终止</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-shutdownNow-%E7%BB%88%E6%AD%A2"><span class="toc-text">4.4.shutdownNow 终止</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-isTerminated-%E6%98%AF%E5%90%A6%E7%BB%88%E6%AD%A2"><span class="toc-text">4.5.isTerminated 是否终止</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E7%BA%BF%E7%A8%8B%E6%95%B0"><span class="toc-text">5.线程池中的最大线程数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-ThreadLocal%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-text">三.ThreadLocal使用和原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-ThreadLocal%E7%9A%84%E8%AE%A4%E8%AF%86"><span class="toc-text">1.ThreadLocal的认识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E4%B8%80%E4%B8%AA%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E8%A1%80%E6%A1%88"><span class="toc-text">1.1.一个面试题引发的血案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E4%BB%80%E4%B9%88%E6%98%AFThreadLocal-%E7%BA%BF%E7%A8%8B%E5%86%85%E9%83%A8%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE"><span class="toc-text">1.2.什么是ThreadLocal(线程内部共享数据)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-ThreadLcal%E7%9A%84API"><span class="toc-text">1.3.ThreadLcal的API</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-ThreadLocal%E6%BA%90%E7%A0%81"><span class="toc-text">2.ThreadLocal源码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-set%E6%96%B9%E6%B3%95"><span class="toc-text">2.1.set方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-put%E6%96%B9%E6%B3%95"><span class="toc-text">2.2.put方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98"><span class="toc-text">2.3.内存泄漏问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">四.锁的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%94%81%E7%9A%84%E8%AE%A4%E8%AF%86-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E9%94%81-%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90-%E9%80%9A%E8%BF%87%E4%B8%8A%E9%94%81%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8"><span class="toc-text">1.锁的认识 为什么要使用锁:多个线程并发访问共享资源,通过上锁保证数据安全.</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0"><span class="toc-text">1.1.线程安全概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-text">1.2.线程安全的实现方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-text">1.3.乐观锁和悲观锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E9%94%81%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-text">1.4.锁相关概念</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5Synchronized"><span class="toc-text">2 线程同步Synchronized</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-Synchronized%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">2.1. Synchronized的用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-Synchronized-%E5%8E%9F%E7%90%86"><span class="toc-text">2.2.Synchronized 原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-synchronized%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-text">2.3.synchronized的优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%BA%93%E7%BB%84%E6%88%90"><span class="toc-text">3.线程并发库组成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E6%98%BE%E7%A4%BA%E9%94%81-java-util-concurrent-locks"><span class="toc-text">3.1. 显示锁 java.util.concurrent.locks</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E7%B1%BB-%EF%BC%88%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%89"><span class="toc-text">3.2. 原子变量类 （乐观锁）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3-java-util-concurrent"><span class="toc-text">3.3.线程池相关 java.util.concurrent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E7%B1%BB-java-util-concurrent"><span class="toc-text">3.4.并发容器类 java.util.concurrent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB-java-util-concurrent"><span class="toc-text">3.5.同步工具类 java.util.concurrent</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-lock"><span class="toc-text">4.线程同步-lock</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-Lock%E6%A6%82%E8%BF%B0"><span class="toc-text">4.1.Lock概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-Lock%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">4.2.Lock的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-synchronized%EF%BC%88%E9%9A%90%E5%BC%8F%E9%94%81%EF%BC%89%E4%B8%8ELock%EF%BC%88%E6%98%BE%E7%A4%BA%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">4.3. synchronized（隐式锁）与Lock（显示）的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-Lock%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-text">4.4. Lock的底层原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-text">5.线程安全-乐观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E4%B9%90%E8%A7%82%E9%94%81%E6%A6%82%E8%BF%B0"><span class="toc-text">5.1.乐观锁概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-Atomic%E6%A1%88%E4%BE%8B"><span class="toc-text">5.2.Atomic案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-%E4%B9%90%E8%A7%82%E9%94%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">5.3.乐观锁使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-atomic"><span class="toc-text">5.3.atomic</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">6 并发控制工具类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E6%80%BB%E7%BB%93"><span class="toc-text">五.总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%87%8D%E7%82%B9%E5%86%85%E5%AE%B9"><span class="toc-text">1.重点内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87"><span class="toc-text">2.面试必备</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/breeze/1d13ce0d.html" title="WYDG-产品目录列表-20200506"><img src="/img/photo-1653549892896-dde02867edee.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="WYDG-产品目录列表-20200506"></a><div class="content"><a class="title" href="/breeze/1d13ce0d.html" title="WYDG-产品目录列表-20200506">WYDG-产品目录列表-20200506</a><time datetime="2025-04-13T05:43:05.000Z" title="发表于 2025-04-13 13:43:05">2025-04-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/breeze/6f268337.html" title="雨雀文件下载"><img src="/img/premium_photo-1695185954894-e9382c6f4da8.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="雨雀文件下载"></a><div class="content"><a class="title" href="/breeze/6f268337.html" title="雨雀文件下载">雨雀文件下载</a><time datetime="2024-05-22T12:25:08.000Z" title="发表于 2024-05-22 20:25:08">2024-05-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/breeze/7832219d.html" title="十万字面试总结"><img src="/img/photo-1692708632140-ee01624d558d.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="十万字面试总结"></a><div class="content"><a class="title" href="/breeze/7832219d.html" title="十万字面试总结">十万字面试总结</a><time datetime="2024-02-29T02:50:00.000Z" title="发表于 2024-02-29 10:50:00">2024-02-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/breeze/7ae0ca37.html" title="Redis_30道经典面试题"><img src="/img/photo-1653549892896-dde02867edee.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Redis_30道经典面试题"></a><div class="content"><a class="title" href="/breeze/7ae0ca37.html" title="Redis_30道经典面试题">Redis_30道经典面试题</a><time datetime="2024-02-29T02:45:00.000Z" title="发表于 2024-02-29 10:45:00">2024-02-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/breeze/2a548e97.html" title="面试实战"><img src="/img/photo-1653549892896-dde02867edee.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="面试实战"></a><div class="content"><a class="title" href="/breeze/2a548e97.html" title="面试实战">面试实战</a><time datetime="2024-02-29T02:43:59.000Z" title="发表于 2024-02-29 10:43:59">2024-02-29</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/img/photo-1688475747590-d0db5e2412cb.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 <i id="heartbeat" class="fa fas fa-heartbeat"></i> 清风</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></head></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script src="/js/timing.js"></script><script id="canvas_nest" defer color="255,0,255" opacity="0.7" zindex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!0,document.body.addEventListener("input",POWERMODE)</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="天枢,天璇,天玑,天权,玉衡,开阳,瑶光" data-fontsize="15px" data-random="true" async></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>